{
  "hash": "cfd96bcc72e6bcebbf29e85482f26d3f",
  "result": {
    "markdown": "---\ntitle: \"Forest Data Analysis Report\"\noutput:\n  pdf_document:\n    latex_engine: xelatex\ntoc: true\ntoc-depth: 3\ntoc-title: Contents\ntoc-expand: 2\ntoc-location: right\nnumber-sections: true\nnumber-depth: 3\ndate: today\nauthor:\n    - name: Jakob Danel\n      email: jakob.danel@uni-muenster.de\n      url: https://github.com/jakobdanel\n      affiliations:\n      - name: Universität Münster\n        city: Münster\n        country: Germany\n    - name: Federick Bruch\n      email: f_bruc03@uni-muenster.de\n      url: https://www.uni-muenster.de/Geoinformatics/institute/staff/index.php/351/Frederick_Bruch\n      affiliations:\n      - name: Universität Münster\n        city: Münster\n        country: Germany\nbibliography: references.bib\nexecute-dir: .. \nexecute:\n  freeze: auto  # re-render only when source changes\nprefer-html: true\nformat:\n  wordcount-html: default\n---\n\n# Introduction\n\nForests, referred as the \"world's air-conditioning system\" or the \"lungs of the planet,\" play a critical role in maintaining the global environment, as noted by King Charles III. Delving into forests and their diverse tree species is essential for our comprehension of both local ecosystems and the broader globe. The combination of tree species significantly contributes to the functionality and biodiversity of a forest, as emphasized by Mori et al. in their work on forest tree biodiversity [@mori2017]. Different tree species face distinct threats, posing challenges to both the environment and human populations. For instance, the Oak processionary moth, highlighted by Sobczyk et al  [@sobczyk2014eichenprozessionsspinner]. in their study on the impact of the oak processionary moth, and the bark beetle, discussed in the work of Müller et al. on bark beetle infestations [@muller2019kaferkampfe], exemplify the varying risks associated with specific tree types.Forests play a pivotal role in climate regulation by absorbing carbon dioxide (CO$_2$) and providing habitats for a multitude of animal and plant species. Approximately 80% of all terrestrial species find their home in forests, housing more than four-fifths of all known animal and plant species outside the oceans [@Naturefund]. Recognizing the importance of gaining a comprehensive understanding of forests is imperative, particularly in unraveling the (spatial) distribution patterns of different tree species. Such insights are crucial for informed conservation efforts, sustainable management, and addressing the diverse ecological challenges that forests face.\n\nOften, forest monitoring relies on Sentinel data, offering valuable insights through various applications such as time series analysis of the deforestation process [@cremer2020potential], forest classification [@dostalova2021european], and detection of forest succession [@szostak2018using]. However, employing Sentinel data is not without challenges. Dependency on cloud coverage and limited resolution, such as the 5x5m resolution on Sentinel-1 [@copernicusSentinel1Missions], can hinder the accurate identification of individual trees.To overcome these limitations, LiDAR data emerges as a promising alternative. LiDAR provides higher resolutions and utilizes the intensity of the returned signal as an indicator of the forest structure [@dlrRaumfahrtagenturLidar]. The aim is to investigate whether LiDAR is an appropriate tool for distinguishing between tree species, with a focus on oak, beech, pine, and spruce – the most common species in North Rhine-Westphalia (NRW). This choice ensures comparable environmental conditions, including climate and altitude.\n\nThe methodology involves employing different statistical tools to analyze the distribution of LiDAR returns. Specifically, the study utilizes the random forest algorithm to predict the species of detected trees based on LiDAR data. This approach aims to enhance the precision and capabilities of forest monitoring, especially in regions like NRW, by leveraging LiDAR technology for species-specific insights. Our motivation and methodical approach leading to the following research question:\n\n**Can LiDAR technology be effectively employed to distinguish between tree species in monocultural forests in North Rhine-Westphalia (NRW), and how do the distinctive characteristics of individual tree species contribute to the accuracy of LiDAR-based classification?**\n\nWe formulate the following hypothesis:\n\n1. LiDAR data can effectively differentiate between tree species in monocultural forests in NRW, and there are statistically significant differences in the LiDAR-derived metrics among the various tree species.\n2. Random Forest classification can be used to predict the tree species of trees in monoculteral forests.\n3. Random Forest classification performance varies significantly depending on the set of LiDAR parameters used, indicating that certain combinations of parameters contribute more effectively to accurate tree species classification.\n\n\n\n\n# Methods\n\nWe first describe the processes of data acquisition and data preprocessing. Then we will propose how we analyse the distributions and how we utilize random forest predictions for species distinguishing. \n\n\n## Data acquisition\n\nOur primary objective is to identify patches where one tree species exhibits a high level of dominance, striving to capture monocultural stands within the diverse forests of Nordrhein-Westfalia (NRW). Recognizing the practical challenges of finding true monocultures, we aim to identify patches where one species is highly dominant, enabling meaningful comparisons across different species.\n\nThe study is framed within the NRW region due to the availability of an easily accessible dataset. Our focus includes four prominent tree species in NRW: oak, beech, spruce, and pine, representing the most prevalent species in the region. To ensure the validity of our findings, we derive three patches for each species, thereby confirming that observed variables are characteristic of a particular species rather than a specific patch. Each patch is carefully selected to encompass an area of approximately 50-100 hectares and contain between 5,000 and 10,000 trees. Striking a balance between relevance and manageability, these patches avoid excessive size to enhance the likelihood of capturing varied species mixes and ensure compatibility with local hardware.\n\nSpecific Goals:\n\n1. Retrieve patches with highly dominant tree species.\n2. Minimize or eliminate the presence of human-made structures within the selected patches.\n\nTo achieve our goals, we utilized the waldmonitor dataset [@welle2014] and the map provided by [@Blickensdoerfer2022], both indicating dominant tree species in NRW. We identified patches of feasible size where both sources predicted the presence of a specific species. Further validation involved examining sentinel images of these forest regions to assess the evenness of structures, leaf color distribution, and the absence of significant human-made structures such as roads or buildings. The subsequent preprocessing steps, detailed in the following subsection, involved refining our selected patches and deriving relevant variables, such as tree distribution and density, to ensure that the chosen areas align with the desired research domains.\n\n## Preprocessing\n\n::: {.cell}\n\n:::\n\n\n\nIn this research study, the management and processing of a large dataset are crucial considerations. The dataset's substantial size necessitates careful maintenance to ensure efficient handling. Furthermore, the data should be easily processable and editable to facilitate necessary corrections and precalculations within the context of our research objectives. To achieve our goals, we have implemented a framework that automatically derives data based on a shapefile, delineating areas of interest. The processed data and results of precalculations are stored in a straightforward manner to enhance accessibility. Additionally, we have designed functions that establish a user-friendly interface, enabling the execution of algorithms on subsets of the data, such as distinct species. These interfaces are not only directly callable by users but can also be integrated into other functions to automate processes. The overarching aim is to streamline the entire preprocessing workflow using a single script, leveraging only the shapefile as a basis. This subsection details the accomplishments of our R-package in realizing these goals, outlining the preprocessing steps undertaken and justifying their necessity in the context of our research.\n\nThe data are stored in a data subdirectory of the root directory in the format `species/location-name/tile-name`. To automate the matching of areas of interest with the catalog from the Land NRW[^1], we utilize the intersecting tool developed by Heisig[^2]. This tool, allows for the automatic retrieval and placement of data downloaded from the Land NRW catalog. To enhance data accessibility, we have devised an object that incorporates species, location name, and tile name (the NRW internal identifier) for each area This object facilitates the specification of the area to be processed. Additionally, we have defined an initialization function that downloads all tiles, returning a list of tile location objects for subsequent processing. A pivotal component of the package's preprocessing functionality is the map function, which iterates over a list of tile locations (effectively the entire dataset) and accepts a processing function as an argument. The subsequent paragraph outlines the specific preprocessing steps employed, all of which are implemented within the mapping function.\n\nTo facilitate memory-handling capabilities, each of the tiles, where one area can span multiple tiles, has been split into manageable chunks. We employed a 50x50m size for each tile, resulting in the division of original 1km x 1km files into 400 tiles. These tiles are stored in our directory structure, with each tile housed in a directory named after its tile name and assigned an id as the filename. Implementation-wise, the `lidr::catalog_retile` function was instrumental in achieving this segmentation. The resulting smaller chunks allow for efficient iteration during subsequent preprocessing steps.\n\nThe next phase involves reducing our data to the actual size by intersecting the tiles with the defined area of interest. Using the `lidR::merge_spatial` function, we intersect the area derived from the shapefile, removing all point cloud items outside this region. Due to our tile-wise approach, empty tiles may arise, and in such cases, those tiles are simply deleted.\n\nFollowing the size reduction to our dataset, the next step involves correcting the `z` values. The `z` values in the data are originally relative to the ellipsoid used for referencing, but we require them to be relative to the ground. To achieve this, we utilize the `lidR::tin` function, which extrapolates a convex hull between all ground points (classified by the data provider) and calculates the z value based on this structure.\n\nSubsequently, we aim to perform segmentation for each distinct tree, marking each item of the point cloud with a tree ID. We employ the algorithm described by @li2012, using parameters `li2012(dt1 = 2, dt2 = 3, R = 2, Zu = 10, hmin = 5, speed_up = 12)`. The meanings of these parameters are elucidated in Li et al.'s work [@li2012].\n\nFinally, the last preprocessing step involves individual tree detection, seeking a single `POINT` object for each tree. The `lidR::lmf` function, an implementation of the tree data using a local maximum approach, is utilized for this purpose [@popescu2004]. The results are stored in GeoPackage files within our data structure.\n\nSee @sec-appendix-preprocessing for the implementation of the preprocessing.\n\n[^1]: https://www.opengeodata.nrw.de/produkte/geobasis/hm/3dm_l_las/3dm_l_las/, last visited 7th Dec 2023\n[^2]: https://github.com/joheisig/GEDIcalibratoR, last visited 7th Dec 2023\n\n## Analysis of different distributions\n\nAnalysis of data distributions is a critical aspect of our research, with a focus on comparing two or more distributions. Our objective extends beyond evaluating the disparities between species; we also aim to assess differences within a species. To gain a comprehensive understanding of the data, we employ various visualization techniques, including histograms, density functions, and box plots.\n\nIn tandem with visualizations, descriptive statistics, such as means, standard errors, and quantiles, are leveraged to provide key insights into the central tendency and variability of the data.\n\nFor a more quantitative analysis of distribution dissimilarity, statistical tests are employed. The Kullback-Leibler (KL) difference serves as a measure to compare the similarity of a set of distributions. This involves converting distributions into their density functions, with the standard error serving as the bandwidth. The KL difference is calculated for each pair of distributions, as it is asymmetric. For the two distributions the KL difference is defined as following [@kullback1951kullback]:\n\n$$\nD_{KL}(P \\, \\| \\, Q) = \\sum_i P(i) \\log\\left(\\frac{P(i)}{Q(i)}\\right)\n$$\n\nTo obtain a symmetric score, the Jensen-Shannon Divergence (JSD) is utilized [@grosse2002analysis], expressed by the formula:\n\n$$\nJS(P || Q) = \\frac{1}{2} * KL(P || M) + \\frac{1}{2} * KL(Q || M)\n$$\nHere, $M = \\frac{1}{2} * (P + Q)$. The JSD provides a balanced measure of dissimilarity between distributions [@Brownlee2019Calculate]. For comparing the different scores to each other, we will use averages.\n\nAdditionally, the Kolmogorov-Smirnov Test is implemented to assess whether two distributions significantly differ from each other. This statistical test offers a formal evaluation of the dissimilarity between empirical distribution functions.\n\n## Random Forest for predicting species\n\nThe aim of our research is to investigate the feasibility of developing a predictive model for tree species classification based on derived parameters. To accomplish this objective, we employed the Random Forest algorithm, as introduced by [@breiman2001random], which leverages multiple decision trees to predict the species of a given tree based on its characteristics.\n\nThe dataset utilized in our study consists of identified trees, and our primary goal is to predict the species of each tree. To establish ground truth for training and validation of the model, we assigned the dominant species to each distinct patch.\n\nFor validation purposes, we adopted a spatial cross-validation methodology, specifically implementing the leave-one-out principle. This technique systematically excludes a particular portion of the dataset in each iteration [@brovelli2008accuracy]. In our spatial cross-validation, the group left out is determined based on their spatial characteristics  [@valavi2018blockcv].\n\nOur combined approach entails designating the patches with tree detections as the left-out group. The model is trained on the training split and validated using the left-out (validation) split of the data. Ground truth and predictions from each iteration are stored, and the results from all iterations are aggregated into a confusion matrix for a comprehensive analysis.\n\nIn our evaluation of results, we utilized various statistical measurements. The *accuracy*, defined as the ratio of correct predictions to all predictions [@alvarez2002exact], is calculated using the formula\n$$\\text{Accuracy} = \\frac{\\text{Correct Predictions}}{\\text{All Predictions}}$$\nThis metric provides insight into the percentage of correct predictions.\n\nTo normalize accuracy in the context of a small number of classes ($n = 4$), Kohen's Kappa Index was employed [@fleiss1969large]. The formula is given by\n$$\\kappa = \\frac{P_o - P_e}{1 - P_e}$$\nwhere $P_o$ represents the observed agreement between raters, and $P_e$ is the expected agreement, accounting for the probability of chance agreement.\n\nAnother crucial metric, *precision*, commonly used in binary classification, measures the accuracy of positive predictions [@cleverdon1967cranfield]. It is calculated as\n$$\\text{Precision} = \\frac{\\text{True Positives}}{\\text{True Positives + False Positives}}$$\n\nSimilarly, *recall*, also known as sensitivity or true positive rate, is essential in binary classification to assess the model's ability to identify all relevant instances [@sparck1972statistical]. The formula for recall is\n$$\\text{Recall} = \\frac{\\text{True Positives}}{\\text{True Positives + False Negatives}}$$\n\nThese statistical measures collectively provide a comprehensive evaluation of the model's performance, taking into account both overall accuracy and class-specific performance metrics.\n\n\n\n\n## Implementation\nIn the implementation of our project aimed at utilizing LiDAR data for distinguishing tree species in monocultural forests, we chose R as our programming language. This decision was driven by the robust and well-maintained package infrastructure offered by R, providing a solid foundation for our work. Additionally, R's inherent capability to handle large data structures efficiently proved advantageous for our project, where processing LiDAR point clouds required a scalable and effective solution.\n\nOur implementation relied on four key R packages, each serving a crucial role in the project's success:\n\n- **lidR:** This package played a fundamental role in handling and processing LiDAR point clouds. Its capabilities were essential for the core management of LiDAR data throughout our analysis [@lidR].\n\n- **sf:** Used for managing spatial vector data and conducting spatial operations, the sf package enriched our analysis with essential spatial components, enhancing the geographical dimension of our research [@sf].\n\n- **dplyr:** As a package specialized in data manipulation, dplyr provided indispensable tools for shaping and organizing our data to meet the specific requirements of our analysis [@dplyr].\n\n- **ggplot2:** Renowned for its proficiency in creating high-quality visualizations, ggplot2 was employed to present our results in a manner that is not only informative but also reproducible [@ggplot2].\n\nTo streamline the implementation process and make our work accessible to others, we encapsulated these functionalities into a comprehensive R package. This package handles various aspects of the project seamlessly:\n\n- **Automated Data Management:** The R package takes care of organizing and saving data in a predefined directory structure, ensuring a systematic and orderly approach.\n\n- **Meta Information Generation:** It automatically generates meta-information based on the structure of the data, providing vital context and documentation for our analyses.\n\n- **Analytic Function Application:** Analytic functions are applied automatically to specified data subsets, streamlining the analytical process and enhancing the reproducibility of our results.\n\nFor those interested in exploring or contributing to our work, the GitHub repository containing the implementations can be accessed [here](https://github.com/jakobdanel/lidar-forest-analysis). This centralized repository serves as a collaborative hub, inviting further development and utilization of our LiDAR forest analysis package [@lfa]. For further investigation you can find the package Documentation here: @sec-documentation\n\n\n\n# Results\n\nFirst we present the researched areas, after that we look into distribution characterics. Lastly we present a set of generated random forest models and their accuracy.\n\n\n\n::: {.cell}\n\n:::\n\n\n## Researched areas\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nlibrary(ggplot2)\nsf::sf_use_s2(FALSE)\npatches <- sf::read_sf(\"research_areas.shp\") |> sf::st_centroid()\n\nde <- sf::read_sf(\"results/results/states_de/Bundesländer_2017_mit_Einwohnerzahl.shp\") # Source: https://hub.arcgis.com/datasets/esri-de-content::bundesl%C3%A4nder-2017-mit-einwohnerzahl/explore?location=51.099647%2C10.454033%2C7.43\nnrw <- de[5,] |> sf::st_geometry()\n\n\nggplot() + geom_sf(data = nrw) + \n    geom_sf(data = patches, mapping = aes(col = species))\n```\n\n::: {.cell-output-display}\n![Locations of the different patches with the dominant species for that patch. The patches centroids are displayed on a basemap describing the borders from NRW.](report_files/figure-html/fig-patches-nrw-1.png){#fig-patches-nrw width=672}\n:::\n:::\n\nWe draw three patches for each species from different regions (see @tbl-summary-researched-areas). We download the LiDAR data for those patches and runned all preprocessing steps as described. We than checked with certain derived parameters (e.g. tree heights, tree distributions or tree density) that all patches contain valid forest data. In that step we discovered, that in one patch some forest clearance took place in the near past. This patch was removed from the dataset and was replaced with a new one.    \n\nIn our research, drawing patches evenly distributed across Nordrhein-Westfalia is inherently constrained by natural factors. Consequently, the patches for oak and pine predominantly originate from the Münsterland region, as illustrated in [@fig-patches-nrw]. For spruce, the patches were derived from Sauerland, reflecting the prevalence of spruce forests in this specific region within NRW, as corroborated by Welle et al. [@welle2014] and Blickensdörfer et al. [@Blickensdoerfer2022]. Beech patches, on the other hand, were generated from diverse locations within NRW. Across all patches, no human-made objects were identified, with the exception of small paths for pedestrians and forestry vehicles.\n\nThe distribution of area and detections is notable for each four species. Beech covers 69,791.9 hectares with a total of 5,954 detections, oak spans 63,232.49 hectares with 5,354 detections, pine extends across 72,862.4 hectares with 8,912 detections, and spruce encompasses 57,940.02 hectares with 8,619 detections. Both the amount of detections and the corresponding area exhibit a relatively uniform distribution across the diverse patches, as summarized in @tbl-summary-researched-areas. \n\nWith the selected dataset described, we intentionally chose three patches for each four species that exhibit a practical and usable size for our research objectives. These carefully chosen patches align with the conditions essential for our study, providing comprehensive and representative data for in-depth analysis and meaningful insights into the characteristics of each tree species within the specified areas.\n\n\n\n::: {#tbl-summary-researched-areas .cell tbl-cap='Summary of researched patches grouped by species, with their location, area and the amount of detected trees.'}\n\n```{.r .cell-code  code-fold=\"true\"}\nshp <- sf::read_sf(\"research_areas.shp\")\ntable <- lfa::lfa_get_all_areas()\n\nsf::sf_use_s2(FALSE)\nfor (row in 1:nrow(table)) {\n  area <-\n    dplyr::filter(shp, shp$species == table[row, \"specie\"] &\n                    shp$name == table[row, \"area\"])\n  area_size <- area |> sf::st_area()\n  point <- area |> sf::st_centroid() |> sf::st_coordinates()\n  table[row,\"point\"] <- paste0(\"(\",round(point[1], digits = 4),\", \",round(point[2],digits = 4),\")\")\n  \n  table[row, \"area_size\"] = round(area_size,digits = 2) #paste0(round(area_size,digits = 2), \" m²\")\n  \n  amount_det <- nrow(lfa::lfa_get_detection_area(table[row, \"specie\"], table[row, \"area\"]))\n  if(is.null(amount_det)){\n    cat(nrow(lfa::lfa_get_detection_area(table[row, \"specie\"], table[row, \"area\"])),table[row, \"specie\"],table[row, \"area\"])\n  }\n  table[row, \"amount_detections\"] = amount_det\n  \n  # table[row, \"specie\"] <- lfa::lfa_capitalize_first_char(table[row,\"specie\"])\n  table[row, \"area\"] <- lfa::lfa_capitalize_first_char(table[row,\"area\"])\n  }\ntable$area <- gsub(\"_\", \" \", table$area)\ntable$area <- gsub(\"ue\", \"ü\", table$area)\ntable = table[,!names(table) %in% c(\"specie\")]\n\nknitr::kable(table, \"html\", col.names = c(\"Patch Name\",\"Location\",\"Area size (m²)\",\"Amount tree detections\" ), caption = NULL, digits = 2, escape = TRUE) |>\n  kableExtra::kable_styling(\n    bootstrap_options = c(\"striped\", \"hold_position\", \"bordered\",\"responsive\"),\n    stripe_index = c(1:3,7:9),\n    full_width = FALSE\n  ) |>\n  kableExtra::pack_rows(\"Beech\", 1, 3) |>\n  kableExtra::pack_rows(\"Oak\", 4, 6) |>\n  kableExtra::pack_rows(\"Pine\", 7, 9) |>\n  kableExtra::pack_rows(\"Spruce\", 10, 12) |>\n  kableExtra::column_spec(1, bold = TRUE)\n```\n\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table table-striped table-bordered table-responsive\" style=\"width: auto !important; margin-left: auto; margin-right: auto;\">\n <thead>\n  <tr>\n   <th style=\"text-align:left;\"> Patch Name </th>\n   <th style=\"text-align:left;\"> Location </th>\n   <th style=\"text-align:right;\"> Area size (m²) </th>\n   <th style=\"text-align:right;\"> Amount tree detections </th>\n  </tr>\n </thead>\n<tbody>\n  <tr grouplength=\"3\"><td colspan=\"4\" style=\"border-bottom: 1px solid;\"><strong>Beech</strong></td></tr>\n<tr>\n   <td style=\"text-align:left;padding-left: 2em;font-weight: bold;\" indentlevel=\"1\"> Bielefeld brackwede </td>\n   <td style=\"text-align:left;\"> (8.5244, 51.9902) </td>\n   <td style=\"text-align:right;\"> 161410.57 </td>\n   <td style=\"text-align:right;\"> 1443 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;padding-left: 2em;font-weight: bold;\" indentlevel=\"1\"> Billerbeck </td>\n   <td style=\"text-align:left;\"> (7.3273, 51.9987) </td>\n   <td style=\"text-align:right;\"> 185887.25 </td>\n   <td style=\"text-align:right;\"> 1732 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;padding-left: 2em;font-weight: bold;\" indentlevel=\"1\"> Wülfenrath </td>\n   <td style=\"text-align:left;\"> (7.0769, 51.2917) </td>\n   <td style=\"text-align:right;\"> 350621.21 </td>\n   <td style=\"text-align:right;\"> 2779 </td>\n  </tr>\n  <tr grouplength=\"3\"><td colspan=\"4\" style=\"border-bottom: 1px solid;\"><strong>Oak</strong></td></tr>\n<tr>\n   <td style=\"text-align:left;padding-left: 2em;font-weight: bold;\" indentlevel=\"1\"> Hamm </td>\n   <td style=\"text-align:left;\"> (7.8618, 51.6639) </td>\n   <td style=\"text-align:right;\"> 269397.22 </td>\n   <td style=\"text-align:right;\"> 2441 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;padding-left: 2em;font-weight: bold;\" indentlevel=\"1\"> Münster </td>\n   <td style=\"text-align:left;\"> (7.6187, 51.9174) </td>\n   <td style=\"text-align:right;\"> 164116.61 </td>\n   <td style=\"text-align:right;\"> 1270 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;padding-left: 2em;font-weight: bold;\" indentlevel=\"1\"> Rinkerode </td>\n   <td style=\"text-align:left;\"> (7.6744, 51.8598) </td>\n   <td style=\"text-align:right;\"> 198811.09 </td>\n   <td style=\"text-align:right;\"> 1643 </td>\n  </tr>\n  <tr grouplength=\"3\"><td colspan=\"4\" style=\"border-bottom: 1px solid;\"><strong>Pine</strong></td></tr>\n<tr>\n   <td style=\"text-align:left;padding-left: 2em;font-weight: bold;\" indentlevel=\"1\"> Greffen </td>\n   <td style=\"text-align:left;\"> (8.1697, 51.9913) </td>\n   <td style=\"text-align:right;\"> 49418.81 </td>\n   <td style=\"text-align:right;\"> 513 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;padding-left: 2em;font-weight: bold;\" indentlevel=\"1\"> Mesum </td>\n   <td style=\"text-align:left;\"> (7.5403, 52.2573) </td>\n   <td style=\"text-align:right;\"> 405072.85 </td>\n   <td style=\"text-align:right;\"> 5031 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;padding-left: 2em;font-weight: bold;\" indentlevel=\"1\"> Telgte </td>\n   <td style=\"text-align:left;\"> (7.7816, 52.0024) </td>\n   <td style=\"text-align:right;\"> 274132.34 </td>\n   <td style=\"text-align:right;\"> 3368 </td>\n  </tr>\n  <tr grouplength=\"3\"><td colspan=\"4\" style=\"border-bottom: 1px solid;\"><strong>Spruce</strong></td></tr>\n<tr>\n   <td style=\"text-align:left;padding-left: 2em;font-weight: bold;\" indentlevel=\"1\"> Brilon </td>\n   <td style=\"text-align:left;\"> (8.5352, 51.4084) </td>\n   <td style=\"text-align:right;\"> 211478.20 </td>\n   <td style=\"text-align:right;\"> 3342 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;padding-left: 2em;font-weight: bold;\" indentlevel=\"1\"> Oberhundem </td>\n   <td style=\"text-align:left;\"> (8.1861, 51.0909) </td>\n   <td style=\"text-align:right;\"> 151895.53 </td>\n   <td style=\"text-align:right;\"> 2471 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;padding-left: 2em;font-weight: bold;\" indentlevel=\"1\"> Osterwald </td>\n   <td style=\"text-align:left;\"> (8.3721, 51.2151) </td>\n   <td style=\"text-align:right;\"> 216026.43 </td>\n   <td style=\"text-align:right;\"> 2806 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n\n\n\n\n\n## Distribution of tree characteristics\n\nThe following subsections describe the distributions of different tree characterestics across the different species and patches.\n\n### Tree Heights\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\ndetections <- lfa::lfa_get_detections()\n```\n:::\n\n\nIn this study, we scrutinize the distribution of tree heights, focusing initially on the density distribution to unravel the nuances across various tree species. Notably, our examination reveals distinctive patterns, with Oak and Pine exhibiting significantly steeper peaks in their density curves compared to Beech and Spruce. While all species present unique density curves, a commonality emerges—each curve is characterized by a single peak, except for the intriguing exception observed in Telgte. Taking Beech as an illustrative example, our findings indicate a notable shift in the peak to a considerably higher extent. The varinace in the density curves indicating that an differencation between species only with the help oof tree height values could be difficult.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nlfa::lfa_create_density_plots(detections, value_column = \"Z\", category_column1 = \"area\", category_column2 = \"specie\", title = \"Density of the height distributions\", xlims = c(0,50))\n```\n\n::: {.cell-output-display}\n![Density of the height distribitions of the detectected trees. Splitted by the different researched areas and grouped by the dominant specie in this area.](report_files/figure-html/fig-density-z-1.png){#fig-density-z width=672}\n:::\n:::\n\n\nTo have a deeper look into the distributions of those `Z`-values we will now also have a look into the boxplots of the height distrubutions in the different areas.\nNoteworthy observations include the presence of outliers beyond the extended range of the Whisker Antennas ($1.5*\\text{IQR}$) in all datasets. Of particular interest is the Rinkerode dataset, which exhibits a higher prevalence of outliers in the upper domain. Anomalies in this dataset are attributed to potential inaccuracies, urging a critical examination of data integrity. A pairwise examination of Oak and Pine species indicates higher mean heights for Oak compared to Pine. This insight underscores the significance of species-specific attributes in shaping overall height distributions. Further exploration into the factors contributing to these mean differences enhances our understanding of the unique characteristics inherent to each species. Contrary to expectations, the spread within a particular species does not exhibit significant divergence from the spread observed between different species. This finding suggests that while species-specific traits play a crucial role in shaping height distributions, certain overarching factors may contribute to shared patterns across diverse tree populations.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nlfa::lfa_create_boxplot(detections, value_column = \"Z\", category_column1 = \"area\", category_column2 = \"specie\", title = \"Boxplots of the height distributions\")\n```\n\n::: {.cell-output-display}\n![Boxplots of the height distribitions of the detectected trees. Splitted by the different researched areas and grouped by the dominant specie in this area.](report_files/figure-html/fig-boxplot-z-1.png){#fig-boxplot-z width=672}\n:::\n:::\n\n\n\n\nOur examination of Kullback-Leibler Divergence (KLD) and Jensen-Shannon Divergence (JSD) metrics reveals low mean values (KLD: 5.252696, JSD: 2.246663) across different species, indicating overall similarity in tree species height distributions. However, within specific species, particularly Pine, higher divergence values (see @tbl-z-values-kld-pine and @tbl-z-values-jsd-pine) suggest significant intraspecific differences.\n\nNotably, the Spruce species consistently demonstrates low divergence values across all tested areas, implying a high level of explainability. This finding highlights tree height as a reliable indicator for detecting Spruce trees, indicating its potential for accurate species identification in diverse forest ecosystems.\n\n### Number of returns\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\ndata <- sf::st_read(\"data/tree_properties.gpkg\")\nneighbors <- lfa::lfa_get_neighbor_paths() |> lfa::lfa_combine_sf_obj(lfa::lfa_get_all_areas())\ndata = sf::st_join(data,neighbors, join = sf::st_within)\n```\n:::\n\nExamining the distribution of LiDAR returns per tree is the focus of our current investigation. Initial analysis involves the study of density graphs representing the distribution of LiDAR returns. The density curves for each species exhibit distinct peaks corresponding to their respective species, providing a clear differentiation in LiDAR return patterns. Notably, there is an exception observed in the Brilon patch (Spruce), where the curve deviates, possibly indicative of variations in forest age. A noteworthy trend is the divergent shape of density curves between coniferous and deciduous trees. Conifers exhibit steeper curves, indicating lower density for higher return values compared to deciduous trees. This disparity underscores the potential of LiDAR data to distinguish between tree types based on return density characteristics. In the case of Beech trees, the peaks' heights vary among different curves, suggesting nuanced variations within the species. Despite these differences, all species consistently peak in similar regions, emphasizing the overarching similarities in LiDAR return patterns across diverse tree species.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nlfa::lfa_create_density_plots(data, value_column = \"number_of_returns\", category_column1 = \"area\", category_column2 = \"specie\", title = \"Density of the distribution of LiDAR returns per individual tree\", xlims = c(0,10000))\n```\n\n::: {.cell-output-display}\n![Density of the amount of LiDAR returns per detectected tree. Splitted by the different researched areas and grouped by the dominant specie in this area.](report_files/figure-html/fig-density-number-returns-1.png){#fig-density-number-returns width=672}\n:::\n:::\n\n\nCurrently, our investigation focuses on boxplots representing each patch. We observe significant size variations among plots within the same species. Notably, numerous outliers are present above the box in each patch. For Pines, the boxes exhibit a notable similarity. However, the box for Brilon is entirely shifted from other boxes associated with patches featuring Spruce forest.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nlfa::lfa_create_boxplot(data, value_column = \"number_of_returns\", category_column1 = \"area\", category_column2 = \"specie\", title = \"Boxplots of the distribution of LiDAR returns per individual tree\")\n```\n\n::: {.cell-output-display}\n![Boxplots of the the amount of LiDAR returns per detectected tree. Splitted by the different researched areas and grouped by the dominant specie in this area.](report_files/figure-html/fig-boxplot-number-returns-1.png){#fig-boxplot-number-returns width=672}\n:::\n:::\n\n\nOverall, our analysis reveals very low results for both Kullback-Leibler Divergence (KLD) and Jensen-Shannon Divergence (JSD) metrics across different species. Within species, there is high explainability observed for the different LiDAR return curves between patches.\n\nThis suggests that the number of returns alone may not be a robust predictor for identifying the dominant species in a forest. However, the curves indicate a clear potential for distinguishing between conifers (Pine and Spruce) and deciduous trees (Beech and Oak) based on the number of returns. This observation is further supported by the JSD scores, as detailed in @tbl-number-of-returns-jsd_specie.\n\n### n-nearest Neighbours\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nneighbors <- lfa::lfa_combine_sf_obj(lfa::lfa_get_neighbor_paths(),lfa::lfa_get_all_areas())\n```\n:::\n\n\n#### Overview\nTo initiate our analysis, we first establish a framework for selecting neighbors by examining the distance development with different n, as illustrated in @fig-n-nearest-overview. The curves share a similar design, but the actual values vary. Notably, as n increases, the distance between all patches also increases, indicating a broader spatial context.\n\nConsidering this trend, we extend our investigation beyond the nearest neighbor to include the 100th nearest neighbor. The $\\Delta$distance shows a consistent decrease with each increment in n, reinforcing our decision to limit exploration beyond n of a hundred. Additionally, the constraint is driven by practical considerations, as our sample size occasionally lacks the capacity to explore larger n values, resulting in inaccurate values due to the absence of the true nearest neighbor within the sample area.\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nlfa::lfa_create_neighbor_mean_curves(neighbors) |> lfa::lfa_create_plot_per_area()\n```\n\n::: {.cell-output-display}\n![Average Distance to n-nearest neighbor from each patch. For simplicity colored by the dominant specie of each tree.](report_files/figure-html/fig-n-nearest-overview-1.png){#fig-n-nearest-overview width=672}\n:::\n:::\n\n\n\n#### The Nearest Neighbour\nOur initial focus centers on examining the distance to the nearest neighbor for each tree. Notably, the curve representing Spruce exhibits distinct characteristics compared to the three other curves—displaying a steeper profile with less variance, as depicted in @fig-density-1-nearest.\n\nFurther analysis of all patches reveals similar distributions, as evident in the boxplot shown in Figure 2 (@fig-boxplot-1-nearest), where mean and variance demonstrate consistency across patches. However, these graphical statistics present challenges in effectively distinguishing between different tree species based on the distance to the nearest neighbor.\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nlfa::lfa_create_density_plots(neighbors,value_column = \"Neighbor_1\",category_column1 = \"area\",category_column2 = \"specie\", title = \"Density plots for the nearest neighbor among species and areas\", xlims = c(0,15))\n```\n\n::: {.cell-output-display}\n![Density plot of the distance to the nearest neighbor distribution across all patches grouped by the dominant species.](report_files/figure-html/fig-density-1-nearest-1.png){#fig-density-1-nearest width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nlfa::lfa_create_boxplot(neighbors,value_column = \"Neighbor_1\",category_column1 = \"area\",category_column2 = \"specie\", title = \"Box plots for the nearest neighbor among species and areas\")\n```\n\n::: {.cell-output-display}\n![Density plot of the distance to the nearest neighbor distribution across all patches grouped by the dominant species.](report_files/figure-html/fig-boxplot-1-nearest-1.png){#fig-boxplot-1-nearest width=672}\n:::\n:::\n\n\n\n#### The 100th nearest Neighbor\nMoving on to the analysis of the 100th nearest neighbor, intriguing patterns emerge. Peaks in the curves display varying heights and positions, with a notable example being the complete shift between Oak and Spruce, as illustrated in @fig-density-100-nearest.\n\nHowever, it is essential to acknowledge the high variance observed between curves within a species, such as Pine or Beech. While this variance could serve as a potential indicator, it comes with the caveat that the sample size must be substantial for reliable conclusions.\n\nExamining boxplots reveals numerous outliers above the boxes, hinting at potential edge effects on the sides of patches. This observation raises concerns about the adequacy of trees in these areas for a more in-depth analysis, posing challenges in deriving accurate insights.\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nlfa::lfa_create_density_plots(neighbors,value_column = \"Neighbor_100\",category_column1 = \"area\",category_column2 = \"specie\", title = \"Density plots for the nearest neighbor along species and areas\", xlims = c(35,100))\n```\n\n::: {.cell-output-display}\n![Density plot of the distance to the nearest neighbor distribution across all patches grouped by the dominant species.](report_files/figure-html/fig-density-100-nearest-1.png){#fig-density-100-nearest width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nlfa::lfa_create_boxplot(neighbors,value_column = \"Neighbor_100\",category_column1 = \"area\",category_column2 = \"specie\", title = \"Box plots for the nearest neighbor along species and areas\")\n```\n\n::: {.cell-output-display}\n![Density plot of the distance to the nearest neighbor distribution across all patches grouped by the dominant species.](report_files/figure-html/fig-boxplot-100-nearest-1.png){#fig-boxplot-100-nearest width=672}\n:::\n:::\n\n\n#### Average distance to 100 nearest neighbors\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nnames <- paste0(\"Neighbor_\",1:100)\nneighbors$avg = rowMeans(dplyr::select(as.data.frame(neighbors),names))\n```\n:::\n\n\nTurning our attention to the averages of the first 100 neighbors, our analysis indicates strikingly similar results. There is considerable variance observed between different species, as well as within individual species, as depicted in @fig-density-avg-nearest.\n\nDespite the uniformity in average results, the issue of outliers persists, as evident in the boxplot representation shown in @fig-boxplot-avg-nearest. These outliers pose challenges and may be indicative of specific environmental conditions affecting tree distributions. Further exploration is required to better understand and mitigate the impact of outliers on our analysis.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nlfa::lfa_create_density_plots(neighbors,value_column = \"avg\",category_column1 = \"area\",category_column2 = \"specie\", title = \"Density plots for the average of 100 nearest neighbors\", xlims = c(25,60))\n```\n\n::: {.cell-output-display}\n![Density plot of the average distance to the nearest neighbor (n=100) distribution across all patches grouped by the dominant species.](report_files/figure-html/fig-density-avg-nearest-1.png){#fig-density-avg-nearest width=672}\n:::\n:::\n\n\n\n\nThe neighbor analysis proves potentially useful for distinguishing between tree species, yet the observed variances within each species suggest that relying solely on distance to neighbors may not suffice.\n\nA critical consideration is the sample size problem, wherein more distinguishable patterns emerge with higher neighbor levels, but this necessitates a sufficiently large sample size. Unfortunately, deriving a clear relationship between sample size and the number of tree neighbors remains elusive in our current findings. This gap in understanding could be a pertinent subject for further research, delving into the intricate interplay between sample size and the effectiveness of neighbor analysis in species differentiation.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nlfa::lfa_create_boxplot(neighbors,value_column = \"avg\",category_column1 = \"area\",category_column2 = \"specie\", title = \"Box plots for the average to the nearest neighbor across all species and areas\")\n```\n\n::: {.cell-output-display}\n![Density plot of the average distance to the nearest neighbor (n = 100) distribution across all patches grouped by the dominant species.](report_files/figure-html/fig-boxplot-avg-nearest-1.png){#fig-boxplot-avg-nearest width=672}\n:::\n:::\n\n\n### Density of forest patches\nExamining densities provides valuable insights into identifying the dominant species within patches. Spruce stands out as the densest species, surpassing all other patches. Following closely in density is Pine, as depicted in [@fig-density-bar].\n\nBeech and Oak exhibit similar density levels, with Beech consistently denser across all patches. When comparing the highest density patches for each species, Beech consistently outpaces Oak. While Oak is slightly less dense overall ($8.354499 \\times 10^{-3} \\frac{1}{m^2}$) than Beech ($8.727781 \\times 10^{-3} \\frac{1}{m^2}$), the distinction in density remains noticeable.\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nlibrary(units)\nlfa::lfa_calculate_patch_density() |>\n  lfa::lfa_create_grouped_bar_plot(grouping_var = \"species\", value_col = \"density\", label_col = \"name\")\n```\n\n::: {.cell-output-display}\n![Barplot of the densitys of all patches (#detected trees/area of patch). Colorized by the dominant tree species of each patch.](report_files/figure-html/fig-density-bar-1.png){#fig-density-bar width=672}\n:::\n:::\n\nIn summary, our findings indicate that the density of each patch proves highly effective in distinguishing dominant species. Furthermore, the differentiation between conifers (Pine and Spruce) and deciduous trees (Beech and Oak) based on density aligns with patterns observed in the number of return points per detected tree. While distinguishing within conifers is straightforward, discerning between the deciduous tree species Beech and Oak, is possible but poses a moderate challenge.\n\n### Canopy Height Model\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nchms <- lfa::lfa_visit_all_areas(lfa::lfa_chm)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\npatches <- lfa::lfa_get_all_areas()\npatches$chm_mean = NA\npatches$chm_var = NA\npatches$chm_median = NA\nfor (area_key in names(chms)) {\n  area <- chms[area_key]\n  area[[area_key]] |> as.vector() -> vec\n  patches[patches$area == area_key, \"chm_mean\"] <-\n    mean(vec, na.rm = T)\n  patches[patches$area == area_key, \"chm_var\"] <-\n    var(vec, na.rm = T)\n  patches[patches$area == area_key, \"chm_median\"] <-\n    median(vec, na.rm = T)\n  \n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nlfa::lfa_create_grouped_bar_plot(patches,\"specie\",\"chm_mean\",\"area\",ylab = \"Mean\", title = \"Mean Canopy Height\")\n```\n\n::: {.cell-output-display}\n![Mean Canopy Height across all patches colored by the dominant specie of each patch.](report_files/figure-html/fig-chm-mean-1.png){#fig-chm-mean width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nlfa::lfa_create_grouped_bar_plot(patches,\"specie\",\"chm_var\",\"area\",ylab = \"Variance\", title = \"Variance of Canopy Height\")\n```\n\n::: {.cell-output-display}\n![Variance Canopy Height across all patches colored by the dominant specie of each patch.](report_files/figure-html/fig-chm-var-1.png){#fig-chm-var width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nlfa::lfa_create_grouped_bar_plot(patches,\"specie\",\"chm_median\",\"area\",ylab = \"Median\", title = \"Median Canopy Height\")\n```\n\n::: {.cell-output-display}\n![Median Canopy Height across all patches colored by the dominant specie of each patch.](report_files/figure-html/fig-chm-median-1.png){#fig-chm-median width=672}\n:::\n:::\n\n\n## Random Forest Predictions\nThis section  outlines the presentation of Random Forest results, encompassing three models, each trained on different parameters. Each chapter provides an explanation for the selection of a particular model, offering insights into the reasoning behind our choices.\n\n\n### Use neighbors and height\nA Random Forest model was trained on tree heights (z-values) and the distance to the nearest 100 neighbors. Despite achieving only medium results, this straightforward model clearly demonstrates the feasibility of distinguishing between tree species.\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\ndetections <- lfa::lfa_get_detections()\nneighbors <- lfa::lfa_get_neighbor_paths() |> lfa::lfa_combine_sf_obj(lfa::lfa_get_all_areas())\nneighbors <- sf::st_join(neighbors,detections, join = sf::st_within)\nnames(neighbors)[names(neighbors) == 'specie.x'] <- 'specie'\nnames(neighbors)[names(neighbors) == 'area.x'] <- 'area'\nexcluded_cols <- c(\"area.x\",\"specie.x\",\"treeID.y\",\"Z.y\",\"area.y\",\"specie.y\",\"geom\",\"treeID.x\",\"Z.x\")\n```\n:::\n\n::: {.cell hash='report_cache/html/unnamed-chunk-27_a12ecf5a16a71e89cca40523771cd7b5'}\n\n```{.r .cell-code  code-fold=\"true\"}\ndata <- lfa::lfa_random_forest(tree_data = neighbors, excluded_input_columns = excluded_cols,response_variable = \"specie\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nmodel.rf_neighbors <- data\nsave(model.rf_neighbors, file = \"./models/neighbors.rData\")\n```\n:::\n\n\n\nThe classifier exhibits notable performance variations across different classes. Precision for the \"Beech\" class is high, indicating accurate positive predictions, but the lower recall suggests the possibility of missing some instances of \"Beech.\" In contrast, both precision and recall for the \"Oak\" and \"Pine\" classes are extremely low, highlighting challenges in accurately classifying instances. The \"Spruce\" class shows moderate precision and high recall, indicating comparatively better performance.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\ncm <- data$confusion_matrix\nlfa::lfa_plot_confusion_matrix(cm)\n```\n\n::: {.cell-output-display}\n![Confusion Matrix of randomForest on the distance to 100 nearest neighbors.](report_files/figure-html/fig-cm-neighbors-1.png){#fig-cm-neighbors width=672}\n:::\n:::\n\n\n\nThe model's predictions for \"Beech\" are frequent but vary significantly, leading to substantial differences between Precision and Recall (see [@fig-pr-neighbors]). The model tends to make predictions that are either mostly correct or mostly incorrect, resulting in a homogenous prediction pattern, as illustrated in the confusion matrix (see [@fig-cm-neighbors]).\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\ndata$confusion_matrix |> lfa::lfa_calculate_rf_metrics() |> lfa::lfa_visualize_rf_metrics()\n```\n\n::: {.cell-output-display}\n![Class wise precision and recall for randomForest-Classification with distance to the 100 nearest neighbors.](report_files/figure-html/fig-pr-neighbors-1.png){#fig-pr-neighbors width=672}\n:::\n:::\n\n\n\n\n### Enrich Neighbors with segmentation data\n\nThis model employs the same parameters as the preceding one, while incorporating additional features derived from the segmentation of each tree in the point cloud. The expanded feature set includes density of returns per tree, mean and variance of Z values of return points, mean and variance of intensity of LiDAR returns, number of LiDAR returns per tree, and the area in square meters of each tree. The aim is to compare the results obtained with this augmented feature set against those based solely on tree detection characteristics.\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\ndata <- sf::st_read(\"./data/tree_properties.gpkg\")\ndetections <- lfa::lfa_get_detections()\nneighbors <- lfa::lfa_get_neighbor_paths() |> lfa::lfa_combine_sf_obj(lfa::lfa_get_all_areas())\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\ncombined <- sf::st_join(data,detections,join = sf::st_within)\n\ncombined$Z.x = NULL\nnames(combined)[names(combined) == 'Z.y'] <- 'Z'\n\ncombined$treeID.segmentation <- NULL\n\ncombined[[\"density\"]][is.na(combined[[\"density\"]])] <- -1\ncombined[[\"Z.mean\"]][is.na(combined[[\"Z.mean\"]])] <- -1\ncombined[[\"Z.var\"]][is.na(combined[[\"Z.var\"]])] <- -1\ncombined[[\"Intensity.mean\"]][is.na(combined[[\"Intensity.mean\"]])] <- -1\ncombined[[\"Intensity.var\"]][is.na(combined[[\"Intensity.var\"]])] <- -1\ncombined[[\"number_of_returns\"]][is.na(combined[[\"number_of_returns\"]])] <- -1\ncombined[[\"tree_area\"]][is.na(combined[[\"tree_area\"]])] <- -1\n\nneighbors$treeID = NULL\nneighbors$Z = NULL\nneighbors$area = NULL\nneighbors$specie = NULL\n\ncombined = sf::st_join(combined, neighbors, sf::st_within)\nexcluded_cols <- c(\"Z.x\", \"treeID.detection\",\"treeID.segmentation\",\"name_las_file\",\"treeID\",\"area\",\"specie\",\"geom\")\n```\n:::\n\n::: {.cell hash='report_cache/html/unnamed-chunk-34_3d9b048158d7d5ab3b43b2b9add6a717'}\n\n```{.r .cell-code  code-fold=\"true\"}\ndata <- lfa::lfa_random_forest(tree_data = combined, excluded_input_columns = excluded_cols,response_variable = \"specie\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nmodel.rf_segmentation_detection_params <- data\nsave(model.rf_segmentation_detection_params, file = \"./models/segmentation_detection_params.rData\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\ncm <- data$confusion_matrix\nlfa::lfa_plot_confusion_matrix(cm)\n```\n\n::: {.cell-output-display}\n![Confusion Matrix of randomForest with all parameters derived from tree level.](report_files/figure-html/fig-cm-tree-level-1.png){#fig-cm-tree-level width=672}\n:::\n:::\n\n\nThe classifier exhibits suboptimal performance for the \"Beech\" and \"Oak\" classes, with low precision and recall values, indicative of challenges in accurately classifying instances for these categories. In contrast, the \"Pine\" class demonstrates higher precision and recall, suggesting improved performance in capturing true instances while minimizing false positives. The \"Spruce\" class displays moderate precision and high recall, indicating relatively better performance in capturing true instances with fewer false positives.\n\nNotably, the overall accuracy (0.44) and Kappa (0.23) have significantly improved compared to the previous model (Accuracy = 0.35, Kappa = 0.14). The model demonstrates effectiveness for conifers but shows limitations for deciduous trees, as depicted in the confusion matrix at the tree-level (@fig-cm-tree-level). Specifically, \"Oak\" and \"Beech\" ground truth predictions are distributed among all classes, while \"Pine\" exhibits false negatives, especially for the \"Spruce\" class.\n\nAdditionally, this model achieves a more balanced distribution between Precision and Recall differences across classes, as illustrated in the Precision-Recall curve at the tree-level (@fig-pr-tree-level).\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\ndata$confusion_matrix |> lfa::lfa_calculate_rf_metrics() |> lfa::lfa_visualize_rf_metrics()\n```\n\n::: {.cell-output-display}\n![Precsion and Recall of randomForest with all parameters derived from tree level.](report_files/figure-html/fig-pr-tree-level-1.png){#fig-pr-tree-level width=672}\n:::\n:::\n\n\n\n\n### Train with patch level information\n\nIn this phase of our study, we examined the impact of patch-level information on the model. The model training incorporated Z-Values, distance to the 100 nearest neighbors, density of trees within a patch, as well as statistics related to the canopy height, including mean, variance, and median.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nchms <- lfa::lfa_visit_all_areas(lfa::lfa_chm)\npatches <- lfa::lfa_get_all_areas()\npatches$chm_mean = NA\npatches$chm_var = NA\npatches$chm_median = NA\nfor (area_key in names(chms)) {\n  area <- chms[area_key]\n  area[[area_key]] |> as.vector() -> vec\n  patches[patches$area == area_key, \"chm_mean\"] <-\n    mean(vec, na.rm = T)\n  patches[patches$area == area_key, \"chm_var\"] <-\n    var(vec, na.rm = T)\n  patches[patches$area == area_key, \"chm_median\"] <-\n    median(vec, na.rm = T)\n  \n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nneighbors <- lfa::lfa_get_neighbor_paths() |> lfa::lfa_combine_sf_obj(lfa::lfa_get_all_areas())\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\ndetections <- lfa::lfa_get_detections()\ndensity <- lfa::lfa_calculate_patch_density(detections = detections)\ncolnames(density) <- c(\"id\",\"specie\",\"area\",\"geometry\",\"area_size\",\"detections\",\"density\")\ndetections <- dplyr::left_join(detections,density |> as.data.frame(),by=c(\"area\",\"specie\"))\ndetections <- dplyr::left_join(detections,patches, by = c(\"area\",\"specie\"))\n\ndetections <- sf::st_join(detections, neighbors, join = sf::st_within)\n\ndetections$treeID.x = NULL\nnames(detections)[names(detections) == 'treeID.y'] <- 'treeID'\n\ndetections$Z.x = NULL\nnames(detections)[names(detections) == 'Z.y'] <- 'Z'\n\ndetections$area.x = NULL\nnames(detections)[names(detections) == 'area.y'] <- 'area'\n\ndetections$specie.x = NULL\nnames(detections)[names(detections) == 'specie.y'] <- 'specie'\n\nexcluded_cols = c(\"treeID\",\"geom\",\"area\",\"specie\",\"id\",\"geometry\",\"area_size\",\"detections\",\"geometry\")\n```\n:::\n\n::: {.cell hash='report_cache/html/unnamed-chunk-41_bf8f690bd341d180b3562c74b9060ef9'}\n\n```{.r .cell-code  code-fold=\"true\"}\ndata <- lfa::lfa_random_forest(tree_data = detections, excluded_input_columns = excluded_cols,response_variable = \"specie\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nmodel.rf_patch <- data\nsave(model.rf_patch, file = \"./models/patch.rData\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\ncm <- data$confusion_matrix\nlfa::lfa_plot_confusion_matrix(cm)\n```\n\n::: {.cell-output-display}\n![Confusion Matrix of randomForest on returns per Tree.](report_files/figure-html/fig-cm-patch-1.png){#fig-cm-patch width=672}\n:::\n:::\n\nThe model yields favorable overall results, with an accuracy of 0.63 and a Kappa value of 0.49. Notably, predictions appear to be predominantly influenced by patch-level information, resulting in largely homogeneous predictions within most patches.\n\nFor the \"Beech\" and \"Oak\" classes, the classifier performs moderately well, exhibiting moderate precision and recall values. These values are within the same domain, with an equal balance between recall and precision for both classes.\n\nIn the case of the \"Pine\" class, high precision is accompanied by lower recall, indicating a conservative prediction approach. However, the classifier successfully captures a substantial portion of actual \"Pine\" instances. Noteworthy is the presence of outliers where \"Pine\" is falsely predicted as \"Oak\" (see @fig-cm-patch). These false predictions are concentrated in the Greffen patch, which contains a total of 513 detections. Notably, all significant Pine patches yield accurate predictions.\n\nThe \"Spruce\" class exhibits a good balance between precision and recall, with slightly better recall values. The deciduous vs. conifers comparison is notably successful, with conifers predicted mostly as true positives and false predictions for deciduous tree species predominantly leaning towards predicting deciduous trees.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\ndata$confusion_matrix |> lfa::lfa_calculate_rf_metrics() |> lfa::lfa_visualize_rf_metrics()\n```\n\n::: {.cell-output-display}\n![Class wise precision and recall for randomForest-Classification with LiDAR returns per tree.](report_files/figure-html/fig-pr-patch-1.png){#fig-pr-patch width=672}\n:::\n:::\n\n\n\n# Discussion\n\n\n## Findings\n\nNow, we will delve into the findings derived from the previously presented results, discussing them in the context of the hypotheses outlined in the Introduction. As we move forward, the discussion will delve into the alignment of our findings with the initial hypotheses, shedding light on the effectiveness of the employed methodology and the insights gained from the analysis.\n\n**LiDAR data can effectively differentiate between tree species in monocultural forests in NRW, and there are statistically significant differences in the LiDAR-derived metrics among the various tree species.**\n\nThe statement provided offers a nuanced perspective on the effectiveness of tree species differentiation based on the analysis conducted. It is acknowledged that the effectiveness of differentiation is intricately tied to the chosen criteria and the specific species under consideration. Notably, certain patch-level statistics, such as tree density, emerge as robust indicators for distinguishing between tree species. However, when scrutinizing the distribution of characteristics at the individual tree level, the variance between the distributions of patches from the same species is often not significantly smaller than the variance between distributions of different species. This observation suggests that relying solely on characteristics at the tree level might not yield distinct species differentiation. An interesting finding is the effectiveness of distinguishing between conifers and deciduous trees, with notable differences, particularly concerning Spruce trees. The identified dissimilarities, especially when comparing Spruce trees to other species, underscore the potential for effective differentiation in certain instances. The conclusion drawn emphasizes the importance of generating a comprehensive set of statistics for a defined area of interest and comparing the results to sample patches. This approach provides a robust indicator of the species distribution within the specified area. Importantly, the recommendation is against solely relying on one selected parameter, given the relatively high variance observed within the same species. Instead, a multifaceted analysis involving various parameters proves more effective in characterizing and distinguishing tree species in a given region.\n\n**Random Forest classification can be used to predict the tree species of trees in monoculteral forests.**\n\nThe presented statement accurately captures the key findings and insights derived from the analysis of the tree models. It is affirmed that all tree models can be partially utilized to distinguish between tree species. However, not all models demonstrated consistently good results across all classes, with oak scoring moderately to low on the tree models. The observation that utilizing patch-level information for training the model enhances performance aligns with the understanding that aggregating information at a higher level of abstraction can provide more robust insights. Furthermore, the notable success in distinguishing between conifers and deciduous trees, especially with the last model, highlights the efficacy of the approach, showcasing high accuracy in this particular differentiation. The conclusion drawn, emphasizing the effectiveness of looking into all tree parameters for distinguishing between inspected tree species using the random forest method, underscores the comprehensive nature of the analysis. It suggests that a holistic consideration of multiple parameters enhances the model's ability to accurately classify and distinguish between different tree species.\n\n**Random Forest classification performance varies significantly depending on the set of LiDAR parameters used, indicating that certain combinations of parameters contribute more effectively to accurate tree species classification.**\n\nThe provided statement accurately characterizes the findings regarding the quality of results obtained from the three models and highlights important nuances in the analysis. Indeed, the quality of results exhibits high variance across all three models, considering overall statistics such as accuracy and Kohen's Kappa, as well as class-specific measures like precision and recall. The mention of presenting only some highlights of the researched parameter combinations emphasizes that the models' performance is influenced by a multitude of factors. The observation that incorporating segmentation parameters into the last model leads to a decrease in performance underscores the sensitivity of the model to specific parameter combinations. The statement further notes the high dependency of model performance on the utilized tree characteristics, with significant variations across different classes. For instance, the predictability of beech is highlighted, showcasing that certain parameters, such as tree heights and distance to neighbors, play a more crucial role in accurate predictions compared to others. The insight that another machine learning approach that can recognize the importance of specific parameters for the prediction of a certain class might be beneficial suggests avenues for further exploration and model refinement. Additionally, the variation in the power of differentiation between conifers and deciduous trees among the three models, with the last model outperforming others, reinforces the significance of the approach that incorporates patch-level information. This observation hints at the importance of considering a holistic view of the forest rather than relying solely on individual tree characteristics for certain tasks. In conclusion, the statement provides a comprehensive overview of the complexities and considerations involved in interpreting and optimizing the machine learning models for tree species prediction based on the dataset and analysis conducted.\n\n## Limitations\n\nOur approach, while yielding valuable insights, is not without its set of assumptions and limitations, each deserving careful consideration to grasp the nuances of our findings.\n\nFirstly, the assumption that all trees within the chosen areas of interest share the same species is integral to our methodology. While this assumption facilitates the development of predictive models, we acknowledge that 100% monocultural forests are rare in reality. Our validation process, primarily relying on Sentinel images, raises potential concerns regarding the inadvertent selection of mixed forests. Such a scenario could significantly impact the distribution of tree characteristics and introduce inaccuracies in the ground truth used for training the random forest algorithm.\n The temporal aspect of LiDAR data collection is a crucial factor that can significantly impact various LiDAR characteristics. LiDAR data may be captured at different seasons of the year, and these seasonal variations can introduce substantial differences in the derived information. For instance, the number of returns and intensities in LiDAR data can be highly influenced by the season during which the data is collected. Seasonal changes in vegetation, such as leaf growth or shedding, can impact the LiDAR returns. Another key assumption revolves around the representation of naturally grown forests in our areas of interest. Given the absence of true natural forests in Germany and North Rhine-Westphalia (NRW) due to forestry practices, our study areas may consist of newly planted or managed forests with differing characteristics. While this could potentially influence our analysis, we consider the impact relatively minor given the prevalent managed nature of forests in the region.\n\nWe assumed the independence of each forest in our study from its spatial environment. However, forests are inherently influenced by various factors such as neighborhood type, altitude, climate, and the presence of fauna. Despite our efforts to draw samples from diverse locations in NRW, these environmental variations persist, introducing a layer of complexity to our analysis.\n The relatively small sample size, with only three areas of interest per species, is another limitation. Increasing the sample size would undoubtedly enhance the robustness of our analysis and mitigate potential drawbacks associated with the limited number of samples. The correctness of our detection process, reliant on the accuracy of the LiDAR point cloud, is a crucial aspect. While the algorithm employed is established and widely used, the precision of our results hinges on the accuracy of the LiDAR detection process. Lastly, we acknowledge technical limitations, notably the tile-based segmentation approach used for processing efficiency. The choice of 50x50m tiles, while suitable for practical hardware constraints, introduces potential challenges near tile borders. Trees located at these borders may be counted as two separate trees during the segmentation process, impacting our results.\n\nIn conclusion, understanding these assumptions and limitations is paramount for a nuanced interpretation of our results. Each aspect informs the intricacies of our methodology and underscores potential areas for refinement in future studies.\n\n\n## Further Work\n\nOur work has laid the foundation for further exploration and refinement in the field of tree species prediction and analysis. As we reflect on our findings, several avenues for future research and optimization strategies emerge.\n\nOne promising direction involves delving into the predictability of other tree species. While our study focused on Beech, Oak, Pine, and Spruce, primarily due to their regional relevance, investigating the performance of our methods on a broader spectrum of species could provide valuable insights into the generalizability of our models.\n\nExpanding the geographical scope of our approach is another intriguing prospect. Our study was confined to a localized area in North Rhine-Westphalia (NRW). Testing the project's performance in diverse regions with similar species could unravel variations influenced by different environmental conditions. Additionally, exploring potential spatial trends in derived parameters and model performance could enhance our understanding of broader patterns.\n\nIf tree-level datasets are available, future research could test the derived parameters without the assumption that all trees within a patch share the same species. This would offer a more nuanced representation of individual tree characteristics and potentially enhance the accuracy of the random forest models.\n\nQuantitative parameter selection methods present an opportunity for optimization. Moving beyond a trial-and-error approach, incorporating metrics like Kullback-Leibler Divergence (KLD) and Jensen-Shannon Divergence (JSD) into the selection process could provide a systematic and data-driven way to identify relevant parameters. Advanced techniques, such as reinforced learning methods, may also hold promise in this context.\n\nDataset quality optimization, particularly the removal of outliers, is another avenue for exploration. Many character distributions in our dataset exhibited outliers, and assessing the impact of outlier removal on random forest accuracy could be a valuable optimization strategy.\n\nFinally, exploring additional tree statistics beyond those considered in our current study could enrich our understanding. This might involve investigating intensity distribution, the number of returns distribution on the z-axis per tree, and more sophisticated spatial point pattern analyses [@pebesma2023spatial]. Techniques like Ripley’s reduced second moment function [@ripley1977modelling] could offer deeper insights into spatial patterns.\n\nIncorporating these avenues into future research endeavors has the potential to advance the field, refining methodologies and expanding the applicability of tree species prediction and analysis. Our work, while a significant step forward, lays the groundwork for a more comprehensive exploration of the intricacies within this domain.\n      \n\n## Conclusion\n\nOur research aimed to investigate the usability of LiDAR data in distinguishing between tree species in monocultural forests, contributing to the field of forest monitoring. The overall success of our approach suggests promising outcomes. However, it's important to acknowledge and further address certain limitations identified in our work. Future endeavors in this line of research could delve deeper into these limitations to enhance the robustness and applicability of the methodology. The potential utility of our approach in forest monitoring applications is a significant finding. The ability to distinguish between tree species in monocultural forests using LiDAR data offers valuable insights for forest management and ecological studies. The success of our methodology lays a foundation for continued research and application in real-world scenarios, potentially influencing forest monitoring practices.\n\nIn summary, our research has demonstrated the viability of using LiDAR data for distinguishing tree species in monocultural forests, contributing to the broader field of forest monitoring. By addressing and expanding upon the identified limitations, our approach has the potential to become a valuable tool in practical forest management and environmental research.\n\n\n\n\n\n# References\n\n::: {#refs}\n:::\n\n# Appendix\n## Script which can be used to do all preprocessing {#sec-appendix-preprocessing}\n\n\n::: {.cell}\n\n:::\n\n\n\nLoad the file with the research areas\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsf <- sf::read_sf(here::here(\"research_areas.shp\"), quiet = TRUE)\n```\n:::\n\n\n\nInit the project\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(lfa)\nsf::sf_use_s2(FALSE)\nlocations <- lfa_init(\"research_areas.shp\")\n```\n:::\n\n\n\n\nDo all of the preprocessing steps\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#lfa::lfa_map_tile_locations(locations, lfa::retile,check_flag = \"retile\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlfa::lfa_map_tile_locations(locations, lfa::lfa_intersect_areas, ctg = NULL, areas_sf = sf,check_flag = \"intersect\")\nlfa::lfa_map_tile_locations(locations, lfa::lfa_ground_correction, ctg = NULL,check_flag = \"z_correction\")\nlfa::lfa_map_tile_locations(locations, lfa::lfa_segmentation, ctg = NULL,check_flag = \"segmentation\")\nlfa::lfa_map_tile_locations(locations, lfa::lfa_detection, catalog = NULL, write_to_file = TRUE,check_flag = \"detection\")\n```\n:::\n\n\n\n\n## Quantitative Results\n### Distribution of Z-Values\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\ndata <- lfa::lfa_get_detections()\nvalue_column <- \"Z\"\n```\n:::\n\n\n\n\n#### Kullback-Leibler-Divergence\n\n\n\n\n::: {#tbl-z-values-kld_specie .cell tbl-cap='Kullback-Leibler-Divergence between the researched species Beech, Oak, Pine and Spruce for the atrribute z-values'}\n\n```{.r .cell-code  code-fold=\"true\"}\nkld_results_specie <- lfa::lfa_run_test_asymmetric(data,value_column,\"specie\",lfa::lfa_kld_from_vec)\nlfa::lfa_generate_result_table_tests(kld_results_specie,\"Kullback-Leibler-Divergence between species\")\n```\n\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table table-bordered table\" style=\"width: auto !important; margin-left: auto; margin-right: auto;\">\n<caption>Kullback-Leibler-Divergence between species</caption>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\">   </th>\n   <th style=\"text-align:left;\"> Beech </th>\n   <th style=\"text-align:left;\"> Oak </th>\n   <th style=\"text-align:left;\"> Pine </th>\n   <th style=\"text-align:left;\"> Spruce </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Beech </td>\n   <td style=\"text-align:left;\"> 0.0 </td>\n   <td style=\"text-align:left;\"> 13.2 </td>\n   <td style=\"text-align:left;\"> 12.5 </td>\n   <td style=\"text-align:left;\"> 0.76 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Oak </td>\n   <td style=\"text-align:left;\"> 4.2 </td>\n   <td style=\"text-align:left;\"> 0.0 </td>\n   <td style=\"text-align:left;\"> 3.4 </td>\n   <td style=\"text-align:left;\"> 5.02 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Pine </td>\n   <td style=\"text-align:left;\"> 2.3 </td>\n   <td style=\"text-align:left;\"> 5.6 </td>\n   <td style=\"text-align:left;\"> 0.0 </td>\n   <td style=\"text-align:left;\"> 3.95 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Spruce </td>\n   <td style=\"text-align:left;\"> 2.4 </td>\n   <td style=\"text-align:left;\"> 14.7 </td>\n   <td style=\"text-align:left;\"> 16.1 </td>\n   <td style=\"text-align:left;\"> 0.00 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncolMeans(kld_results_specie, na.rm = TRUE) |> mean()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5.252696\n```\n:::\n:::\n\n::: {#tbl-z-values-kld-beech .cell tbl-cap='Kullback-Leibler-Divergence between the researched areas which have the dominante specie beech for the atrribute z-values'}\n\n```{.r .cell-code  code-fold=\"true\"}\nspecie <- data[data$specie==\"beech\",]\nkld_results_beech <- lfa::lfa_run_test_asymmetric(specie,value_column,\"area\",lfa::lfa_kld_from_vec)\nlfa::lfa_generate_result_table_tests(kld_results_beech,\"Kullback-Leibler-Divergence between areas with beech\")\n```\n\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table table-bordered table\" style=\"width: auto !important; margin-left: auto; margin-right: auto;\">\n<caption>Kullback-Leibler-Divergence between areas with beech</caption>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\">   </th>\n   <th style=\"text-align:left;\"> Bielefeld_brackwede </th>\n   <th style=\"text-align:left;\"> Billerbeck </th>\n   <th style=\"text-align:left;\"> Wuelfenrath </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Bielefeld_brackwede </td>\n   <td style=\"text-align:left;\"> 0.00 </td>\n   <td style=\"text-align:left;\"> 0.4 </td>\n   <td style=\"text-align:left;\"> 3.1 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Billerbeck </td>\n   <td style=\"text-align:left;\"> 0.27 </td>\n   <td style=\"text-align:left;\"> 0.0 </td>\n   <td style=\"text-align:left;\"> 6.0 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Wuelfenrath </td>\n   <td style=\"text-align:left;\"> 1.13 </td>\n   <td style=\"text-align:left;\"> 2.4 </td>\n   <td style=\"text-align:left;\"> 0.0 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncolMeans(kld_results_beech, na.rm = TRUE) |> mean()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1.473353\n```\n:::\n:::\n\n::: {#tbl-z-values-kld-oak .cell tbl-cap='Kullback-Leibler-Divergence between the researched areas which have the dominante specie oak for the atrribute z-values'}\n\n```{.r .cell-code  code-fold=\"true\"}\nspecie <- data[data$specie==\"oak\",]\nkld_results_oak <- lfa::lfa_run_test_asymmetric(specie,value_column,\"area\",lfa::lfa_kld_from_vec)\nlfa::lfa_generate_result_table_tests(kld_results_oak,\"Kullback-Leibler-Divergence between areas with oak\")\n```\n\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table table-bordered table\" style=\"width: auto !important; margin-left: auto; margin-right: auto;\">\n<caption>Kullback-Leibler-Divergence between areas with oak</caption>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\">   </th>\n   <th style=\"text-align:left;\"> Hamm </th>\n   <th style=\"text-align:left;\"> Muenster </th>\n   <th style=\"text-align:left;\"> Rinkerode </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Hamm </td>\n   <td style=\"text-align:left;\"> 0.0 </td>\n   <td style=\"text-align:left;\"> 2.1 </td>\n   <td style=\"text-align:left;\"> 16 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Muenster </td>\n   <td style=\"text-align:left;\"> 0.4 </td>\n   <td style=\"text-align:left;\"> 0.0 </td>\n   <td style=\"text-align:left;\"> 17 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Rinkerode </td>\n   <td style=\"text-align:left;\"> 7.6 </td>\n   <td style=\"text-align:left;\"> 17.8 </td>\n   <td style=\"text-align:left;\"> 0 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncolMeans(kld_results_oak, na.rm = TRUE) |> mean()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 6.779863\n```\n:::\n:::\n\n::: {#tbl-z-values-kld-pine .cell tbl-cap='Kullback-Leibler-Divergence between the researched areas which have the dominante specie pine for the atrribute z-values'}\n\n```{.r .cell-code  code-fold=\"true\"}\nspecie <- data[data$specie==\"pine\",]\nkld_results_pine <- lfa::lfa_run_test_asymmetric(specie,value_column,\"area\",lfa::lfa_kld_from_vec)\nlfa::lfa_generate_result_table_tests(kld_results_pine,\"Kullback-Leibler-Divergence between areas with pine\")\n```\n\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table table-bordered table\" style=\"width: auto !important; margin-left: auto; margin-right: auto;\">\n<caption>Kullback-Leibler-Divergence between areas with pine</caption>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\">   </th>\n   <th style=\"text-align:left;\"> Greffen </th>\n   <th style=\"text-align:left;\"> Mesum </th>\n   <th style=\"text-align:left;\"> Telgte </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Greffen </td>\n   <td style=\"text-align:left;\"> 0.00 </td>\n   <td style=\"text-align:left;\"> 0.74 </td>\n   <td style=\"text-align:left;\"> 16 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Mesum </td>\n   <td style=\"text-align:left;\"> 0.43 </td>\n   <td style=\"text-align:left;\"> 0.00 </td>\n   <td style=\"text-align:left;\"> 18 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Telgte </td>\n   <td style=\"text-align:left;\"> 3.87 </td>\n   <td style=\"text-align:left;\"> 6.82 </td>\n   <td style=\"text-align:left;\"> 0 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncolMeans(kld_results_pine, na.rm = TRUE) |> mean()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5.129383\n```\n:::\n:::\n\n::: {#tbl-z-values-kld-spruce .cell tbl-cap='Kullback-Leibler-Divergence between the researched areas which have the dominante specie spruce for the atrribute z-values'}\n\n```{.r .cell-code  code-fold=\"true\"}\nspecie <- data[data$specie==\"spruce\",]\nkld_results_spruce <- lfa::lfa_run_test_asymmetric(specie,value_column,\"area\",lfa::lfa_kld_from_vec)\nlfa::lfa_generate_result_table_tests(kld_results_spruce,\"Kullback-Leibler-Divergence between areas with spruce\")\n```\n\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table table-bordered table\" style=\"width: auto !important; margin-left: auto; margin-right: auto;\">\n<caption>Kullback-Leibler-Divergence between areas with spruce</caption>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\">   </th>\n   <th style=\"text-align:left;\"> Brilon </th>\n   <th style=\"text-align:left;\"> Oberhundem </th>\n   <th style=\"text-align:left;\"> Osterwald </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Brilon </td>\n   <td style=\"text-align:left;\"> 0.000 </td>\n   <td style=\"text-align:left;\"> 0.092 </td>\n   <td style=\"text-align:left;\"> 1.7 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Oberhundem </td>\n   <td style=\"text-align:left;\"> 0.081 </td>\n   <td style=\"text-align:left;\"> 0.000 </td>\n   <td style=\"text-align:left;\"> 2.1 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Osterwald </td>\n   <td style=\"text-align:left;\"> 1.521 </td>\n   <td style=\"text-align:left;\"> 2.178 </td>\n   <td style=\"text-align:left;\"> 0.0 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncolMeans(kld_results_spruce, na.rm = TRUE) |> mean()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.8509258\n```\n:::\n:::\n\n\n\n\n\n#### Jensen-Shannon Divergence\n\n\n\n\n::: {#tbl-z-values-jsd_specie .cell tbl-cap='Jensen-Shannon Divergence between the researched species Beech, Oak, Pine and Spruce for the atrribute z-values'}\n\n```{.r .cell-code  code-fold=\"true\"}\njsd_results_specie <- lfa::lfa_run_test_symmetric(data,value_column,\"specie\",lfa::lfa_jsd_from_vec)\nlfa::lfa_generate_result_table_tests(jsd_results_specie,\"Jensen-Shannon Divergence between species\")\n```\n\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table table-bordered table\" style=\"width: auto !important; margin-left: auto; margin-right: auto;\">\n<caption>Jensen-Shannon Divergence between species</caption>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\">   </th>\n   <th style=\"text-align:left;\"> Beech </th>\n   <th style=\"text-align:left;\"> Oak </th>\n   <th style=\"text-align:left;\"> Pine </th>\n   <th style=\"text-align:left;\"> Spruce </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Beech </td>\n   <td style=\"text-align:left;\"> 0 </td>\n   <td style=\"text-align:left;\"> 4.5 </td>\n   <td style=\"text-align:left;\"> 4.6 </td>\n   <td style=\"text-align:left;\"> 2.4 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Oak </td>\n   <td style=\"text-align:left;\"> NA </td>\n   <td style=\"text-align:left;\"> 0.0 </td>\n   <td style=\"text-align:left;\"> 3.9 </td>\n   <td style=\"text-align:left;\"> 6.1 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Pine </td>\n   <td style=\"text-align:left;\"> NA </td>\n   <td style=\"text-align:left;\"> NA </td>\n   <td style=\"text-align:left;\"> 0.0 </td>\n   <td style=\"text-align:left;\"> 7.1 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Spruce </td>\n   <td style=\"text-align:left;\"> NA </td>\n   <td style=\"text-align:left;\"> NA </td>\n   <td style=\"text-align:left;\"> NA </td>\n   <td style=\"text-align:left;\"> 0.0 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncolMeans(jsd_results_specie, na.rm = TRUE) |> mean()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2.246663\n```\n:::\n:::\n\n::: {#tbl-z-values-jsd-beech .cell tbl-cap='Jensen-Shannon Divergence between the researched areas which have the dominante specie beech for the atrribute z-values'}\n\n```{.r .cell-code  code-fold=\"true\"}\nspecie <- data[data$specie==\"beech\",]\njsd_results_beech <- lfa::lfa_run_test_symmetric(specie,value_column,\"area\",lfa::lfa_jsd_from_vec)\nlfa::lfa_generate_result_table_tests(jsd_results_beech,\"Jensen-Shannon Divergence between areas with beech\")\n```\n\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table table-bordered table\" style=\"width: auto !important; margin-left: auto; margin-right: auto;\">\n<caption>Jensen-Shannon Divergence between areas with beech</caption>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\">   </th>\n   <th style=\"text-align:left;\"> Bielefeld_brackwede </th>\n   <th style=\"text-align:left;\"> Billerbeck </th>\n   <th style=\"text-align:left;\"> Wuelfenrath </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Bielefeld_brackwede </td>\n   <td style=\"text-align:left;\"> 0 </td>\n   <td style=\"text-align:left;\"> 1.1 </td>\n   <td style=\"text-align:left;\"> 3.3 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Billerbeck </td>\n   <td style=\"text-align:left;\"> NA </td>\n   <td style=\"text-align:left;\"> 0.0 </td>\n   <td style=\"text-align:left;\"> 4.9 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Wuelfenrath </td>\n   <td style=\"text-align:left;\"> NA </td>\n   <td style=\"text-align:left;\"> NA </td>\n   <td style=\"text-align:left;\"> 0.0 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncolMeans(jsd_results_beech, na.rm = TRUE) |> mean()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1.10555\n```\n:::\n:::\n\n::: {#tbl-z-values-jsd-oak .cell tbl-cap='Jensen-Shannon Divergence between the researched areas which have the dominante specie oak for the atrribute z-values'}\n\n```{.r .cell-code  code-fold=\"true\"}\nspecie <- data[data$specie==\"oak\",]\njsd_results_oak <- lfa::lfa_run_test_symmetric(specie,value_column,\"area\",lfa::lfa_jsd_from_vec)\nlfa::lfa_generate_result_table_tests(jsd_results_oak,\"Jensen-Shannon Divergence between areas with oak\")\n```\n\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table table-bordered table\" style=\"width: auto !important; margin-left: auto; margin-right: auto;\">\n<caption>Jensen-Shannon Divergence between areas with oak</caption>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\">   </th>\n   <th style=\"text-align:left;\"> Hamm </th>\n   <th style=\"text-align:left;\"> Muenster </th>\n   <th style=\"text-align:left;\"> Rinkerode </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Hamm </td>\n   <td style=\"text-align:left;\"> 0 </td>\n   <td style=\"text-align:left;\"> 1.6 </td>\n   <td style=\"text-align:left;\"> 6.5 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Muenster </td>\n   <td style=\"text-align:left;\"> NA </td>\n   <td style=\"text-align:left;\"> 0.0 </td>\n   <td style=\"text-align:left;\"> 6.4 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Rinkerode </td>\n   <td style=\"text-align:left;\"> NA </td>\n   <td style=\"text-align:left;\"> NA </td>\n   <td style=\"text-align:left;\"> 0.0 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncolMeans(jsd_results_oak, na.rm = TRUE) |> mean()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1.692942\n```\n:::\n:::\n\n::: {#tbl-z-values-jsd-pine .cell tbl-cap='Jensen-Shannon Divergence between the researched areas which have the dominante specie pine for the atrribute z-values'}\n\n```{.r .cell-code  code-fold=\"true\"}\nspecie <- data[data$specie==\"pine\",]\njsd_results_pine <- lfa::lfa_run_test_symmetric(specie,value_column,\"area\",lfa::lfa_jsd_from_vec)\nlfa::lfa_generate_result_table_tests(jsd_results_pine,\"Jensen-Shannon Divergence between areas with pine\")\n```\n\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table table-bordered table\" style=\"width: auto !important; margin-left: auto; margin-right: auto;\">\n<caption>Jensen-Shannon Divergence between areas with pine</caption>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\">   </th>\n   <th style=\"text-align:left;\"> Greffen </th>\n   <th style=\"text-align:left;\"> Mesum </th>\n   <th style=\"text-align:left;\"> Telgte </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Greffen </td>\n   <td style=\"text-align:left;\"> 0 </td>\n   <td style=\"text-align:left;\"> 3.1 </td>\n   <td style=\"text-align:left;\"> 12 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Mesum </td>\n   <td style=\"text-align:left;\"> NA </td>\n   <td style=\"text-align:left;\"> 0.0 </td>\n   <td style=\"text-align:left;\"> 10 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Telgte </td>\n   <td style=\"text-align:left;\"> NA </td>\n   <td style=\"text-align:left;\"> NA </td>\n   <td style=\"text-align:left;\"> 0 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncolMeans(jsd_results_pine, na.rm = TRUE) |> mean()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2.956354\n```\n:::\n:::\n\n::: {#tbl-z-values-jsd-spruce .cell tbl-cap='Jensen-Shannon Divergence between the researched areas which have the dominante specie spruce for the atrribute z-values'}\n\n```{.r .cell-code  code-fold=\"true\"}\nspecie <- data[data$specie==\"spruce\",]\njsd_results_spruce <- lfa::lfa_run_test_symmetric(specie,value_column,\"area\",lfa::lfa_jsd_from_vec)\nlfa::lfa_generate_result_table_tests(jsd_results_spruce,\"Jensen-Shannon Divergence between areas with spruce\")\n```\n\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table table-bordered table\" style=\"width: auto !important; margin-left: auto; margin-right: auto;\">\n<caption>Jensen-Shannon Divergence between areas with spruce</caption>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\">   </th>\n   <th style=\"text-align:left;\"> Brilon </th>\n   <th style=\"text-align:left;\"> Oberhundem </th>\n   <th style=\"text-align:left;\"> Osterwald </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Brilon </td>\n   <td style=\"text-align:left;\"> 0 </td>\n   <td style=\"text-align:left;\"> 0.31 </td>\n   <td style=\"text-align:left;\"> 4.0 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Oberhundem </td>\n   <td style=\"text-align:left;\"> NA </td>\n   <td style=\"text-align:left;\"> 0.00 </td>\n   <td style=\"text-align:left;\"> 5.5 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Osterwald </td>\n   <td style=\"text-align:left;\"> NA </td>\n   <td style=\"text-align:left;\"> NA </td>\n   <td style=\"text-align:left;\"> 0.0 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncolMeans(jsd_results_spruce, na.rm = TRUE) |> mean()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1.100383\n```\n:::\n:::\n\n\n\n\n\n### Nearest Neighbours\n#### Distribution of nearest neighbor distances\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\ndata <- lfa::lfa_combine_sf_obj(lfa::lfa_get_neighbor_paths(),lfa::lfa_get_all_areas())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nReading layer `neighbours' from data source \n  `/home/jakob/gi-master/project-courses/lidar-forest-analysis/src/data/beech/bielefeld_brackwede/neighbours.gpkg' \n  using driver `GPKG'\nSimple feature collection with 1443 features and 102 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 466999.8 ymin: 5759839 xmax: 467617.1 ymax: 5760261\nProjected CRS: ETRS89 / UTM zone 32N\nReading layer `neighbours' from data source \n  `/home/jakob/gi-master/project-courses/lidar-forest-analysis/src/data/beech/billerbeck/neighbours.gpkg' \n  using driver `GPKG'\nSimple feature collection with 1732 features and 102 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 384890.8 ymin: 5761918 xmax: 385590.9 ymax: 5762478\nProjected CRS: ETRS89 / UTM zone 32N\nReading layer `neighbours' from data source \n  `/home/jakob/gi-master/project-courses/lidar-forest-analysis/src/data/beech/wuelfenrath/neighbours.gpkg' \n  using driver `GPKG'\nSimple feature collection with 2779 features and 102 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 365546.3 ymin: 5683711 xmax: 366356.1 ymax: 5684321\nProjected CRS: ETRS89 / UTM zone 32N\nReading layer `neighbours' from data source \n  `/home/jakob/gi-master/project-courses/lidar-forest-analysis/src/data/oak/hamm/neighbours.gpkg' \n  using driver `GPKG'\nSimple feature collection with 2441 features and 102 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 420953.3 ymin: 5723884 xmax: 421596 ymax: 5724609\nProjected CRS: ETRS89 / UTM zone 32N\nReading layer `neighbours' from data source \n  `/home/jakob/gi-master/project-courses/lidar-forest-analysis/src/data/oak/muenster/neighbours.gpkg' \n  using driver `GPKG'\nSimple feature collection with 1270 features and 102 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 404615.6 ymin: 5752535 xmax: 405396.8 ymax: 5752971\nProjected CRS: ETRS89 / UTM zone 32N\nReading layer `neighbours' from data source \n  `/home/jakob/gi-master/project-courses/lidar-forest-analysis/src/data/oak/rinkerode/neighbours.gpkg' \n  using driver `GPKG'\nSimple feature collection with 1643 features and 102 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 408428.2 ymin: 5746021 xmax: 409014.8 ymax: 5746511\nProjected CRS: ETRS89 / UTM zone 32N\nReading layer `neighbours' from data source \n  `/home/jakob/gi-master/project-courses/lidar-forest-analysis/src/data/pine/greffen/neighbours.gpkg' \n  using driver `GPKG'\nSimple feature collection with 513 features and 102 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 442816.1 ymin: 5760217 xmax: 443148.9 ymax: 5760567\nProjected CRS: ETRS89 / UTM zone 32N\nReading layer `neighbours' from data source \n  `/home/jakob/gi-master/project-courses/lidar-forest-analysis/src/data/pine/mesum/neighbours.gpkg' \n  using driver `GPKG'\nSimple feature collection with 5031 features and 102 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 399930.6 ymin: 5790412 xmax: 400969.7 ymax: 5790950\nProjected CRS: ETRS89 / UTM zone 32N\nReading layer `neighbours' from data source \n  `/home/jakob/gi-master/project-courses/lidar-forest-analysis/src/data/pine/telgte/neighbours.gpkg' \n  using driver `GPKG'\nSimple feature collection with 3368 features and 102 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 416135.1 ymin: 5761663 xmax: 416697.1 ymax: 5762477\nProjected CRS: ETRS89 / UTM zone 32N\nReading layer `neighbours' from data source \n  `/home/jakob/gi-master/project-courses/lidar-forest-analysis/src/data/spruce/brilon/neighbours.gpkg' \n  using driver `GPKG'\nSimple feature collection with 3342 features and 102 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 467305.7 ymin: 5695055 xmax: 467996.9 ymax: 5695593\nProjected CRS: ETRS89 / UTM zone 32N\nReading layer `neighbours' from data source \n  `/home/jakob/gi-master/project-courses/lidar-forest-analysis/src/data/spruce/oberhundem/neighbours.gpkg' \n  using driver `GPKG'\nSimple feature collection with 2471 features and 102 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 442631.7 ymin: 5660096 xmax: 443309.5 ymax: 5660502\nProjected CRS: ETRS89 / UTM zone 32N\nReading layer `neighbours' from data source \n  `/home/jakob/gi-master/project-courses/lidar-forest-analysis/src/data/spruce/osterwald/neighbours.gpkg' \n  using driver `GPKG'\nSimple feature collection with 2806 features and 102 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 455822 ymin: 5673761 xmax: 456483.2 ymax: 5674162\nProjected CRS: ETRS89 / UTM zone 32N\n```\n:::\n\n```{.r .cell-code  code-fold=\"true\"}\nvalue_column <- \"Neighbor_1\"\n```\n:::\n\n\n\n\n##### Kullback-Leibler-Divergence\n\n\n\n\n::: {#tbl-nearest-neighbor-1-kld_specie .cell tbl-cap='Kullback-Leibler-Divergence between the researched species Beech, Oak, Pine and Spruce for the atrribute nearest-neighbor-1'}\n\n```{.r .cell-code  code-fold=\"true\"}\nkld_results_specie <- lfa::lfa_run_test_asymmetric(data,value_column,\"specie\",lfa::lfa_kld_from_vec)\nlfa::lfa_generate_result_table_tests(kld_results_specie,\"Kullback-Leibler-Divergence between species\")\n```\n\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table table-bordered table\" style=\"width: auto !important; margin-left: auto; margin-right: auto;\">\n<caption>Kullback-Leibler-Divergence between species</caption>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\">   </th>\n   <th style=\"text-align:left;\"> Beech </th>\n   <th style=\"text-align:left;\"> Oak </th>\n   <th style=\"text-align:left;\"> Pine </th>\n   <th style=\"text-align:left;\"> Spruce </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Beech </td>\n   <td style=\"text-align:left;\"> 0.000 </td>\n   <td style=\"text-align:left;\"> 0.029 </td>\n   <td style=\"text-align:left;\"> 0.40 </td>\n   <td style=\"text-align:left;\"> 3.3 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Oak </td>\n   <td style=\"text-align:left;\"> 0.031 </td>\n   <td style=\"text-align:left;\"> 0.000 </td>\n   <td style=\"text-align:left;\"> 0.25 </td>\n   <td style=\"text-align:left;\"> 3.9 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Pine </td>\n   <td style=\"text-align:left;\"> 0.213 </td>\n   <td style=\"text-align:left;\"> 0.128 </td>\n   <td style=\"text-align:left;\"> 0.00 </td>\n   <td style=\"text-align:left;\"> 4.9 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Spruce </td>\n   <td style=\"text-align:left;\"> 2.735 </td>\n   <td style=\"text-align:left;\"> 3.199 </td>\n   <td style=\"text-align:left;\"> 4.52 </td>\n   <td style=\"text-align:left;\"> 0.0 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncolMeans(kld_results_specie, na.rm = TRUE) |> mean()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1.477983\n```\n:::\n:::\n\n::: {#tbl-nearest-neighbor-1-kld-beech .cell tbl-cap='Kullback-Leibler-Divergence between the researched areas which have the dominante specie beech for the atrribute nearest-neighbor-1'}\n\n```{.r .cell-code  code-fold=\"true\"}\nspecie <- data[data$specie==\"beech\",]\nkld_results_beech <- lfa::lfa_run_test_asymmetric(specie,value_column,\"area\",lfa::lfa_kld_from_vec)\nlfa::lfa_generate_result_table_tests(kld_results_beech,\"Kullback-Leibler-Divergence between areas with beech\")\n```\n\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table table-bordered table\" style=\"width: auto !important; margin-left: auto; margin-right: auto;\">\n<caption>Kullback-Leibler-Divergence between areas with beech</caption>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\">   </th>\n   <th style=\"text-align:left;\"> Bielefeld_brackwede </th>\n   <th style=\"text-align:left;\"> Billerbeck </th>\n   <th style=\"text-align:left;\"> Wuelfenrath </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Bielefeld_brackwede </td>\n   <td style=\"text-align:left;\"> 0.000 </td>\n   <td style=\"text-align:left;\"> 0.35 </td>\n   <td style=\"text-align:left;\"> 0.051 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Billerbeck </td>\n   <td style=\"text-align:left;\"> 0.380 </td>\n   <td style=\"text-align:left;\"> 0.00 </td>\n   <td style=\"text-align:left;\"> 0.138 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Wuelfenrath </td>\n   <td style=\"text-align:left;\"> 0.059 </td>\n   <td style=\"text-align:left;\"> 0.15 </td>\n   <td style=\"text-align:left;\"> 0.000 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncolMeans(kld_results_beech, na.rm = TRUE) |> mean()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.1249588\n```\n:::\n:::\n\n::: {#tbl-nearest-neighbor-1-kld-oak .cell tbl-cap='Kullback-Leibler-Divergence between the researched areas which have the dominante specie oak for the atrribute nearest-neighbor-1'}\n\n```{.r .cell-code  code-fold=\"true\"}\nspecie <- data[data$specie==\"oak\",]\nkld_results_oak <- lfa::lfa_run_test_asymmetric(specie,value_column,\"area\",lfa::lfa_kld_from_vec)\nlfa::lfa_generate_result_table_tests(kld_results_oak,\"Kullback-Leibler-Divergence between areas with oak\")\n```\n\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table table-bordered table\" style=\"width: auto !important; margin-left: auto; margin-right: auto;\">\n<caption>Kullback-Leibler-Divergence between areas with oak</caption>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\">   </th>\n   <th style=\"text-align:left;\"> Hamm </th>\n   <th style=\"text-align:left;\"> Muenster </th>\n   <th style=\"text-align:left;\"> Rinkerode </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Hamm </td>\n   <td style=\"text-align:left;\"> 0.000 </td>\n   <td style=\"text-align:left;\"> 0.079 </td>\n   <td style=\"text-align:left;\"> 0.078 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Muenster </td>\n   <td style=\"text-align:left;\"> 0.092 </td>\n   <td style=\"text-align:left;\"> 0.000 </td>\n   <td style=\"text-align:left;\"> 0.019 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Rinkerode </td>\n   <td style=\"text-align:left;\"> 0.086 </td>\n   <td style=\"text-align:left;\"> 0.020 </td>\n   <td style=\"text-align:left;\"> 0.000 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncolMeans(kld_results_oak, na.rm = TRUE) |> mean()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.04167636\n```\n:::\n:::\n\n::: {#tbl-nearest-neighbor-1-kld-pine .cell tbl-cap='Kullback-Leibler-Divergence between the researched areas which have the dominante specie pine for the atrribute nearest-neighbor-1'}\n\n```{.r .cell-code  code-fold=\"true\"}\nspecie <- data[data$specie==\"pine\",]\nkld_results_pine <- lfa::lfa_run_test_asymmetric(specie,value_column,\"area\",lfa::lfa_kld_from_vec)\nlfa::lfa_generate_result_table_tests(kld_results_pine,\"Kullback-Leibler-Divergence between areas with pine\")\n```\n\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table table-bordered table\" style=\"width: auto !important; margin-left: auto; margin-right: auto;\">\n<caption>Kullback-Leibler-Divergence between areas with pine</caption>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\">   </th>\n   <th style=\"text-align:left;\"> Greffen </th>\n   <th style=\"text-align:left;\"> Mesum </th>\n   <th style=\"text-align:left;\"> Telgte </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Greffen </td>\n   <td style=\"text-align:left;\"> 0.00 </td>\n   <td style=\"text-align:left;\"> 0.495 </td>\n   <td style=\"text-align:left;\"> 0.258 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Mesum </td>\n   <td style=\"text-align:left;\"> 0.48 </td>\n   <td style=\"text-align:left;\"> 0.000 </td>\n   <td style=\"text-align:left;\"> 0.098 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Telgte </td>\n   <td style=\"text-align:left;\"> 0.22 </td>\n   <td style=\"text-align:left;\"> 0.076 </td>\n   <td style=\"text-align:left;\"> 0.000 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncolMeans(kld_results_pine, na.rm = TRUE) |> mean()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.1812239\n```\n:::\n:::\n\n::: {#tbl-nearest-neighbor-1-kld-spruce .cell tbl-cap='Kullback-Leibler-Divergence between the researched areas which have the dominante specie spruce for the atrribute nearest-neighbor-1'}\n\n```{.r .cell-code  code-fold=\"true\"}\nspecie <- data[data$specie==\"spruce\",]\nkld_results_spruce <- lfa::lfa_run_test_asymmetric(specie,value_column,\"area\",lfa::lfa_kld_from_vec)\nlfa::lfa_generate_result_table_tests(kld_results_spruce,\"Kullback-Leibler-Divergence between areas with spruce\")\n```\n\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table table-bordered table\" style=\"width: auto !important; margin-left: auto; margin-right: auto;\">\n<caption>Kullback-Leibler-Divergence between areas with spruce</caption>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\">   </th>\n   <th style=\"text-align:left;\"> Brilon </th>\n   <th style=\"text-align:left;\"> Oberhundem </th>\n   <th style=\"text-align:left;\"> Osterwald </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Brilon </td>\n   <td style=\"text-align:left;\"> 0.00 </td>\n   <td style=\"text-align:left;\"> 0.67 </td>\n   <td style=\"text-align:left;\"> 5.1 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Oberhundem </td>\n   <td style=\"text-align:left;\"> 0.41 </td>\n   <td style=\"text-align:left;\"> 0.00 </td>\n   <td style=\"text-align:left;\"> 7.2 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Osterwald </td>\n   <td style=\"text-align:left;\"> 6.09 </td>\n   <td style=\"text-align:left;\"> 6.23 </td>\n   <td style=\"text-align:left;\"> 0.0 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncolMeans(kld_results_spruce, na.rm = TRUE) |> mean()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2.863587\n```\n:::\n:::\n\n\n\n\n\n##### Jensen-Shannon Divergence\n\n\n\n\n::: {#tbl-nearest-neighbor-1-jsd_specie .cell tbl-cap='Jensen-Shannon Divergence between the researched species Beech, Oak, Pine and Spruce for the atrribute nearest-neighbor-1'}\n\n```{.r .cell-code  code-fold=\"true\"}\njsd_results_specie <- lfa::lfa_run_test_symmetric(data,value_column,\"specie\",lfa::lfa_jsd_from_vec)\nlfa::lfa_generate_result_table_tests(jsd_results_specie,\"Jensen-Shannon Divergence between species\")\n```\n\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table table-bordered table\" style=\"width: auto !important; margin-left: auto; margin-right: auto;\">\n<caption>Jensen-Shannon Divergence between species</caption>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\">   </th>\n   <th style=\"text-align:left;\"> Beech </th>\n   <th style=\"text-align:left;\"> Oak </th>\n   <th style=\"text-align:left;\"> Pine </th>\n   <th style=\"text-align:left;\"> Spruce </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Beech </td>\n   <td style=\"text-align:left;\"> 0 </td>\n   <td style=\"text-align:left;\"> 0.22 </td>\n   <td style=\"text-align:left;\"> 2.1 </td>\n   <td style=\"text-align:left;\"> 9.3 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Oak </td>\n   <td style=\"text-align:left;\"> NA </td>\n   <td style=\"text-align:left;\"> 0.00 </td>\n   <td style=\"text-align:left;\"> 1.3 </td>\n   <td style=\"text-align:left;\"> 10.6 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Pine </td>\n   <td style=\"text-align:left;\"> NA </td>\n   <td style=\"text-align:left;\"> NA </td>\n   <td style=\"text-align:left;\"> 0.0 </td>\n   <td style=\"text-align:left;\"> 14.7 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Spruce </td>\n   <td style=\"text-align:left;\"> NA </td>\n   <td style=\"text-align:left;\"> NA </td>\n   <td style=\"text-align:left;\"> NA </td>\n   <td style=\"text-align:left;\"> 0.0 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncolMeans(jsd_results_specie, na.rm = TRUE) |> mean()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2.470051\n```\n:::\n:::\n\n::: {#tbl-nearest-neighbor-1-jsd-beech .cell tbl-cap='Jensen-Shannon Divergence between the researched areas which have the dominante specie beech for the atrribute nearest-neighbor-1'}\n\n```{.r .cell-code  code-fold=\"true\"}\nspecie <- data[data$specie==\"beech\",]\njsd_results_beech <- lfa::lfa_run_test_symmetric(specie,value_column,\"area\",lfa::lfa_jsd_from_vec)\nlfa::lfa_generate_result_table_tests(jsd_results_beech,\"Jensen-Shannon Divergence between areas with beech\")\n```\n\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table table-bordered table\" style=\"width: auto !important; margin-left: auto; margin-right: auto;\">\n<caption>Jensen-Shannon Divergence between areas with beech</caption>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\">   </th>\n   <th style=\"text-align:left;\"> Bielefeld_brackwede </th>\n   <th style=\"text-align:left;\"> Billerbeck </th>\n   <th style=\"text-align:left;\"> Wuelfenrath </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Bielefeld_brackwede </td>\n   <td style=\"text-align:left;\"> 0 </td>\n   <td style=\"text-align:left;\"> 2.2 </td>\n   <td style=\"text-align:left;\"> 0.39 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Billerbeck </td>\n   <td style=\"text-align:left;\"> NA </td>\n   <td style=\"text-align:left;\"> 0.0 </td>\n   <td style=\"text-align:left;\"> 0.85 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Wuelfenrath </td>\n   <td style=\"text-align:left;\"> NA </td>\n   <td style=\"text-align:left;\"> NA </td>\n   <td style=\"text-align:left;\"> 0.00 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncolMeans(jsd_results_beech, na.rm = TRUE) |> mean()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.5042359\n```\n:::\n:::\n\n::: {#tbl-nearest-neighbor-1-jsd-oak .cell tbl-cap='Jensen-Shannon Divergence between the researched areas which have the dominante specie oak for the atrribute nearest-neighbor-1'}\n\n```{.r .cell-code  code-fold=\"true\"}\nspecie <- data[data$specie==\"oak\",]\njsd_results_oak <- lfa::lfa_run_test_symmetric(specie,value_column,\"area\",lfa::lfa_jsd_from_vec)\nlfa::lfa_generate_result_table_tests(jsd_results_oak,\"Jensen-Shannon Divergence between areas with oak\")\n```\n\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table table-bordered table\" style=\"width: auto !important; margin-left: auto; margin-right: auto;\">\n<caption>Jensen-Shannon Divergence between areas with oak</caption>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\">   </th>\n   <th style=\"text-align:left;\"> Hamm </th>\n   <th style=\"text-align:left;\"> Muenster </th>\n   <th style=\"text-align:left;\"> Rinkerode </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Hamm </td>\n   <td style=\"text-align:left;\"> 0 </td>\n   <td style=\"text-align:left;\"> 0.57 </td>\n   <td style=\"text-align:left;\"> 0.61 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Muenster </td>\n   <td style=\"text-align:left;\"> NA </td>\n   <td style=\"text-align:left;\"> 0.00 </td>\n   <td style=\"text-align:left;\"> 0.17 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Rinkerode </td>\n   <td style=\"text-align:left;\"> NA </td>\n   <td style=\"text-align:left;\"> NA </td>\n   <td style=\"text-align:left;\"> 0.00 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncolMeans(jsd_results_oak, na.rm = TRUE) |> mean()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.1803836\n```\n:::\n:::\n\n::: {#tbl-nearest-neighbor-1-jsd-pine .cell tbl-cap='Jensen-Shannon Divergence between the researched areas which have the dominante specie pine for the atrribute nearest-neighbor-1'}\n\n```{.r .cell-code  code-fold=\"true\"}\nspecie <- data[data$specie==\"pine\",]\njsd_results_pine <- lfa::lfa_run_test_symmetric(specie,value_column,\"area\",lfa::lfa_jsd_from_vec)\nlfa::lfa_generate_result_table_tests(jsd_results_pine,\"Jensen-Shannon Divergence between areas with pine\")\n```\n\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table table-bordered table\" style=\"width: auto !important; margin-left: auto; margin-right: auto;\">\n<caption>Jensen-Shannon Divergence between areas with pine</caption>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\">   </th>\n   <th style=\"text-align:left;\"> Greffen </th>\n   <th style=\"text-align:left;\"> Mesum </th>\n   <th style=\"text-align:left;\"> Telgte </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Greffen </td>\n   <td style=\"text-align:left;\"> 0 </td>\n   <td style=\"text-align:left;\"> 3.6 </td>\n   <td style=\"text-align:left;\"> 1.89 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Mesum </td>\n   <td style=\"text-align:left;\"> NA </td>\n   <td style=\"text-align:left;\"> 0.0 </td>\n   <td style=\"text-align:left;\"> 0.68 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Telgte </td>\n   <td style=\"text-align:left;\"> NA </td>\n   <td style=\"text-align:left;\"> NA </td>\n   <td style=\"text-align:left;\"> 0.00 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncolMeans(jsd_results_pine, na.rm = TRUE) |> mean()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.891592\n```\n:::\n:::\n\n::: {#tbl-nearest-neighbor-1-jsd-spruce .cell tbl-cap='Jensen-Shannon Divergence between the researched areas which have the dominante specie spruce for the atrribute nearest-neighbor-1'}\n\n```{.r .cell-code  code-fold=\"true\"}\nspecie <- data[data$specie==\"spruce\",]\njsd_results_spruce <- lfa::lfa_run_test_symmetric(specie,value_column,\"area\",lfa::lfa_jsd_from_vec)\nlfa::lfa_generate_result_table_tests(jsd_results_spruce,\"Jensen-Shannon Divergence between areas with spruce\")\n```\n\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table table-bordered table\" style=\"width: auto !important; margin-left: auto; margin-right: auto;\">\n<caption>Jensen-Shannon Divergence between areas with spruce</caption>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\">   </th>\n   <th style=\"text-align:left;\"> Brilon </th>\n   <th style=\"text-align:left;\"> Oberhundem </th>\n   <th style=\"text-align:left;\"> Osterwald </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Brilon </td>\n   <td style=\"text-align:left;\"> 0 </td>\n   <td style=\"text-align:left;\"> 4.1 </td>\n   <td style=\"text-align:left;\"> 16 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Oberhundem </td>\n   <td style=\"text-align:left;\"> NA </td>\n   <td style=\"text-align:left;\"> 0.0 </td>\n   <td style=\"text-align:left;\"> 18 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Osterwald </td>\n   <td style=\"text-align:left;\"> NA </td>\n   <td style=\"text-align:left;\"> NA </td>\n   <td style=\"text-align:left;\"> 0 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncolMeans(jsd_results_spruce, na.rm = TRUE) |> mean()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4.471632\n```\n:::\n:::\n\n\n\n#### Distribution of distances to 100th nearest neighbor\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\ndata <- lfa::lfa_combine_sf_obj(lfa::lfa_get_neighbor_paths(),lfa::lfa_get_all_areas())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nReading layer `neighbours' from data source \n  `/home/jakob/gi-master/project-courses/lidar-forest-analysis/src/data/beech/bielefeld_brackwede/neighbours.gpkg' \n  using driver `GPKG'\nSimple feature collection with 1443 features and 102 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 466999.8 ymin: 5759839 xmax: 467617.1 ymax: 5760261\nProjected CRS: ETRS89 / UTM zone 32N\nReading layer `neighbours' from data source \n  `/home/jakob/gi-master/project-courses/lidar-forest-analysis/src/data/beech/billerbeck/neighbours.gpkg' \n  using driver `GPKG'\nSimple feature collection with 1732 features and 102 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 384890.8 ymin: 5761918 xmax: 385590.9 ymax: 5762478\nProjected CRS: ETRS89 / UTM zone 32N\nReading layer `neighbours' from data source \n  `/home/jakob/gi-master/project-courses/lidar-forest-analysis/src/data/beech/wuelfenrath/neighbours.gpkg' \n  using driver `GPKG'\nSimple feature collection with 2779 features and 102 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 365546.3 ymin: 5683711 xmax: 366356.1 ymax: 5684321\nProjected CRS: ETRS89 / UTM zone 32N\nReading layer `neighbours' from data source \n  `/home/jakob/gi-master/project-courses/lidar-forest-analysis/src/data/oak/hamm/neighbours.gpkg' \n  using driver `GPKG'\nSimple feature collection with 2441 features and 102 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 420953.3 ymin: 5723884 xmax: 421596 ymax: 5724609\nProjected CRS: ETRS89 / UTM zone 32N\nReading layer `neighbours' from data source \n  `/home/jakob/gi-master/project-courses/lidar-forest-analysis/src/data/oak/muenster/neighbours.gpkg' \n  using driver `GPKG'\nSimple feature collection with 1270 features and 102 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 404615.6 ymin: 5752535 xmax: 405396.8 ymax: 5752971\nProjected CRS: ETRS89 / UTM zone 32N\nReading layer `neighbours' from data source \n  `/home/jakob/gi-master/project-courses/lidar-forest-analysis/src/data/oak/rinkerode/neighbours.gpkg' \n  using driver `GPKG'\nSimple feature collection with 1643 features and 102 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 408428.2 ymin: 5746021 xmax: 409014.8 ymax: 5746511\nProjected CRS: ETRS89 / UTM zone 32N\nReading layer `neighbours' from data source \n  `/home/jakob/gi-master/project-courses/lidar-forest-analysis/src/data/pine/greffen/neighbours.gpkg' \n  using driver `GPKG'\nSimple feature collection with 513 features and 102 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 442816.1 ymin: 5760217 xmax: 443148.9 ymax: 5760567\nProjected CRS: ETRS89 / UTM zone 32N\nReading layer `neighbours' from data source \n  `/home/jakob/gi-master/project-courses/lidar-forest-analysis/src/data/pine/mesum/neighbours.gpkg' \n  using driver `GPKG'\nSimple feature collection with 5031 features and 102 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 399930.6 ymin: 5790412 xmax: 400969.7 ymax: 5790950\nProjected CRS: ETRS89 / UTM zone 32N\nReading layer `neighbours' from data source \n  `/home/jakob/gi-master/project-courses/lidar-forest-analysis/src/data/pine/telgte/neighbours.gpkg' \n  using driver `GPKG'\nSimple feature collection with 3368 features and 102 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 416135.1 ymin: 5761663 xmax: 416697.1 ymax: 5762477\nProjected CRS: ETRS89 / UTM zone 32N\nReading layer `neighbours' from data source \n  `/home/jakob/gi-master/project-courses/lidar-forest-analysis/src/data/spruce/brilon/neighbours.gpkg' \n  using driver `GPKG'\nSimple feature collection with 3342 features and 102 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 467305.7 ymin: 5695055 xmax: 467996.9 ymax: 5695593\nProjected CRS: ETRS89 / UTM zone 32N\nReading layer `neighbours' from data source \n  `/home/jakob/gi-master/project-courses/lidar-forest-analysis/src/data/spruce/oberhundem/neighbours.gpkg' \n  using driver `GPKG'\nSimple feature collection with 2471 features and 102 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 442631.7 ymin: 5660096 xmax: 443309.5 ymax: 5660502\nProjected CRS: ETRS89 / UTM zone 32N\nReading layer `neighbours' from data source \n  `/home/jakob/gi-master/project-courses/lidar-forest-analysis/src/data/spruce/osterwald/neighbours.gpkg' \n  using driver `GPKG'\nSimple feature collection with 2806 features and 102 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 455822 ymin: 5673761 xmax: 456483.2 ymax: 5674162\nProjected CRS: ETRS89 / UTM zone 32N\n```\n:::\n\n```{.r .cell-code  code-fold=\"true\"}\nvalue_column <- \"Neighbor_100\"\n```\n:::\n\n\n\n\n##### Kullback-Leibler-Divergence\n\n\n\n\n::: {#tbl-nearest-neighbor-100-kld_specie .cell tbl-cap='Kullback-Leibler-Divergence between the researched species Beech, Oak, Pine and Spruce for the atrribute nearest-neighbor-100'}\n\n```{.r .cell-code  code-fold=\"true\"}\nkld_results_specie <- lfa::lfa_run_test_asymmetric(data,value_column,\"specie\",lfa::lfa_kld_from_vec)\nlfa::lfa_generate_result_table_tests(kld_results_specie,\"Kullback-Leibler-Divergence between species\")\n```\n\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table table-bordered table\" style=\"width: auto !important; margin-left: auto; margin-right: auto;\">\n<caption>Kullback-Leibler-Divergence between species</caption>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\">   </th>\n   <th style=\"text-align:left;\"> Beech </th>\n   <th style=\"text-align:left;\"> Oak </th>\n   <th style=\"text-align:left;\"> Pine </th>\n   <th style=\"text-align:left;\"> Spruce </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Beech </td>\n   <td style=\"text-align:left;\"> 0.000 </td>\n   <td style=\"text-align:left;\"> 0.194 </td>\n   <td style=\"text-align:left;\"> 0.082 </td>\n   <td style=\"text-align:left;\"> 0.89 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Oak </td>\n   <td style=\"text-align:left;\"> 0.183 </td>\n   <td style=\"text-align:left;\"> 0.000 </td>\n   <td style=\"text-align:left;\"> 0.063 </td>\n   <td style=\"text-align:left;\"> 0.67 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Pine </td>\n   <td style=\"text-align:left;\"> 0.084 </td>\n   <td style=\"text-align:left;\"> 0.069 </td>\n   <td style=\"text-align:left;\"> 0.000 </td>\n   <td style=\"text-align:left;\"> 0.86 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Spruce </td>\n   <td style=\"text-align:left;\"> 1.083 </td>\n   <td style=\"text-align:left;\"> 0.809 </td>\n   <td style=\"text-align:left;\"> 1.200 </td>\n   <td style=\"text-align:left;\"> 0.00 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncolMeans(kld_results_specie, na.rm = TRUE) |> mean()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.3862841\n```\n:::\n:::\n\n::: {#tbl-nearest-neighbor-100-kld-beech .cell tbl-cap='Kullback-Leibler-Divergence between the researched areas which have the dominante specie beech for the atrribute nearest-neighbor-100'}\n\n```{.r .cell-code  code-fold=\"true\"}\nspecie <- data[data$specie==\"beech\",]\nkld_results_beech <- lfa::lfa_run_test_asymmetric(specie,value_column,\"area\",lfa::lfa_kld_from_vec)\nlfa::lfa_generate_result_table_tests(kld_results_beech,\"Kullback-Leibler-Divergence between areas with beech\")\n```\n\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table table-bordered table\" style=\"width: auto !important; margin-left: auto; margin-right: auto;\">\n<caption>Kullback-Leibler-Divergence between areas with beech</caption>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\">   </th>\n   <th style=\"text-align:left;\"> Bielefeld_brackwede </th>\n   <th style=\"text-align:left;\"> Billerbeck </th>\n   <th style=\"text-align:left;\"> Wuelfenrath </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Bielefeld_brackwede </td>\n   <td style=\"text-align:left;\"> 0.00 </td>\n   <td style=\"text-align:left;\"> 0.12 </td>\n   <td style=\"text-align:left;\"> 0.12 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Billerbeck </td>\n   <td style=\"text-align:left;\"> 0.14 </td>\n   <td style=\"text-align:left;\"> 0.00 </td>\n   <td style=\"text-align:left;\"> 0.40 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Wuelfenrath </td>\n   <td style=\"text-align:left;\"> 0.12 </td>\n   <td style=\"text-align:left;\"> 0.31 </td>\n   <td style=\"text-align:left;\"> 0.00 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncolMeans(kld_results_beech, na.rm = TRUE) |> mean()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.1338066\n```\n:::\n:::\n\n::: {#tbl-nearest-neighbor-100-kld-oak .cell tbl-cap='Kullback-Leibler-Divergence between the researched areas which have the dominante specie oak for the atrribute nearest-neighbor-100'}\n\n```{.r .cell-code  code-fold=\"true\"}\nspecie <- data[data$specie==\"oak\",]\nkld_results_oak <- lfa::lfa_run_test_asymmetric(specie,value_column,\"area\",lfa::lfa_kld_from_vec)\nlfa::lfa_generate_result_table_tests(kld_results_oak,\"Kullback-Leibler-Divergence between areas with oak\")\n```\n\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table table-bordered table\" style=\"width: auto !important; margin-left: auto; margin-right: auto;\">\n<caption>Kullback-Leibler-Divergence between areas with oak</caption>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\">   </th>\n   <th style=\"text-align:left;\"> Hamm </th>\n   <th style=\"text-align:left;\"> Muenster </th>\n   <th style=\"text-align:left;\"> Rinkerode </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Hamm </td>\n   <td style=\"text-align:left;\"> 0.00 </td>\n   <td style=\"text-align:left;\"> 0.19 </td>\n   <td style=\"text-align:left;\"> 0.11 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Muenster </td>\n   <td style=\"text-align:left;\"> 0.20 </td>\n   <td style=\"text-align:left;\"> 0.00 </td>\n   <td style=\"text-align:left;\"> 0.06 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Rinkerode </td>\n   <td style=\"text-align:left;\"> 0.11 </td>\n   <td style=\"text-align:left;\"> 0.07 </td>\n   <td style=\"text-align:left;\"> 0.00 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncolMeans(kld_results_oak, na.rm = TRUE) |> mean()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.08182597\n```\n:::\n:::\n\n::: {#tbl-nearest-neighbor-100-kld-pine .cell tbl-cap='Kullback-Leibler-Divergence between the researched areas which have the dominante specie pine for the atrribute nearest-neighbor-100'}\n\n```{.r .cell-code  code-fold=\"true\"}\nspecie <- data[data$specie==\"pine\",]\nkld_results_pine <- lfa::lfa_run_test_asymmetric(specie,value_column,\"area\",lfa::lfa_kld_from_vec)\nlfa::lfa_generate_result_table_tests(kld_results_pine,\"Kullback-Leibler-Divergence between areas with pine\")\n```\n\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table table-bordered table\" style=\"width: auto !important; margin-left: auto; margin-right: auto;\">\n<caption>Kullback-Leibler-Divergence between areas with pine</caption>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\">   </th>\n   <th style=\"text-align:left;\"> Greffen </th>\n   <th style=\"text-align:left;\"> Mesum </th>\n   <th style=\"text-align:left;\"> Telgte </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Greffen </td>\n   <td style=\"text-align:left;\"> 0.00 </td>\n   <td style=\"text-align:left;\"> 0.25 </td>\n   <td style=\"text-align:left;\"> 0.51 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Mesum </td>\n   <td style=\"text-align:left;\"> 0.20 </td>\n   <td style=\"text-align:left;\"> 0.00 </td>\n   <td style=\"text-align:left;\"> 0.25 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Telgte </td>\n   <td style=\"text-align:left;\"> 0.54 </td>\n   <td style=\"text-align:left;\"> 0.26 </td>\n   <td style=\"text-align:left;\"> 0.00 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncolMeans(kld_results_pine, na.rm = TRUE) |> mean()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.22229\n```\n:::\n:::\n\n::: {#tbl-nearest-neighbor-100-kld-spruce .cell tbl-cap='Kullback-Leibler-Divergence between the researched areas which have the dominante specie spruce for the atrribute nearest-neighbor-100'}\n\n```{.r .cell-code  code-fold=\"true\"}\nspecie <- data[data$specie==\"spruce\",]\nkld_results_spruce <- lfa::lfa_run_test_asymmetric(specie,value_column,\"area\",lfa::lfa_kld_from_vec)\nlfa::lfa_generate_result_table_tests(kld_results_spruce,\"Kullback-Leibler-Divergence between areas with spruce\")\n```\n\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table table-bordered table\" style=\"width: auto !important; margin-left: auto; margin-right: auto;\">\n<caption>Kullback-Leibler-Divergence between areas with spruce</caption>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\">   </th>\n   <th style=\"text-align:left;\"> Brilon </th>\n   <th style=\"text-align:left;\"> Oberhundem </th>\n   <th style=\"text-align:left;\"> Osterwald </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Brilon </td>\n   <td style=\"text-align:left;\"> 0.000 </td>\n   <td style=\"text-align:left;\"> 0.05 </td>\n   <td style=\"text-align:left;\"> 0.23 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Oberhundem </td>\n   <td style=\"text-align:left;\"> 0.046 </td>\n   <td style=\"text-align:left;\"> 0.00 </td>\n   <td style=\"text-align:left;\"> 0.37 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Osterwald </td>\n   <td style=\"text-align:left;\"> 0.276 </td>\n   <td style=\"text-align:left;\"> 0.46 </td>\n   <td style=\"text-align:left;\"> 0.00 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncolMeans(kld_results_spruce, na.rm = TRUE) |> mean()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.1591879\n```\n:::\n:::\n\n\n\n\n\n##### Jensen-Shannon Divergence\n\n\n\n\n::: {#tbl-nearest-neighbor-100-jsd_specie .cell tbl-cap='Jensen-Shannon Divergence between the researched species Beech, Oak, Pine and Spruce for the atrribute nearest-neighbor-100'}\n\n```{.r .cell-code  code-fold=\"true\"}\njsd_results_specie <- lfa::lfa_run_test_symmetric(data,value_column,\"specie\",lfa::lfa_jsd_from_vec)\nlfa::lfa_generate_result_table_tests(jsd_results_specie,\"Jensen-Shannon Divergence between species\")\n```\n\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table table-bordered table\" style=\"width: auto !important; margin-left: auto; margin-right: auto;\">\n<caption>Jensen-Shannon Divergence between species</caption>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\">   </th>\n   <th style=\"text-align:left;\"> Beech </th>\n   <th style=\"text-align:left;\"> Oak </th>\n   <th style=\"text-align:left;\"> Pine </th>\n   <th style=\"text-align:left;\"> Spruce </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Beech </td>\n   <td style=\"text-align:left;\"> 0 </td>\n   <td style=\"text-align:left;\"> 0.38 </td>\n   <td style=\"text-align:left;\"> 0.14 </td>\n   <td style=\"text-align:left;\"> 1.27 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Oak </td>\n   <td style=\"text-align:left;\"> NA </td>\n   <td style=\"text-align:left;\"> 0.00 </td>\n   <td style=\"text-align:left;\"> 0.30 </td>\n   <td style=\"text-align:left;\"> 0.78 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Pine </td>\n   <td style=\"text-align:left;\"> NA </td>\n   <td style=\"text-align:left;\"> NA </td>\n   <td style=\"text-align:left;\"> 0.00 </td>\n   <td style=\"text-align:left;\"> 1.39 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Spruce </td>\n   <td style=\"text-align:left;\"> NA </td>\n   <td style=\"text-align:left;\"> NA </td>\n   <td style=\"text-align:left;\"> NA </td>\n   <td style=\"text-align:left;\"> 0.00 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncolMeans(jsd_results_specie, na.rm = TRUE) |> mean()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.2997233\n```\n:::\n:::\n\n::: {#tbl-nearest-neighbor-100-jsd-beech .cell tbl-cap='Jensen-Shannon Divergence between the researched areas which have the dominante specie beech for the atrribute nearest-neighbor-100'}\n\n```{.r .cell-code  code-fold=\"true\"}\nspecie <- data[data$specie==\"beech\",]\njsd_results_beech <- lfa::lfa_run_test_symmetric(specie,value_column,\"area\",lfa::lfa_jsd_from_vec)\nlfa::lfa_generate_result_table_tests(jsd_results_beech,\"Jensen-Shannon Divergence between areas with beech\")\n```\n\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table table-bordered table\" style=\"width: auto !important; margin-left: auto; margin-right: auto;\">\n<caption>Jensen-Shannon Divergence between areas with beech</caption>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\">   </th>\n   <th style=\"text-align:left;\"> Bielefeld_brackwede </th>\n   <th style=\"text-align:left;\"> Billerbeck </th>\n   <th style=\"text-align:left;\"> Wuelfenrath </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Bielefeld_brackwede </td>\n   <td style=\"text-align:left;\"> 0 </td>\n   <td style=\"text-align:left;\"> 0.22 </td>\n   <td style=\"text-align:left;\"> 0.21 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Billerbeck </td>\n   <td style=\"text-align:left;\"> NA </td>\n   <td style=\"text-align:left;\"> 0.00 </td>\n   <td style=\"text-align:left;\"> 0.57 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Wuelfenrath </td>\n   <td style=\"text-align:left;\"> NA </td>\n   <td style=\"text-align:left;\"> NA </td>\n   <td style=\"text-align:left;\"> 0.00 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncolMeans(jsd_results_beech, na.rm = TRUE) |> mean()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.124106\n```\n:::\n:::\n\n::: {#tbl-nearest-neighbor-100-jsd-oak .cell tbl-cap='Jensen-Shannon Divergence between the researched areas which have the dominante specie oak for the atrribute nearest-neighbor-100'}\n\n```{.r .cell-code  code-fold=\"true\"}\nspecie <- data[data$specie==\"oak\",]\njsd_results_oak <- lfa::lfa_run_test_symmetric(specie,value_column,\"area\",lfa::lfa_jsd_from_vec)\nlfa::lfa_generate_result_table_tests(jsd_results_oak,\"Jensen-Shannon Divergence between areas with oak\")\n```\n\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table table-bordered table\" style=\"width: auto !important; margin-left: auto; margin-right: auto;\">\n<caption>Jensen-Shannon Divergence between areas with oak</caption>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\">   </th>\n   <th style=\"text-align:left;\"> Hamm </th>\n   <th style=\"text-align:left;\"> Muenster </th>\n   <th style=\"text-align:left;\"> Rinkerode </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Hamm </td>\n   <td style=\"text-align:left;\"> 0 </td>\n   <td style=\"text-align:left;\"> 0.34 </td>\n   <td style=\"text-align:left;\"> 0.17 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Muenster </td>\n   <td style=\"text-align:left;\"> NA </td>\n   <td style=\"text-align:left;\"> 0.00 </td>\n   <td style=\"text-align:left;\"> 0.23 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Rinkerode </td>\n   <td style=\"text-align:left;\"> NA </td>\n   <td style=\"text-align:left;\"> NA </td>\n   <td style=\"text-align:left;\"> 0.00 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncolMeans(jsd_results_oak, na.rm = TRUE) |> mean()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.1007612\n```\n:::\n:::\n\n::: {#tbl-nearest-neighbor-100-jsd-pine .cell tbl-cap='Jensen-Shannon Divergence between the researched areas which have the dominante specie pine for the atrribute nearest-neighbor-100'}\n\n```{.r .cell-code  code-fold=\"true\"}\nspecie <- data[data$specie==\"pine\",]\njsd_results_pine <- lfa::lfa_run_test_symmetric(specie,value_column,\"area\",lfa::lfa_jsd_from_vec)\nlfa::lfa_generate_result_table_tests(jsd_results_pine,\"Jensen-Shannon Divergence between areas with pine\")\n```\n\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table table-bordered table\" style=\"width: auto !important; margin-left: auto; margin-right: auto;\">\n<caption>Jensen-Shannon Divergence between areas with pine</caption>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\">   </th>\n   <th style=\"text-align:left;\"> Greffen </th>\n   <th style=\"text-align:left;\"> Mesum </th>\n   <th style=\"text-align:left;\"> Telgte </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Greffen </td>\n   <td style=\"text-align:left;\"> 0 </td>\n   <td style=\"text-align:left;\"> 0.45 </td>\n   <td style=\"text-align:left;\"> 0.86 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Mesum </td>\n   <td style=\"text-align:left;\"> NA </td>\n   <td style=\"text-align:left;\"> 0.00 </td>\n   <td style=\"text-align:left;\"> 0.50 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Telgte </td>\n   <td style=\"text-align:left;\"> NA </td>\n   <td style=\"text-align:left;\"> NA </td>\n   <td style=\"text-align:left;\"> 0.00 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncolMeans(jsd_results_pine, na.rm = TRUE) |> mean()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.2265055\n```\n:::\n:::\n\n::: {#tbl-nearest-neighbor-100-jsd-spruce .cell tbl-cap='Jensen-Shannon Divergence between the researched areas which have the dominante specie spruce for the atrribute nearest-neighbor-100'}\n\n```{.r .cell-code  code-fold=\"true\"}\nspecie <- data[data$specie==\"spruce\",]\njsd_results_spruce <- lfa::lfa_run_test_symmetric(specie,value_column,\"area\",lfa::lfa_jsd_from_vec)\nlfa::lfa_generate_result_table_tests(jsd_results_spruce,\"Jensen-Shannon Divergence between areas with spruce\")\n```\n\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table table-bordered table\" style=\"width: auto !important; margin-left: auto; margin-right: auto;\">\n<caption>Jensen-Shannon Divergence between areas with spruce</caption>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\">   </th>\n   <th style=\"text-align:left;\"> Brilon </th>\n   <th style=\"text-align:left;\"> Oberhundem </th>\n   <th style=\"text-align:left;\"> Osterwald </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Brilon </td>\n   <td style=\"text-align:left;\"> 0 </td>\n   <td style=\"text-align:left;\"> 0.1 </td>\n   <td style=\"text-align:left;\"> 0.57 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Oberhundem </td>\n   <td style=\"text-align:left;\"> NA </td>\n   <td style=\"text-align:left;\"> 0.0 </td>\n   <td style=\"text-align:left;\"> 0.73 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Osterwald </td>\n   <td style=\"text-align:left;\"> NA </td>\n   <td style=\"text-align:left;\"> NA </td>\n   <td style=\"text-align:left;\"> 0.00 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncolMeans(jsd_results_spruce, na.rm = TRUE) |> mean()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.1613747\n```\n:::\n:::\n\n\n\n#### Distribution of average nearest neighbor distances\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\ndata <- lfa::lfa_combine_sf_obj(lfa::lfa_get_neighbor_paths(),lfa::lfa_get_all_areas())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nReading layer `neighbours' from data source \n  `/home/jakob/gi-master/project-courses/lidar-forest-analysis/src/data/beech/bielefeld_brackwede/neighbours.gpkg' \n  using driver `GPKG'\nSimple feature collection with 1443 features and 102 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 466999.8 ymin: 5759839 xmax: 467617.1 ymax: 5760261\nProjected CRS: ETRS89 / UTM zone 32N\nReading layer `neighbours' from data source \n  `/home/jakob/gi-master/project-courses/lidar-forest-analysis/src/data/beech/billerbeck/neighbours.gpkg' \n  using driver `GPKG'\nSimple feature collection with 1732 features and 102 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 384890.8 ymin: 5761918 xmax: 385590.9 ymax: 5762478\nProjected CRS: ETRS89 / UTM zone 32N\nReading layer `neighbours' from data source \n  `/home/jakob/gi-master/project-courses/lidar-forest-analysis/src/data/beech/wuelfenrath/neighbours.gpkg' \n  using driver `GPKG'\nSimple feature collection with 2779 features and 102 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 365546.3 ymin: 5683711 xmax: 366356.1 ymax: 5684321\nProjected CRS: ETRS89 / UTM zone 32N\nReading layer `neighbours' from data source \n  `/home/jakob/gi-master/project-courses/lidar-forest-analysis/src/data/oak/hamm/neighbours.gpkg' \n  using driver `GPKG'\nSimple feature collection with 2441 features and 102 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 420953.3 ymin: 5723884 xmax: 421596 ymax: 5724609\nProjected CRS: ETRS89 / UTM zone 32N\nReading layer `neighbours' from data source \n  `/home/jakob/gi-master/project-courses/lidar-forest-analysis/src/data/oak/muenster/neighbours.gpkg' \n  using driver `GPKG'\nSimple feature collection with 1270 features and 102 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 404615.6 ymin: 5752535 xmax: 405396.8 ymax: 5752971\nProjected CRS: ETRS89 / UTM zone 32N\nReading layer `neighbours' from data source \n  `/home/jakob/gi-master/project-courses/lidar-forest-analysis/src/data/oak/rinkerode/neighbours.gpkg' \n  using driver `GPKG'\nSimple feature collection with 1643 features and 102 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 408428.2 ymin: 5746021 xmax: 409014.8 ymax: 5746511\nProjected CRS: ETRS89 / UTM zone 32N\nReading layer `neighbours' from data source \n  `/home/jakob/gi-master/project-courses/lidar-forest-analysis/src/data/pine/greffen/neighbours.gpkg' \n  using driver `GPKG'\nSimple feature collection with 513 features and 102 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 442816.1 ymin: 5760217 xmax: 443148.9 ymax: 5760567\nProjected CRS: ETRS89 / UTM zone 32N\nReading layer `neighbours' from data source \n  `/home/jakob/gi-master/project-courses/lidar-forest-analysis/src/data/pine/mesum/neighbours.gpkg' \n  using driver `GPKG'\nSimple feature collection with 5031 features and 102 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 399930.6 ymin: 5790412 xmax: 400969.7 ymax: 5790950\nProjected CRS: ETRS89 / UTM zone 32N\nReading layer `neighbours' from data source \n  `/home/jakob/gi-master/project-courses/lidar-forest-analysis/src/data/pine/telgte/neighbours.gpkg' \n  using driver `GPKG'\nSimple feature collection with 3368 features and 102 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 416135.1 ymin: 5761663 xmax: 416697.1 ymax: 5762477\nProjected CRS: ETRS89 / UTM zone 32N\nReading layer `neighbours' from data source \n  `/home/jakob/gi-master/project-courses/lidar-forest-analysis/src/data/spruce/brilon/neighbours.gpkg' \n  using driver `GPKG'\nSimple feature collection with 3342 features and 102 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 467305.7 ymin: 5695055 xmax: 467996.9 ymax: 5695593\nProjected CRS: ETRS89 / UTM zone 32N\nReading layer `neighbours' from data source \n  `/home/jakob/gi-master/project-courses/lidar-forest-analysis/src/data/spruce/oberhundem/neighbours.gpkg' \n  using driver `GPKG'\nSimple feature collection with 2471 features and 102 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 442631.7 ymin: 5660096 xmax: 443309.5 ymax: 5660502\nProjected CRS: ETRS89 / UTM zone 32N\nReading layer `neighbours' from data source \n  `/home/jakob/gi-master/project-courses/lidar-forest-analysis/src/data/spruce/osterwald/neighbours.gpkg' \n  using driver `GPKG'\nSimple feature collection with 2806 features and 102 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 455822 ymin: 5673761 xmax: 456483.2 ymax: 5674162\nProjected CRS: ETRS89 / UTM zone 32N\n```\n:::\n\n```{.r .cell-code  code-fold=\"true\"}\nnames <- paste0(\"Neighbor_\",1:100)\ndata$avg = rowMeans(dplyr::select(as.data.frame(data),names))\nvalue_column <- \"avg\"\n```\n:::\n\n\n\n\n##### Kullback-Leibler-Divergence\n\n\n\n\n::: {#tbl-nearest-neighbor-avg-kld_specie .cell tbl-cap='Kullback-Leibler-Divergence between the researched species Beech, Oak, Pine and Spruce for the atrribute nearest-neighbor-avg'}\n\n```{.r .cell-code  code-fold=\"true\"}\nkld_results_specie <- lfa::lfa_run_test_asymmetric(data,value_column,\"specie\",lfa::lfa_kld_from_vec)\nlfa::lfa_generate_result_table_tests(kld_results_specie,\"Kullback-Leibler-Divergence between species\")\n```\n\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table table-bordered table\" style=\"width: auto !important; margin-left: auto; margin-right: auto;\">\n<caption>Kullback-Leibler-Divergence between species</caption>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\">   </th>\n   <th style=\"text-align:left;\"> Beech </th>\n   <th style=\"text-align:left;\"> Oak </th>\n   <th style=\"text-align:left;\"> Pine </th>\n   <th style=\"text-align:left;\"> Spruce </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Beech </td>\n   <td style=\"text-align:left;\"> 0.000 </td>\n   <td style=\"text-align:left;\"> 0.31 </td>\n   <td style=\"text-align:left;\"> 0.065 </td>\n   <td style=\"text-align:left;\"> 1.28 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Oak </td>\n   <td style=\"text-align:left;\"> 0.302 </td>\n   <td style=\"text-align:left;\"> 0.00 </td>\n   <td style=\"text-align:left;\"> 0.178 </td>\n   <td style=\"text-align:left;\"> 0.83 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Pine </td>\n   <td style=\"text-align:left;\"> 0.067 </td>\n   <td style=\"text-align:left;\"> 0.17 </td>\n   <td style=\"text-align:left;\"> 0.000 </td>\n   <td style=\"text-align:left;\"> 1.23 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Spruce </td>\n   <td style=\"text-align:left;\"> 1.660 </td>\n   <td style=\"text-align:left;\"> 0.92 </td>\n   <td style=\"text-align:left;\"> 1.869 </td>\n   <td style=\"text-align:left;\"> 0.00 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncolMeans(kld_results_specie, na.rm = TRUE) |> mean()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.5552882\n```\n:::\n:::\n\n::: {#tbl-nearest-neighbor-avg-kld-beech .cell tbl-cap='Kullback-Leibler-Divergence between the researched areas which have the dominante specie beech for the atrribute nearest-neighbor-avg'}\n\n```{.r .cell-code  code-fold=\"true\"}\nspecie <- data[data$specie==\"beech\",]\nkld_results_beech <- lfa::lfa_run_test_asymmetric(specie,value_column,\"area\",lfa::lfa_kld_from_vec)\nlfa::lfa_generate_result_table_tests(kld_results_beech,\"Kullback-Leibler-Divergence between areas with beech\")\n```\n\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table table-bordered table\" style=\"width: auto !important; margin-left: auto; margin-right: auto;\">\n<caption>Kullback-Leibler-Divergence between areas with beech</caption>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\">   </th>\n   <th style=\"text-align:left;\"> Bielefeld_brackwede </th>\n   <th style=\"text-align:left;\"> Billerbeck </th>\n   <th style=\"text-align:left;\"> Wuelfenrath </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Bielefeld_brackwede </td>\n   <td style=\"text-align:left;\"> 0.000 </td>\n   <td style=\"text-align:left;\"> 0.052 </td>\n   <td style=\"text-align:left;\"> 0.50 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Billerbeck </td>\n   <td style=\"text-align:left;\"> 0.052 </td>\n   <td style=\"text-align:left;\"> 0.000 </td>\n   <td style=\"text-align:left;\"> 0.91 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Wuelfenrath </td>\n   <td style=\"text-align:left;\"> 0.348 </td>\n   <td style=\"text-align:left;\"> 0.612 </td>\n   <td style=\"text-align:left;\"> 0.00 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncolMeans(kld_results_beech, na.rm = TRUE) |> mean()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.27574\n```\n:::\n:::\n\n::: {#tbl-nearest-neighbor-avg-kld-oak .cell tbl-cap='Kullback-Leibler-Divergence between the researched areas which have the dominante specie oak for the atrribute nearest-neighbor-avg'}\n\n```{.r .cell-code  code-fold=\"true\"}\nspecie <- data[data$specie==\"oak\",]\nkld_results_oak <- lfa::lfa_run_test_asymmetric(specie,value_column,\"area\",lfa::lfa_kld_from_vec)\nlfa::lfa_generate_result_table_tests(kld_results_oak,\"Kullback-Leibler-Divergence between areas with oak\")\n```\n\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table table-bordered table\" style=\"width: auto !important; margin-left: auto; margin-right: auto;\">\n<caption>Kullback-Leibler-Divergence between areas with oak</caption>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\">   </th>\n   <th style=\"text-align:left;\"> Hamm </th>\n   <th style=\"text-align:left;\"> Muenster </th>\n   <th style=\"text-align:left;\"> Rinkerode </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Hamm </td>\n   <td style=\"text-align:left;\"> 0.00 </td>\n   <td style=\"text-align:left;\"> 0.166 </td>\n   <td style=\"text-align:left;\"> 0.217 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Muenster </td>\n   <td style=\"text-align:left;\"> 0.16 </td>\n   <td style=\"text-align:left;\"> 0.000 </td>\n   <td style=\"text-align:left;\"> 0.031 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Rinkerode </td>\n   <td style=\"text-align:left;\"> 0.21 </td>\n   <td style=\"text-align:left;\"> 0.037 </td>\n   <td style=\"text-align:left;\"> 0.000 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncolMeans(kld_results_oak, na.rm = TRUE) |> mean()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.09154318\n```\n:::\n:::\n\n::: {#tbl-nearest-neighbor-avg-kld-pine .cell tbl-cap='Kullback-Leibler-Divergence between the researched areas which have the dominante specie pine for the atrribute nearest-neighbor-avg'}\n\n```{.r .cell-code  code-fold=\"true\"}\nspecie <- data[data$specie==\"pine\",]\nkld_results_pine <- lfa::lfa_run_test_asymmetric(specie,value_column,\"area\",lfa::lfa_kld_from_vec)\nlfa::lfa_generate_result_table_tests(kld_results_pine,\"Kullback-Leibler-Divergence between areas with pine\")\n```\n\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table table-bordered table\" style=\"width: auto !important; margin-left: auto; margin-right: auto;\">\n<caption>Kullback-Leibler-Divergence between areas with pine</caption>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\">   </th>\n   <th style=\"text-align:left;\"> Greffen </th>\n   <th style=\"text-align:left;\"> Mesum </th>\n   <th style=\"text-align:left;\"> Telgte </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Greffen </td>\n   <td style=\"text-align:left;\"> 0.00 </td>\n   <td style=\"text-align:left;\"> 0.17 </td>\n   <td style=\"text-align:left;\"> 0.29 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Mesum </td>\n   <td style=\"text-align:left;\"> 0.14 </td>\n   <td style=\"text-align:left;\"> 0.00 </td>\n   <td style=\"text-align:left;\"> 0.30 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Telgte </td>\n   <td style=\"text-align:left;\"> 0.26 </td>\n   <td style=\"text-align:left;\"> 0.32 </td>\n   <td style=\"text-align:left;\"> 0.00 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncolMeans(kld_results_pine, na.rm = TRUE) |> mean()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.1637513\n```\n:::\n:::\n\n::: {#tbl-nearest-neighbor-avg-kld-spruce .cell tbl-cap='Kullback-Leibler-Divergence between the researched areas which have the dominante specie spruce for the atrribute nearest-neighbor-avg'}\n\n```{.r .cell-code  code-fold=\"true\"}\nspecie <- data[data$specie==\"spruce\",]\nkld_results_spruce <- lfa::lfa_run_test_asymmetric(specie,value_column,\"area\",lfa::lfa_kld_from_vec)\nlfa::lfa_generate_result_table_tests(kld_results_spruce,\"Kullback-Leibler-Divergence between areas with spruce\")\n```\n\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table table-bordered table\" style=\"width: auto !important; margin-left: auto; margin-right: auto;\">\n<caption>Kullback-Leibler-Divergence between areas with spruce</caption>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\">   </th>\n   <th style=\"text-align:left;\"> Brilon </th>\n   <th style=\"text-align:left;\"> Oberhundem </th>\n   <th style=\"text-align:left;\"> Osterwald </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Brilon </td>\n   <td style=\"text-align:left;\"> 0.000 </td>\n   <td style=\"text-align:left;\"> 0.11 </td>\n   <td style=\"text-align:left;\"> 0.29 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Oberhundem </td>\n   <td style=\"text-align:left;\"> 0.097 </td>\n   <td style=\"text-align:left;\"> 0.00 </td>\n   <td style=\"text-align:left;\"> 0.59 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Osterwald </td>\n   <td style=\"text-align:left;\"> 0.341 </td>\n   <td style=\"text-align:left;\"> 0.75 </td>\n   <td style=\"text-align:left;\"> 0.00 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncolMeans(kld_results_spruce, na.rm = TRUE) |> mean()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.2404004\n```\n:::\n:::\n\n\n\n\n\n##### Jensen-Shannon Divergence\n\n\n\n\n::: {#tbl-nearest-neighbor-avg-jsd_specie .cell tbl-cap='Jensen-Shannon Divergence between the researched species Beech, Oak, Pine and Spruce for the atrribute nearest-neighbor-avg'}\n\n```{.r .cell-code  code-fold=\"true\"}\njsd_results_specie <- lfa::lfa_run_test_symmetric(data,value_column,\"specie\",lfa::lfa_jsd_from_vec)\nlfa::lfa_generate_result_table_tests(jsd_results_specie,\"Jensen-Shannon Divergence between species\")\n```\n\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table table-bordered table\" style=\"width: auto !important; margin-left: auto; margin-right: auto;\">\n<caption>Jensen-Shannon Divergence between species</caption>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\">   </th>\n   <th style=\"text-align:left;\"> Beech </th>\n   <th style=\"text-align:left;\"> Oak </th>\n   <th style=\"text-align:left;\"> Pine </th>\n   <th style=\"text-align:left;\"> Spruce </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Beech </td>\n   <td style=\"text-align:left;\"> 0 </td>\n   <td style=\"text-align:left;\"> 0.73 </td>\n   <td style=\"text-align:left;\"> 0.19 </td>\n   <td style=\"text-align:left;\"> 2.6 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Oak </td>\n   <td style=\"text-align:left;\"> NA </td>\n   <td style=\"text-align:left;\"> 0.00 </td>\n   <td style=\"text-align:left;\"> 0.64 </td>\n   <td style=\"text-align:left;\"> 1.4 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Pine </td>\n   <td style=\"text-align:left;\"> NA </td>\n   <td style=\"text-align:left;\"> NA </td>\n   <td style=\"text-align:left;\"> 0.00 </td>\n   <td style=\"text-align:left;\"> 3.0 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Spruce </td>\n   <td style=\"text-align:left;\"> NA </td>\n   <td style=\"text-align:left;\"> NA </td>\n   <td style=\"text-align:left;\"> NA </td>\n   <td style=\"text-align:left;\"> 0.0 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncolMeans(jsd_results_specie, na.rm = TRUE) |> mean()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.5999417\n```\n:::\n:::\n\n::: {#tbl-nearest-neighbor-avg-jsd-beech .cell tbl-cap='Jensen-Shannon Divergence between the researched areas which have the dominante specie beech for the atrribute nearest-neighbor-avg'}\n\n```{.r .cell-code  code-fold=\"true\"}\nspecie <- data[data$specie==\"beech\",]\njsd_results_beech <- lfa::lfa_run_test_symmetric(specie,value_column,\"area\",lfa::lfa_jsd_from_vec)\nlfa::lfa_generate_result_table_tests(jsd_results_beech,\"Jensen-Shannon Divergence between areas with beech\")\n```\n\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table table-bordered table\" style=\"width: auto !important; margin-left: auto; margin-right: auto;\">\n<caption>Jensen-Shannon Divergence between areas with beech</caption>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\">   </th>\n   <th style=\"text-align:left;\"> Bielefeld_brackwede </th>\n   <th style=\"text-align:left;\"> Billerbeck </th>\n   <th style=\"text-align:left;\"> Wuelfenrath </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Bielefeld_brackwede </td>\n   <td style=\"text-align:left;\"> 0 </td>\n   <td style=\"text-align:left;\"> 0.14 </td>\n   <td style=\"text-align:left;\"> 1.0 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Billerbeck </td>\n   <td style=\"text-align:left;\"> NA </td>\n   <td style=\"text-align:left;\"> 0.00 </td>\n   <td style=\"text-align:left;\"> 1.7 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Wuelfenrath </td>\n   <td style=\"text-align:left;\"> NA </td>\n   <td style=\"text-align:left;\"> NA </td>\n   <td style=\"text-align:left;\"> 0.0 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncolMeans(jsd_results_beech, na.rm = TRUE) |> mean()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.3215991\n```\n:::\n:::\n\n::: {#tbl-nearest-neighbor-avg-jsd-oak .cell tbl-cap='Jensen-Shannon Divergence between the researched areas which have the dominante specie oak for the atrribute nearest-neighbor-avg'}\n\n```{.r .cell-code  code-fold=\"true\"}\nspecie <- data[data$specie==\"oak\",]\njsd_results_oak <- lfa::lfa_run_test_symmetric(specie,value_column,\"area\",lfa::lfa_jsd_from_vec)\nlfa::lfa_generate_result_table_tests(jsd_results_oak,\"Jensen-Shannon Divergence between areas with oak\")\n```\n\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table table-bordered table\" style=\"width: auto !important; margin-left: auto; margin-right: auto;\">\n<caption>Jensen-Shannon Divergence between areas with oak</caption>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\">   </th>\n   <th style=\"text-align:left;\"> Hamm </th>\n   <th style=\"text-align:left;\"> Muenster </th>\n   <th style=\"text-align:left;\"> Rinkerode </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Hamm </td>\n   <td style=\"text-align:left;\"> 0 </td>\n   <td style=\"text-align:left;\"> 0.41 </td>\n   <td style=\"text-align:left;\"> 0.53 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Muenster </td>\n   <td style=\"text-align:left;\"> NA </td>\n   <td style=\"text-align:left;\"> 0.00 </td>\n   <td style=\"text-align:left;\"> 0.26 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Rinkerode </td>\n   <td style=\"text-align:left;\"> NA </td>\n   <td style=\"text-align:left;\"> NA </td>\n   <td style=\"text-align:left;\"> 0.00 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncolMeans(jsd_results_oak, na.rm = TRUE) |> mean()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.1558436\n```\n:::\n:::\n\n::: {#tbl-nearest-neighbor-avg-jsd-pine .cell tbl-cap='Jensen-Shannon Divergence between the researched areas which have the dominante specie pine for the atrribute nearest-neighbor-avg'}\n\n```{.r .cell-code  code-fold=\"true\"}\nspecie <- data[data$specie==\"pine\",]\njsd_results_pine <- lfa::lfa_run_test_symmetric(specie,value_column,\"area\",lfa::lfa_jsd_from_vec)\nlfa::lfa_generate_result_table_tests(jsd_results_pine,\"Jensen-Shannon Divergence between areas with pine\")\n```\n\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table table-bordered table\" style=\"width: auto !important; margin-left: auto; margin-right: auto;\">\n<caption>Jensen-Shannon Divergence between areas with pine</caption>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\">   </th>\n   <th style=\"text-align:left;\"> Greffen </th>\n   <th style=\"text-align:left;\"> Mesum </th>\n   <th style=\"text-align:left;\"> Telgte </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Greffen </td>\n   <td style=\"text-align:left;\"> 0 </td>\n   <td style=\"text-align:left;\"> 0.44 </td>\n   <td style=\"text-align:left;\"> 0.76 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Mesum </td>\n   <td style=\"text-align:left;\"> NA </td>\n   <td style=\"text-align:left;\"> 0.00 </td>\n   <td style=\"text-align:left;\"> 0.89 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Telgte </td>\n   <td style=\"text-align:left;\"> NA </td>\n   <td style=\"text-align:left;\"> NA </td>\n   <td style=\"text-align:left;\"> 0.00 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncolMeans(jsd_results_pine, na.rm = TRUE) |> mean()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.2560143\n```\n:::\n:::\n\n::: {#tbl-nearest-neighbor-avg-jsd-spruce .cell tbl-cap='Jensen-Shannon Divergence between the researched areas which have the dominante specie spruce for the atrribute nearest-neighbor-avg'}\n\n```{.r .cell-code  code-fold=\"true\"}\nspecie <- data[data$specie==\"spruce\",]\njsd_results_spruce <- lfa::lfa_run_test_symmetric(specie,value_column,\"area\",lfa::lfa_jsd_from_vec)\nlfa::lfa_generate_result_table_tests(jsd_results_spruce,\"Jensen-Shannon Divergence between areas with spruce\")\n```\n\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table table-bordered table\" style=\"width: auto !important; margin-left: auto; margin-right: auto;\">\n<caption>Jensen-Shannon Divergence between areas with spruce</caption>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\">   </th>\n   <th style=\"text-align:left;\"> Brilon </th>\n   <th style=\"text-align:left;\"> Oberhundem </th>\n   <th style=\"text-align:left;\"> Osterwald </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Brilon </td>\n   <td style=\"text-align:left;\"> 0 </td>\n   <td style=\"text-align:left;\"> 0.32 </td>\n   <td style=\"text-align:left;\"> 1.1 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Oberhundem </td>\n   <td style=\"text-align:left;\"> NA </td>\n   <td style=\"text-align:left;\"> 0.00 </td>\n   <td style=\"text-align:left;\"> 1.8 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Osterwald </td>\n   <td style=\"text-align:left;\"> NA </td>\n   <td style=\"text-align:left;\"> NA </td>\n   <td style=\"text-align:left;\"> 0.0 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncolMeans(jsd_results_spruce, na.rm = TRUE) |> mean()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.3713411\n```\n:::\n:::\n\n\n\n### Distribution of the number of returns\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\ndata <- sf::st_read(\"data/tree_properties.gpkg\")\nneighbors <- lfa::lfa_get_neighbor_paths() |> lfa::lfa_combine_sf_obj(lfa::lfa_get_all_areas())\ndata = sf::st_join(data,neighbors, join = sf::st_within)\nvalue_column <- \"number_of_returns\"\n```\n:::\n\n\n\n\n#### Kullback-Leibler-Divergence\n\n\n\n\n::: {#tbl-number-of-returns-kld_specie .cell tbl-cap='Kullback-Leibler-Divergence between the researched species Beech, Oak, Pine and Spruce for the atrribute number-of-returns'}\n\n```{.r .cell-code  code-fold=\"true\"}\nkld_results_specie <- lfa::lfa_run_test_asymmetric(data,value_column,\"specie\",lfa::lfa_kld_from_vec)\nlfa::lfa_generate_result_table_tests(kld_results_specie,\"Kullback-Leibler-Divergence between species\")\n```\n\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table table-bordered table\" style=\"width: auto !important; margin-left: auto; margin-right: auto;\">\n<caption>Kullback-Leibler-Divergence between species</caption>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\">   </th>\n   <th style=\"text-align:left;\"> Beech </th>\n   <th style=\"text-align:left;\"> Oak </th>\n   <th style=\"text-align:left;\"> Pine </th>\n   <th style=\"text-align:left;\"> Spruce </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Beech </td>\n   <td style=\"text-align:left;\"> 0.000 </td>\n   <td style=\"text-align:left;\"> 0.083 </td>\n   <td style=\"text-align:left;\"> 0.57 </td>\n   <td style=\"text-align:left;\"> 0.049 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Oak </td>\n   <td style=\"text-align:left;\"> 0.051 </td>\n   <td style=\"text-align:left;\"> 0.000 </td>\n   <td style=\"text-align:left;\"> 0.84 </td>\n   <td style=\"text-align:left;\"> 0.059 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Pine </td>\n   <td style=\"text-align:left;\"> 0.432 </td>\n   <td style=\"text-align:left;\"> 0.833 </td>\n   <td style=\"text-align:left;\"> 0.00 </td>\n   <td style=\"text-align:left;\"> 0.526 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Spruce </td>\n   <td style=\"text-align:left;\"> 0.036 </td>\n   <td style=\"text-align:left;\"> 0.059 </td>\n   <td style=\"text-align:left;\"> 0.54 </td>\n   <td style=\"text-align:left;\"> 0.000 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncolMeans(kld_results_specie, na.rm = TRUE) |> mean()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.2550987\n```\n:::\n:::\n\n::: {#tbl-number-of-returns-kld-beech .cell tbl-cap='Kullback-Leibler-Divergence between the researched areas which have the dominante specie beech for the atrribute number-of-returns'}\n\n```{.r .cell-code  code-fold=\"true\"}\nspecie <- data[data$specie==\"beech\",]\nkld_results_beech <- lfa::lfa_run_test_asymmetric(specie,value_column,\"area\",lfa::lfa_kld_from_vec)\nlfa::lfa_generate_result_table_tests(kld_results_beech,\"Kullback-Leibler-Divergence between areas with beech\")\n```\n\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table table-bordered table\" style=\"width: auto !important; margin-left: auto; margin-right: auto;\">\n<caption>Kullback-Leibler-Divergence between areas with beech</caption>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\">   </th>\n   <th style=\"text-align:left;\"> Bielefeld_brackwede </th>\n   <th style=\"text-align:left;\"> Billerbeck </th>\n   <th style=\"text-align:left;\"> Wuelfenrath </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Bielefeld_brackwede </td>\n   <td style=\"text-align:left;\"> 0.00 </td>\n   <td style=\"text-align:left;\"> 0.15 </td>\n   <td style=\"text-align:left;\"> 0.082 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Billerbeck </td>\n   <td style=\"text-align:left;\"> 0.21 </td>\n   <td style=\"text-align:left;\"> 0.00 </td>\n   <td style=\"text-align:left;\"> 0.136 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Wuelfenrath </td>\n   <td style=\"text-align:left;\"> 0.13 </td>\n   <td style=\"text-align:left;\"> 0.19 </td>\n   <td style=\"text-align:left;\"> 0.000 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncolMeans(kld_results_beech, na.rm = TRUE) |> mean()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.09985223\n```\n:::\n:::\n\n::: {#tbl-number-of-returns-kld-oak .cell tbl-cap='Kullback-Leibler-Divergence between the researched areas which have the dominante specie oak for the atrribute number-of-returns'}\n\n```{.r .cell-code  code-fold=\"true\"}\nspecie <- data[data$specie==\"oak\",]\nkld_results_oak <- lfa::lfa_run_test_asymmetric(specie,value_column,\"area\",lfa::lfa_kld_from_vec)\nlfa::lfa_generate_result_table_tests(kld_results_oak,\"Kullback-Leibler-Divergence between areas with oak\")\n```\n\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table table-bordered table\" style=\"width: auto !important; margin-left: auto; margin-right: auto;\">\n<caption>Kullback-Leibler-Divergence between areas with oak</caption>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\">   </th>\n   <th style=\"text-align:left;\"> Hamm </th>\n   <th style=\"text-align:left;\"> Muenster </th>\n   <th style=\"text-align:left;\"> Rinkerode </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Hamm </td>\n   <td style=\"text-align:left;\"> 0.00 </td>\n   <td style=\"text-align:left;\"> 0.46 </td>\n   <td style=\"text-align:left;\"> 0.846 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Muenster </td>\n   <td style=\"text-align:left;\"> 0.41 </td>\n   <td style=\"text-align:left;\"> 0.00 </td>\n   <td style=\"text-align:left;\"> 0.077 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Rinkerode </td>\n   <td style=\"text-align:left;\"> 0.81 </td>\n   <td style=\"text-align:left;\"> 0.09 </td>\n   <td style=\"text-align:left;\"> 0.000 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncolMeans(kld_results_oak, na.rm = TRUE) |> mean()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.2994815\n```\n:::\n:::\n\n::: {#tbl-number-of-returns-kld-pine .cell tbl-cap='Kullback-Leibler-Divergence between the researched areas which have the dominante specie pine for the atrribute number-of-returns'}\n\n```{.r .cell-code  code-fold=\"true\"}\nspecie <- data[data$specie==\"pine\",]\nkld_results_pine <- lfa::lfa_run_test_asymmetric(specie,value_column,\"area\",lfa::lfa_kld_from_vec)\nlfa::lfa_generate_result_table_tests(kld_results_pine,\"Kullback-Leibler-Divergence between areas with pine\")\n```\n\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table table-bordered table\" style=\"width: auto !important; margin-left: auto; margin-right: auto;\">\n<caption>Kullback-Leibler-Divergence between areas with pine</caption>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\">   </th>\n   <th style=\"text-align:left;\"> Greffen </th>\n   <th style=\"text-align:left;\"> Mesum </th>\n   <th style=\"text-align:left;\"> Telgte </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Greffen </td>\n   <td style=\"text-align:left;\"> 0.00 </td>\n   <td style=\"text-align:left;\"> 0.1444 </td>\n   <td style=\"text-align:left;\"> 0.1773 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Mesum </td>\n   <td style=\"text-align:left;\"> 0.14 </td>\n   <td style=\"text-align:left;\"> 0.0000 </td>\n   <td style=\"text-align:left;\"> 0.0047 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Telgte </td>\n   <td style=\"text-align:left;\"> 0.16 </td>\n   <td style=\"text-align:left;\"> 0.0045 </td>\n   <td style=\"text-align:left;\"> 0.0000 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncolMeans(kld_results_pine, na.rm = TRUE) |> mean()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.07005788\n```\n:::\n:::\n\n::: {#tbl-number-of-returns-kld-spruce .cell tbl-cap='Kullback-Leibler-Divergence between the researched areas which have the dominante specie spruce for the atrribute number-of-returns'}\n\n```{.r .cell-code  code-fold=\"true\"}\nspecie <- data[data$specie==\"spruce\",]\nkld_results_spruce <- lfa::lfa_run_test_asymmetric(specie,value_column,\"area\",lfa::lfa_kld_from_vec)\nlfa::lfa_generate_result_table_tests(kld_results_spruce,\"Kullback-Leibler-Divergence between areas with spruce\")\n```\n\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table table-bordered table\" style=\"width: auto !important; margin-left: auto; margin-right: auto;\">\n<caption>Kullback-Leibler-Divergence between areas with spruce</caption>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\">   </th>\n   <th style=\"text-align:left;\"> Brilon </th>\n   <th style=\"text-align:left;\"> Oberhundem </th>\n   <th style=\"text-align:left;\"> Osterwald </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Brilon </td>\n   <td style=\"text-align:left;\"> 0.000 </td>\n   <td style=\"text-align:left;\"> 0.04 </td>\n   <td style=\"text-align:left;\"> 0.034 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Oberhundem </td>\n   <td style=\"text-align:left;\"> 0.041 </td>\n   <td style=\"text-align:left;\"> 0.00 </td>\n   <td style=\"text-align:left;\"> 0.079 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Osterwald </td>\n   <td style=\"text-align:left;\"> 0.045 </td>\n   <td style=\"text-align:left;\"> 0.10 </td>\n   <td style=\"text-align:left;\"> 0.000 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncolMeans(kld_results_spruce, na.rm = TRUE) |> mean()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.03779495\n```\n:::\n:::\n\n\n\n\n\n#### Jensen-Shannon Divergence\n\n\n\n\n::: {#tbl-number-of-returns-jsd_specie .cell tbl-cap='Jensen-Shannon Divergence between the researched species Beech, Oak, Pine and Spruce for the atrribute number-of-returns'}\n\n```{.r .cell-code  code-fold=\"true\"}\njsd_results_specie <- lfa::lfa_run_test_symmetric(data,value_column,\"specie\",lfa::lfa_jsd_from_vec)\nlfa::lfa_generate_result_table_tests(jsd_results_specie,\"Jensen-Shannon Divergence between species\")\n```\n\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table table-bordered table\" style=\"width: auto !important; margin-left: auto; margin-right: auto;\">\n<caption>Jensen-Shannon Divergence between species</caption>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\">   </th>\n   <th style=\"text-align:left;\"> Beech </th>\n   <th style=\"text-align:left;\"> Oak </th>\n   <th style=\"text-align:left;\"> Pine </th>\n   <th style=\"text-align:left;\"> Spruce </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Beech </td>\n   <td style=\"text-align:left;\"> 0 </td>\n   <td style=\"text-align:left;\"> 3e-04 </td>\n   <td style=\"text-align:left;\"> 0.019 </td>\n   <td style=\"text-align:left;\"> 0.0014 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Oak </td>\n   <td style=\"text-align:left;\"> NA </td>\n   <td style=\"text-align:left;\"> 0e+00 </td>\n   <td style=\"text-align:left;\"> 0.021 </td>\n   <td style=\"text-align:left;\"> 0.0016 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Pine </td>\n   <td style=\"text-align:left;\"> NA </td>\n   <td style=\"text-align:left;\"> NA </td>\n   <td style=\"text-align:left;\"> 0.000 </td>\n   <td style=\"text-align:left;\"> 0.0143 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Spruce </td>\n   <td style=\"text-align:left;\"> NA </td>\n   <td style=\"text-align:left;\"> NA </td>\n   <td style=\"text-align:left;\"> NA </td>\n   <td style=\"text-align:left;\"> 0.0000 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncolMeans(jsd_results_specie, na.rm = TRUE) |> mean()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.004419638\n```\n:::\n:::\n\n::: {#tbl-number-of-returns-jsd-beech .cell tbl-cap='Jensen-Shannon Divergence between the researched areas which have the dominante specie beech for the atrribute number-of-returns'}\n\n```{.r .cell-code  code-fold=\"true\"}\nspecie <- data[data$specie==\"beech\",]\njsd_results_beech <- lfa::lfa_run_test_symmetric(specie,value_column,\"area\",lfa::lfa_jsd_from_vec)\nlfa::lfa_generate_result_table_tests(jsd_results_beech,\"Jensen-Shannon Divergence between areas with beech\")\n```\n\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table table-bordered table\" style=\"width: auto !important; margin-left: auto; margin-right: auto;\">\n<caption>Jensen-Shannon Divergence between areas with beech</caption>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\">   </th>\n   <th style=\"text-align:left;\"> Bielefeld_brackwede </th>\n   <th style=\"text-align:left;\"> Billerbeck </th>\n   <th style=\"text-align:left;\"> Wuelfenrath </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Bielefeld_brackwede </td>\n   <td style=\"text-align:left;\"> 0 </td>\n   <td style=\"text-align:left;\"> 0.0035 </td>\n   <td style=\"text-align:left;\"> 0.00099 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Billerbeck </td>\n   <td style=\"text-align:left;\"> NA </td>\n   <td style=\"text-align:left;\"> 0.0000 </td>\n   <td style=\"text-align:left;\"> 0.00554 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Wuelfenrath </td>\n   <td style=\"text-align:left;\"> NA </td>\n   <td style=\"text-align:left;\"> NA </td>\n   <td style=\"text-align:left;\"> 0.00000 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncolMeans(jsd_results_beech, na.rm = TRUE) |> mean()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.001314268\n```\n:::\n:::\n\n::: {#tbl-number-of-returns-jsd-oak .cell tbl-cap='Jensen-Shannon Divergence between the researched areas which have the dominante specie oak for the atrribute number-of-returns'}\n\n```{.r .cell-code  code-fold=\"true\"}\nspecie <- data[data$specie==\"oak\",]\njsd_results_oak <- lfa::lfa_run_test_symmetric(specie,value_column,\"area\",lfa::lfa_jsd_from_vec)\nlfa::lfa_generate_result_table_tests(jsd_results_oak,\"Jensen-Shannon Divergence between areas with oak\")\n```\n\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table table-bordered table\" style=\"width: auto !important; margin-left: auto; margin-right: auto;\">\n<caption>Jensen-Shannon Divergence between areas with oak</caption>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\">   </th>\n   <th style=\"text-align:left;\"> Hamm </th>\n   <th style=\"text-align:left;\"> Muenster </th>\n   <th style=\"text-align:left;\"> Rinkerode </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Hamm </td>\n   <td style=\"text-align:left;\"> 0 </td>\n   <td style=\"text-align:left;\"> 0.0068 </td>\n   <td style=\"text-align:left;\"> 0.0128 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Muenster </td>\n   <td style=\"text-align:left;\"> NA </td>\n   <td style=\"text-align:left;\"> 0.0000 </td>\n   <td style=\"text-align:left;\"> 0.0017 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Rinkerode </td>\n   <td style=\"text-align:left;\"> NA </td>\n   <td style=\"text-align:left;\"> NA </td>\n   <td style=\"text-align:left;\"> 0.0000 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncolMeans(jsd_results_oak, na.rm = TRUE) |> mean()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.002747351\n```\n:::\n:::\n\n::: {#tbl-number-of-returns-jsd-pine .cell tbl-cap='Jensen-Shannon Divergence between the researched areas which have the dominante specie pine for the atrribute number-of-returns'}\n\n```{.r .cell-code  code-fold=\"true\"}\nspecie <- data[data$specie==\"pine\",]\njsd_results_pine <- lfa::lfa_run_test_symmetric(specie,value_column,\"area\",lfa::lfa_jsd_from_vec)\nlfa::lfa_generate_result_table_tests(jsd_results_pine,\"Jensen-Shannon Divergence between areas with pine\")\n```\n\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table table-bordered table\" style=\"width: auto !important; margin-left: auto; margin-right: auto;\">\n<caption>Jensen-Shannon Divergence between areas with pine</caption>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\">   </th>\n   <th style=\"text-align:left;\"> Greffen </th>\n   <th style=\"text-align:left;\"> Mesum </th>\n   <th style=\"text-align:left;\"> Telgte </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Greffen </td>\n   <td style=\"text-align:left;\"> 0 </td>\n   <td style=\"text-align:left;\"> 0.0035 </td>\n   <td style=\"text-align:left;\"> 0.00458 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Mesum </td>\n   <td style=\"text-align:left;\"> NA </td>\n   <td style=\"text-align:left;\"> 0.0000 </td>\n   <td style=\"text-align:left;\"> 0.00037 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Telgte </td>\n   <td style=\"text-align:left;\"> NA </td>\n   <td style=\"text-align:left;\"> NA </td>\n   <td style=\"text-align:left;\"> 0.00000 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncolMeans(jsd_results_pine, na.rm = TRUE) |> mean()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.001130537\n```\n:::\n:::\n\n::: {#tbl-number-of-returns-jsd-spruce .cell tbl-cap='Jensen-Shannon Divergence between the researched areas which have the dominante specie spruce for the atrribute number-of-returns'}\n\n```{.r .cell-code  code-fold=\"true\"}\nspecie <- data[data$specie==\"spruce\",]\njsd_results_spruce <- lfa::lfa_run_test_symmetric(specie,value_column,\"area\",lfa::lfa_jsd_from_vec)\nlfa::lfa_generate_result_table_tests(jsd_results_spruce,\"Jensen-Shannon Divergence between areas with spruce\")\n```\n\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table table-bordered table\" style=\"width: auto !important; margin-left: auto; margin-right: auto;\">\n<caption>Jensen-Shannon Divergence between areas with spruce</caption>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\">   </th>\n   <th style=\"text-align:left;\"> Brilon </th>\n   <th style=\"text-align:left;\"> Oberhundem </th>\n   <th style=\"text-align:left;\"> Osterwald </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Brilon </td>\n   <td style=\"text-align:left;\"> 0 </td>\n   <td style=\"text-align:left;\"> 0.0069 </td>\n   <td style=\"text-align:left;\"> 0.005 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Oberhundem </td>\n   <td style=\"text-align:left;\"> NA </td>\n   <td style=\"text-align:left;\"> 0.0000 </td>\n   <td style=\"text-align:left;\"> 0.002 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;\"> Osterwald </td>\n   <td style=\"text-align:left;\"> NA </td>\n   <td style=\"text-align:left;\"> NA </td>\n   <td style=\"text-align:left;\"> 0.000 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncolMeans(jsd_results_spruce, na.rm = TRUE) |> mean()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.001939104\n```\n:::\n:::\n\n\n\n\n\n\n## Documentation {#sec-documentation}\n### `lfa_calculate_patch_density`\n\nCalculate patch density for specified areas based on detection data\n\n\n#### Arguments\n\nArgument      |Description\n------------- |----------------\n`areas_location`     |     The file path to a shapefile containing spatial polygons representing the areas for which patch density needs to be calculated. Default is \"research_areas.shp\".\n`detections`     |     A data frame containing detection information, where each row represents a detection and includes the 'area' column specifying the corresponding area. Default is obtained using lfa_get_detections().\n\n\n#### Description\n\nThis function calculates patch density for specified areas using detection data.\n It reads the spatial polygons from a shapefile, computes the area size for each patch,\n counts the number of detections in each patch, and calculates the patch density.\n\n\n#### Value\n\nA data frame with patch density information for each specified area.\n Columns include 'name' (area name), 'geometry' (polygon geometry), 'area_size' (patch area size),\n 'detections' (number of detections in the patch), and 'density' (computed patch density).\n\n\n#### Examples\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Assuming you have a shapefile 'your_research_areas.shp' and detection data\n# from lfa_get_detections()\ndensity_data <- lfa_calculate_patch_density(areas_location = \"your_research_areas.shp\")\nprint(density_data)\n```\n:::\n\n\n\n#### Usage\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlfa_calculate_patch_density(\n  areas_location = \"research_areas.shp\",\n  detections = lfa::lfa_get_detections()\n)\n```\n:::\n\n\n\n\n### `lfa_calculate_rf_metrics`\n\nCalculate Precision and Recall Metrics for Random Forest Classification\n\n\n#### Arguments\n\nArgument      |Description\n------------- |----------------\n`conf_matrix`     |     Confusion matrix obtained from a Random Forest classification.\n\n\n#### Description\n\nThis function calculates precision and recall metrics for each class based on the provided confusion matrix from a Random Forest classification.\n\n\n#### Details\n\nThe function calculates precision and recall metrics for each class based on the confusion matrix obtained from a Random Forest classification.\n\n\n#### Seealso\n\n[`lfa_precision_per_class`](#lfaprecisionperclass) , [`lfa_recall_per_class`](#lfarecallperclass)\n\n\n#### Value\n\nA data frame containing precision and recall metrics for each class.\n\n\n#### Examples\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Example confusion matrix from a Random Forest classification\nrf_cm <- table(predicted = c(\"A\", \"B\", \"A\", \"B\"), actual = c(\"A\", \"A\", \"B\", \"B\"))\n# Calculate precision and recall metrics\nrf_metrics_df <- lfa_calculate_rf_metrics(rf_cm)\n```\n:::\n\n\n\n#### Usage\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlfa_calculate_rf_metrics(conf_matrix)\n```\n:::\n\n\n\n\n### `lfa_capitalize_first_char`\n\nCapitalize First Character of a String\n\n\n#### Arguments\n\nArgument      |Description\n------------- |----------------\n`input_string`     |     A single-character string to be processed.\n\n\n#### Concept\n\nString Manipulation\n\n\n#### Description\n\nThis function takes a string as input and returns the same string with the\n first character capitalized. If the first character is already capitalized,\n the function does nothing. If the first character is not from the alphabet,\n an error is thrown.\n\n\n#### Details\n\nThis function performs the following steps:\n  \n\n*  Checks if the input is a single-character string. \n\n*  Verifies if the first character is from the alphabet (A-Z or a-z). \n\n*  If the first character is not already capitalized, it capitalizes it. \n\n*  Returns the modified string.\n\n\n#### Keyword\n\nalphabet\n\n\n#### Note\n\nThis function is case-sensitive and assumes ASCII characters.\n\n\n#### References\n\nNone\n\n\n#### Seealso\n\nThis function is related to the basic string manipulation functions in base R.\n\n\n#### Value\n\nA modified string with the first character capitalized if it is\n not already. If the first character is already capitalized, the original\n string is returned.\n\n\n#### Examples\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Capitalize the first character of a string\ncapitalize_first_char(\"hello\") # Returns \"Hello\"\ncapitalize_first_char(\"World\") # Returns \"World\"\n\n# Error example (non-alphabetic first character)\ncapitalize_first_char(\"123abc\") # Throws an error\n```\n:::\n\n\n\n#### Usage\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlfa_capitalize_first_char(input_string)\n```\n:::\n\n\n\n\n### `lfa_check_flag`\n\nCheck if a flag is set, indicating the completion of a specific process.\n\n\n#### Arguments\n\nArgument      |Description\n------------- |----------------\n`flag_name`     |     A character string specifying the name of the flag file. It should be a descriptive and unique identifier for the process being checked.\n\n\n#### Description\n\nThis function checks for the existence of a hidden flag file at a specified location within the working directory. If the flag file is found, a message is printed, and the function returns `TRUE` to indicate that the associated processing step has already been completed. If the flag file is not found, the function returns `FALSE` , indicating that further processing can proceed.\n\n\n#### Value\n\nA logical value indicating whether the flag is set ( `TRUE` ) or not ( `FALSE` ).\n\n\n#### Examples\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Check if the flag for a process named \"data_processing\" is set\nlfa_check_flag(\"data_processing\")\n```\n:::\n\n\n\n#### Usage\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlfa_check_flag(flag_name)\n```\n:::\n\n\n\n\n### `lfa_chm`\n\nCreate Canopy Height Model (CHM) from Lidar Data\n\n\n#### Arguments\n\nArgument      |Description\n------------- |----------------\n`specie`     |     Character string indicating the species name.\n`area`     |     Character string indicating the specific area or location.\n`res`     |     Numeric value indicating the spatial resolution of the CHM. Default is 0.5.\n`save_to_file`     |     Logical. If TRUE, the generated CHM will be saved to a GeoTIFF file. Default is TRUE.\n`overwrite`     |     Logical. If TRUE, existing CHM file will be overwritten. Default is FALSE.\n`...`     |     Additional arguments to be passed to the underlying functions, such as lidR::catalog_map.\n\n\n#### Description\n\nThis function generates a Canopy Height Model (CHM) from Lidar data using the lidR package.\n\n\n#### Details\n\nThe behavior of the function with different input parameters is as follows:\n  \n\n*  When a CHM file already exists at the specified path and `overwrite` is FALSE, the function loads the existing CHM and returns it. \n\n*  If the CHM file does not exist or `overwrite` is TRUE, the function processes Lidar data using `lfa_rasterize_chunk` and creates a CHM. \n\n*  The spatial resolution of the CHM can be controlled with the `res` parameter. \n\n*  If `save_to_file` is TRUE, the generated CHM will be saved to a GeoTIFF file.\n\n\n#### Seealso\n\n[`lfa_read_area_as_catalog`](#lfareadareaascatalog) , [`catalog_map`](#catalogmap) , [`terra::rast`](#terra::rast) , [`terra::writeRaster`](#terra::writeraster)\n\n\n#### Value\n\nA raster layer representing the Canopy Height Model (CHM).\n\n\n#### Examples\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Generate CHM for a specific species and area\nchm <- lfa_chm(specie = \"ExampleSpecies\", area = \"ExampleArea\", res = 1.0)\n\n# Generate CHM and save it to a file\nchm <- lfa_chm(specie = \"ExampleSpecies\", area = \"ExampleArea\", res = 1.0, save_to_file = TRUE)\n```\n:::\n\n\n\n#### Usage\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlfa_chm(specie, area, res = 0.5, save_to_file = TRUE, overwrite = FALSE, ...)\n```\n:::\n\n\n\n\n### `lfa_combine_sf_obj`\n\nCombine Spatial Feature Objects from Multiple GeoPackage Files\n\n\n#### Arguments\n\nArgument      |Description\n------------- |----------------\n`paths`     |     A character vector containing file paths to GeoPackage files with neighbor information.\n`area_infos`     |     A data frame or list containing information about the corresponding detection areas, including \"area\" and \"specie\" columns.\n\n\n#### Description\n\nThis function reads spatial feature objects (sf) from multiple GeoPackage files and combines them into a single sf object.\n Each GeoPackage file is assumed to contain neighbor information for a specific detection area, and the resulting sf object\n includes additional columns indicating the corresponding area and species information.\n\n\n#### Value\n\nA combined sf object with additional columns for area and specie information.\n\n\n#### Examples\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Assuming paths and area_infos are defined\ncombined_sf <- lfa_combine_sf_obj(paths, area_infos)\n\n# Print the combined sf object\nprint(combined_sf)\n```\n:::\n\n\n\n#### Usage\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlfa_combine_sf_obj(paths, area_infos)\n```\n:::\n\n\n\n\n### `lfa_count_returns_all_areas`\n\nCount tree returns for all species and areas, returning a consolidated data frame.\n\n\n#### Description\n\nThis function iterates through all species and areas obtained from the function\n [`lfa_get_all_areas`](#lfagetallareas) . For each combination of species and area, it reads\n the corresponding area as a catalog, counts the returns per tree using\n [`lfa_count_returns_per_tree`](#lfacountreturnspertree) , and consolidates the results into a data frame.\n The resulting data frame includes columns for the species, area, and return counts per tree.\n\n\n#### Keyword\n\ncounting\n\n\n#### Seealso\n\n[`lfa_get_all_areas`](#lfagetallareas) , [`lfa_read_area_as_catalog`](#lfareadareaascatalog) ,\n [`lfa_count_returns_per_tree`](#lfacountreturnspertree)\n\n\n#### Value\n\nA data frame with columns for species, area, and return counts per tree.\n\n\n#### Examples\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Count tree returns for all species and areas\nreturns_counts <- lfa_count_returns_all_areas()\n```\n:::\n\n\n\n#### Usage\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlfa_count_returns_all_areas()\n```\n:::\n\n\n\n\n### `lfa_count_returns_per_tree`\n\nCount returns per tree for a given lidR catalog.\n\n\n#### Arguments\n\nArgument      |Description\n------------- |----------------\n`ctg`     |     A lidR catalog object containing LAS files to be processed.\n\n\n#### Description\n\nThis function takes a lidR catalog as input and counts the returns per tree.\n It uses the lidR package to read LAS files from the catalog and performs the counting\n operation on each tree. The result is a data frame containing the counts of returns\n for each unique tree ID within the lidR catalog.\n\n\n#### Keyword\n\ncounting\n\n\n#### Seealso\n\n[`lidR::readLAS`](#lidr::readlas) , [`lidR::is.empty`](#lidr::is.empty) ,\n [`base::table`](#base::table) , [`dplyr::bind_rows`](#dplyr::bindrows)\n\n\n#### Value\n\nA data frame with columns for tree ID and the corresponding count of returns.\n\n\n#### Examples\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Count returns per tree for a lidR catalog\nctg <- lfa_read_area_as_catalog(\"SpeciesA\", \"Area1\")\nreturns_counts_per_tree <- lfa_count_returns_per_tree(ctg)\n```\n:::\n\n\n\n#### Usage\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlfa_count_returns_per_tree(ctg)\n```\n:::\n\n\n\n\n### `lfa_create_boxplot`\n\nCreate a box plot from a data frame\n\n\n#### Arguments\n\nArgument      |Description\n------------- |----------------\n`data`     |     A data frame containing the data.\n`value_column`     |     The name of the column containing the values for the box plot.\n`category_column1`     |     The name of the column containing the first categorical variable.\n`category_column2`     |     The name of the column containing the second categorical variable.\n`title`     |     An optional title for the plot. If not provided, a default title is generated based on the data frame name.\n\n\n#### Description\n\nThis function generates a box plot using ggplot2 based on the specified data frame and columns.\n\n\n#### Details\n\nThe function creates a box plot where the x-axis is based on the second categorical variable,\n the y-axis is based on the specified value column, and the box plots are colored based on the first\n categorical variable. The grouping of box plots is done based on the unique values in the second categorical variable.\n\n\n#### Value\n\nA ggplot object representing the box plot.\n\n\n#### Examples\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Assuming you have a data frame 'your_data' with columns 'value', 'category1', and 'category2'\ncreate_boxplot(your_data, \"value\", \"category1\", \"category2\")\n```\n:::\n\n\n\n#### Usage\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlfa_create_boxplot(\n  data,\n  value_column,\n  category_column1,\n  category_column2,\n  title = NULL\n)\n```\n:::\n\n\n\n\n### `lfa_create_density_plots`\n\nCreate density plots for groups in a data frame\n\n\n#### Arguments\n\nArgument      |Description\n------------- |----------------\n`data`     |     A data frame containing the data.\n`value_column`     |     The name of the column containing the values for the density plot.\n`category_column1`     |     The name of the column containing the categorical variable for grouping.\n`category_column2`     |     The name of the column containing the categorical variable for arranging plots.\n`title`     |     An optional title for the plot. If not provided, a default title is generated based on the data frame name.\n`xlims`     |     Optional limits for the x-axis. Should be a numeric vector with two elements (lower and upper bounds).\n`ylims`     |     Optional limits for the y-axis. Should be a numeric vector with two elements (lower and upper bounds).\n\n\n#### Description\n\nThis function generates density plots using ggplot2 based on the specified data frame and columns.\n\n\n#### Details\n\nThe function creates density plots where the x-axis is based on the specified value column,\n and the density plots are colored based on the first categorical variable. The arrangement of plots\n is done based on the unique values in the second categorical variable. The plots are arranged in a 2x2 grid.\n\n\n#### Value\n\nA ggplot object representing the density plots arranged in a 2x2 grid.\n\n\n#### Examples\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Assuming you have a data frame 'your_data' with columns 'value', 'category1', and 'category2'\ncreate_density_plots(your_data, \"value\", \"category1\", \"category2\", title = \"Density Plots\", xlims = c(0, 10), ylims = c(0, 0.5))\n```\n:::\n\n\n\n#### Usage\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlfa_create_density_plots(\n  data,\n  value_column,\n  category_column1 = \"area\",\n  category_column2 = \"specie\",\n  title = NULL,\n  xlims = NULL,\n  ylims = NULL\n)\n```\n:::\n\n\n\n\n### `lfa_create_grouped_bar_plot`\n\nCreate a barplot using ggplot2\n\n\n#### Arguments\n\nArgument      |Description\n------------- |----------------\n`xlab`     |     Label for x-Axis.\n`ylab`     |     Label for y-Axis.\n`title`     |     Title of the plot.\n`df`     |     A data frame containing the relevant columns for the barplot.\n`value_column`     |     The column containing the values to be plotted.\n`label_column`     |     The column used for labeling the bars on the x-axis. Default is \"name\".\n`grouping_column`     |     The column used for grouping the bars. Default is \"species\".\n\n\n#### Description\n\nThis function generates a barplot using ggplot2 based on the specified data frame columns.\n The barplot displays the values from the specified column, grouped by another column.\n The grouping can be further differentiated by color if desired.\n\n\n#### Value\n\nA ggplot2 barplot.\n\n\n#### Examples\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Assuming you have a data frame 'your_data_frame' with columns \"name\", \"species\", and \"value\"\nlfa_create_barplot(your_data_frame, value_column = \"value\", label_column = \"name\", grouping_column = \"species\")\n```\n:::\n\n\n\n#### Usage\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlfa_create_grouped_bar_plot(\n  data,\n  grouping_var,\n  value_col,\n  label_col,\n  xlab = \"Name of Patch\",\n  ylab = \"Density\",\n  title = \"Tree density across the different patches, grouped by specie\"\n)\n```\n:::\n\n\n\n\n### `lfa_create_neighbor_mean_curves`\n\nCreate neighbor mean curves for specified areas\n\n\n#### Arguments\n\nArgument      |Description\n------------- |----------------\n`neighbors`     |     A data frame containing information about neighbors, where each column represents a specific neighbor, and each row corresponds to an area.\n`use_avg`     |     Logical. If TRUE, the function computes average curves across all neighbors. If FALSE, it computes curves for individual neighbors.\n\n\n#### Description\n\nThis function generates mean curves for a specified set of areas based on neighbor data.\n The user can choose to compute mean curves for individual neighbors or averages across neighbors.\n\n\n#### Value\n\nA data frame with mean curves for each specified area.\n Columns represent areas, and rows represent index values.\n\n\n#### Examples\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Assuming you have a data frame 'your_neighbors_data' with neighbor information\nmean_curves <- lfa_create_neighbor_mean_curves(your_neighbors_data, use_avg = TRUE)\nprint(mean_curves)\n```\n:::\n\n\n\n#### Usage\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlfa_create_neighbor_mean_curves(neighbors, use_avg = FALSE)\n```\n:::\n\n\n\n\n### `lfa_create_plot_per_area`\n\nCreate a line plot per area with one color per specie\n\n\n#### Arguments\n\nArgument      |Description\n------------- |----------------\n`data`     |     A data frame with numeric columns and a column named 'specie' for species information.\n\n\n#### Description\n\nThis function takes a data frame containing numeric columns and creates a line plot\n using ggplot2. Each line in the plot represents a different area, with one color per specie.\n\n\n#### Value\n\nA ggplot2 line plot.\n\n\n#### Examples\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata <- data.frame(\nspecie = rep(c(\"Species1\", \"Species2\", \"Species3\"), each = 10),\ncolumn1 = rnorm(30),\ncolumn2 = rnorm(30),\ncolumn3 = rnorm(30)\n)\nlfa_create_plot_per_area(data)\n```\n:::\n\n\n\n#### Usage\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlfa_create_plot_per_area(data)\n```\n:::\n\n\n\n\n### `lfa_create_ppp_from_area`\n\nCreate a point pattern from tree detections in a specified area for a given species.\n\n\n#### Arguments\n\nArgument      |Description\n------------- |----------------\n`species_identifier`     |     A character string specifying the target species for which the point pattern is to be generated.\n`area_identifier`     |     A character string specifying the target area for which the point pattern is to be generated.\n\n\n#### Description\n\nThis function generates a point pattern from tree detections for a specific species\n within a defined area. It filters the detections using the provided `species_identifier` \n and `area_identifier` parameters. The area is defined by a shapefile named\n \"research_areas.shp,\" and the resulting point pattern is created within the specified area.\n\n\n#### Keyword\n\ndata\n\n\n#### Seealso\n\n[`lfa_get_detections`](#lfagetdetections) , [`sf::st_transform`](#sf::sttransform) ,\n [`sf::st_union`](#sf::stunion) , [`spatstat.geom::as.owin`](#spatstat.geom::as.owin) ,\n [`spatstat.geom::as.ppp`](#spatstat.geom::as.ppp)\n\n\n#### Value\n\nA point pattern representing tree detections for the specified species\n within the defined area.\n\n\n#### Examples\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlfa_create_ppp_from_area(species_identifier = \"SpeciesA\", area_identifier = \"Area1\")\n\n# Create a point pattern for a specific species in a given area\npp <- lfa_create_ppp_from_area(species_identifier = \"SpeciesA\", area_identifier = \"Area1\")\n```\n:::\n\n\n\n#### Usage\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlfa_create_ppp_from_area(species_identifier, area_identifier)\n```\n:::\n\n\n\n\n### `lfa_create_stacked_distributions_plot`\n\nCreate a stacked distribution plot for tree detections, visualizing the distribution\n of a specified variable on the x-axis, differentiated by another variable.\n\n\n#### Arguments\n\nArgument      |Description\n------------- |----------------\n`trees`     |     A data frame containing tree detection data.\n`x_value`     |     A character string specifying the column name used for finding the values on the x-axis of the histogram.\n`fill_value`     |     A character string specifying the column name by which the data are differentiated in the plot.\n`bin`     |     An integer specifying the number of bins for the histogram. Default is 100.\n`ylab`     |     A character string specifying the y-axis label. Default is \"Amount trees.\"\n`xlim`     |     A numeric vector of length 2 specifying the x-axis limits. Default is c(0, 100).\n`ylim`     |     A numeric vector of length 2 specifying the y-axis limits. Default is c(0, 1000).\n`title`     |     The title of the plot.\n\n\n#### Description\n\nThis function generates a stacked distribution plot using the ggplot2 package,\n providing a visual representation of the distribution of a specified variable\n ( `x_value` ) on the x-axis, with differentiation based on another variable\n ( `fill_value` ). The data for the plot are derived from the provided `trees` \n data frame.\n\n\n#### Keyword\n\ndata\n\n\n#### Seealso\n\n[`ggplot2::geom_histogram`](#ggplot2::geomhistogram) , [`ggplot2::facet_wrap`](#ggplot2::facetwrap) ,\n [`ggplot2::ylab`](#ggplot2::ylab) , [`ggplot2::scale_fill_brewer`](#ggplot2::scalefillbrewer) ,\n [`ggplot2::coord_cartesian`](#ggplot2::coordcartesian)\n\n\n#### Value\n\nA ggplot object representing the stacked distribution plot.\n\n\n#### Examples\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create a stacked distribution plot for variable \"Z,\" differentiated by \"area\"\ntrees <- lfa_get_detections()\nlfa_create_stacked_distributions_plot(trees, \"Z\", \"area\")\n```\n:::\n\n\n\n#### Usage\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlfa_create_stacked_distributions_plot(\n  trees,\n  x_value,\n  fill_value,\n  bin = 100,\n  ylab = \"Amount trees\",\n  xlim = c(0, 100),\n  ylim = c(0, 1000),\n  title =\n    \"Histograms of height distributions between species 'beech', 'oak', 'pine' and 'spruce' divided by the different areas of Interest\"\n)\n```\n:::\n\n\n\n\n### `lfa_create_stacked_histogram`\n\nCreate a stacked histogram for tree detections, summing up the values for each species.\n\n\n#### Arguments\n\nArgument      |Description\n------------- |----------------\n`trees`     |     A data frame containing tree detection data.\n`x_value`     |     A character string specifying the column name used for finding the values on the x-axis of the histogram.\n`fill_value`     |     A character string specifying the column name by which the data are differentiated in the plot.\n`bin`     |     An integer specifying the number of bins for the histogram. Default is 30.\n`ylab`     |     A character string specifying the y-axis label. Default is \"Frequency.\"\n`xlim`     |     A numeric vector of length 2 specifying the x-axis limits. Default is c(0, 100).\n`ylim`     |     A numeric vector of length 2 specifying the y-axis limits. Default is NULL.\n\n\n#### Description\n\nThis function generates a stacked histogram using the ggplot2 package,\n summing up the values for each species and visualizing the distribution of\n a specified variable ( `x_value` ) on the x-axis, differentiated by another\n variable ( `fill_value` ). The data for the plot are derived from the provided\n `trees` data frame.\n\n\n#### Keyword\n\ndata\n\n\n#### Seealso\n\n[`ggplot2::geom_histogram`](#ggplot2::geomhistogram) , [`ggplot2::ylab`](#ggplot2::ylab) ,\n [`ggplot2::scale_fill_brewer`](#ggplot2::scalefillbrewer) , [`ggplot2::coord_cartesian`](#ggplot2::coordcartesian)\n\n\n#### Value\n\nA ggplot object representing the stacked histogram.\n\n\n#### Examples\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create a stacked histogram for variable \"Z,\" differentiated by \"area\"\ntrees <- lfa_get_detections()\nlfa_create_stacked_histogram(trees, \"Z\", \"area\")\n```\n:::\n\n\n\n#### Usage\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlfa_create_stacked_histogram(\n  trees,\n  x_value,\n  fill_value,\n  bin = 30,\n  ylab = \"Frequency\",\n  xlim = c(0, 100),\n  ylim = NULL\n)\n```\n:::\n\n\n\n\n### `lfa_create_tile_location_objects`\n\nCreate tile location objects\n\n\n#### Author\n\nJakob Danel\n\n\n#### Description\n\nThis function traverses a directory structure to find LAZ files and creates\n tile location objects for each file. The function looks into the the `data` \n directory of the repository/working directory. It then creates `tile_location` \n objects based on the folder structure. The folder structure should not be\n touched by hand, but created by `lfa_init_data_structure()` which builds the\n structure based on a shape file.\n\n\n#### Seealso\n\n[`tile_location`](#tilelocation)\n\n\n#### Value\n\nA vector containing tile location objects.\n\n\n#### Examples\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlfa_create_tile_location_objects()\n\nlfa_create_tile_location_objects()\n```\n:::\n\n\n\n#### Usage\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlfa_create_tile_location_objects()\n```\n:::\n\n\n\n\n### `lfa_detection`\n\nPerform tree detection on a lidar catalog and optionally save the results to a file.\n\n\n#### Arguments\n\nArgument      |Description\n------------- |----------------\n`catalog`     |     A lidar catalog containing point cloud data. If set to NULL, the function attempts to read the catalog from the specified tile location.\n`tile_location`     |     An object specifying the location of the lidar tile. If catalog is NULL, the function attempts to read the catalog from this tile location.\n`write_to_file`     |     A logical value indicating whether to save the detected tree information to a file. Default is TRUE.\n\n\n#### Description\n\nThis function utilizes lidar data to detect trees within a specified catalog. The detected tree information can be optionally saved to a file in the GeoPackage format. The function uses parallel processing to enhance efficiency.\n\n\n#### Value\n\nA sf style data frame containing information about the detected trees.\n\n\n#### Examples\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Perform tree detection on a catalog and save the results to a file\nlfa_detection(catalog = my_catalog, tile_location = my_tile_location, write_to_file = TRUE)\n```\n:::\n\n\n\n#### Usage\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlfa_detection(catalog, tile_location, write_to_file = TRUE)\n```\n:::\n\n\n\n\n### `lfa_download_areas`\n\nDownload areas based on spatial features\n\n\n#### Arguments\n\nArgument      |Description\n------------- |----------------\n`sf_areas`     |     Spatial features representing areas to be downloaded. It must include columns like \"species\" \"name\" See details for more information.\n\n\n#### Author\n\nJakob Danel\n\n\n#### Description\n\nThis function initiates the data structure and downloads areas based on spatial features.\n\n\n#### Details\n\nThe input data frame, `sf_areas` , must have the following columns:\n  \n\n*  \"species\": The species associated with the area. \n\n*  \"name\": The name of the area. \n \n The function uses the `lfa_init_data_structure` function to set up the data structure\n and then iterates through the rows of `sf_areas` to download each specified area.\n\n\n#### Value\n\nNone\n\n\n#### Examples\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlfa_download_areas(sf_areas)\n\n\n# Example spatial features data frame\nsf_areas <- data.frame(\nspecies = c(\"SpeciesA\", \"SpeciesB\"),\nname = c(\"Area1\", \"Area2\"),\n# Must include also other attributes specialized to sf objects\n# such as geometry, for processing of the download\n)\n\nlfa_download_areas(sf_areas)\n```\n:::\n\n\n\n#### Usage\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlfa_download_areas(sf_areas)\n```\n:::\n\n\n\n\n### `lfa_download`\n\nDownload an las file from the state NRW from a specific location\n\n\n#### Arguments\n\nArgument      |Description\n------------- |----------------\n`species`     |     The species of the tree which is observed at this location\n`name`     |     The name of the area that is observed\n`location`     |     An sf object, which holds the location information for the area where the tile should be downloaded from.\n\n\n#### Description\n\nIt will download the file and save it to data/ list(list(\"html\"), list(list(\"<species>\"))) / list(list(\"html\"), list(list(\"<name>\"))) with the name of the tile\n\n\n#### Value\n\nThe LASCatalog object of the downloaded file\n\n\n#### Usage\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlfa_download(species, name, location)\n```\n:::\n\n\n\n\n### `lfa_find_n_nearest_trees`\n\nFind n Nearest Trees\n\n\n#### Arguments\n\nArgument      |Description\n------------- |----------------\n`trees`     |     A sf object containing tree coordinates.\n`n`     |     The number of nearest trees to find for each tree (default is 100).\n\n\n#### Description\n\nThis function calculates the distances to the n nearest trees for each tree in the input dataset.\n\n\n#### Value\n\nA data frame with additional columns representing the distances to the n nearest trees.\n\n\n#### Examples\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load tree data using lfa_get_detections() (not provided)\ntree_data <- lfa_get_detections()\n\n# Filter tree data for a specific species and area\ntree_data = tree_data[tree_data$specie == \"pine\" & tree_data$area == \"greffen\", ]\n\n# Find the 100 nearest trees for each tree in the filtered dataset\ntree_data <- lfa_find_n_nearest_trees(tree_data)\n```\n:::\n\n\n\n#### Usage\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlfa_find_n_nearest_trees(trees, n = 100)\n```\n:::\n\n\n\n\n### `lfa_generate_result_table_tests`\n\nGenerate Result Table for Tests\n\n\n#### Arguments\n\nArgument      |Description\n------------- |----------------\n`table`     |     A data frame representing the result table.\n\n\n#### Description\n\nThis function generates a result table for tests using the knitr::kable function.\n\n\n#### Details\n\nThis function uses the knitr::kable function to create a formatted table, making it suitable for HTML output.\n The input table is expected to be a data frame with test results, and the resulting table will have capitalized\n row and column names with lines between columns and rows.\n\n\n#### Value\n\nA formatted table suitable for HTML output with lines between columns and rows.\n\n\n#### Examples\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Generate a result table for tests\nresult_table <- data.frame(\nTest1 = c(0.05, 0.10, 0.03),\nTest2 = c(0.02, 0.08, 0.01),\nTest3 = c(0.08, 0.12, 0.05)\n)\nformatted_table <- lfa_generate_result_table_tests(result_table)\nprint(formatted_table)\n```\n:::\n\n\n\n#### Usage\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlfa_generate_result_table_tests(table, caption = \"Table Caption\")\n```\n:::\n\n\n\n\n### `lfa_get_all_areas`\n\nRetrieve a data frame containing all species and corresponding areas.\n\n\n#### Description\n\nThis function scans the \"data\" directory within the current working directory to\n obtain a list of species. It then iterates through each species to retrieve the list\n of areas associated with that species. The resulting data frame contains two columns:\n \"specie\" representing the species and \"area\" representing the corresponding area.\n\n\n#### Keyword\n\ndata\n\n\n#### Seealso\n\n[`list.dirs`](#list.dirs)\n\n\n#### Value\n\nA data frame with columns \"specie\" and \"area\" containing information about\n all species and their associated areas.\n\n\n#### Examples\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Retrieve a data frame with information about all species and areas\nall_areas_df <- lfa_get_all_areas()\n```\n:::\n\n\n\n#### Usage\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlfa_get_all_areas()\n```\n:::\n\n\n\n\n### `lfa_get_detection_area`\n\nGet Detection for an area\n\n\n#### Arguments\n\nArgument      |Description\n------------- |----------------\n`species`     |     A character string specifying the target species.\n`name`     |     A character string specifying the name of the tile.\n\n\n#### Description\n\nRetrieves the tree detection information for a specified species and tile.\n\n\n#### Details\n\nThis function reads tree detection data from geopackage files within the specified tile location for a given species. It then combines the data into a single SF data frame and returns it. The function assumes that the tree detection files follow a naming convention with the pattern \"_detection.gpkg\".\n\n\n#### Keyword\n\nspatial\n\n\n#### References\n\nThis function is part of the LiDAR Forest Analysis (LFA) package.\n\n\n#### Seealso\n\n[`get_tile_dir`](#gettiledir)\n\n\n#### Value\n\nA Simple Features (SF) data frame containing tree detection information for the specified species and tile.\n\n\n#### Examples\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Retrieve tree detection data for species \"example_species\" in tile \"example_tile\"\ntrees_data <- lfa_get_detection_tile_location(\"example_species\", \"example_tile\")\n\n# Example usage:\ntrees_data <- lfa_get_detection_tile_location(\"example_species\", \"example_tile\")\n\n# No trees found scenario:\nempty_data <- lfa_get_detection_tile_location(\"nonexistent_species\", \"nonexistent_tile\")\n# The result will be an empty data frame if no trees are found for the specified species and tile.\n\n# Error handling:\n# In case of invalid inputs, the function may throw errors. Ensure correct species and tile names are provided.\n```\n:::\n\n\n\n#### Usage\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlfa_get_detection_area(species, name)\n```\n:::\n\n\n\n\n### `lfa_get_detections_species`\n\nRetrieve detections for a specific species.\n\n\n#### Arguments\n\nArgument      |Description\n------------- |----------------\n`species`     |     A character string specifying the target species.\n\n\n#### Description\n\nThis function retrieves detection data for a given species from multiple areas.\n\n\n#### Details\n\nThe function looks for detection data in the \"data\" directory for the specified species.\n It then iterates through each subdirectory (representing different areas) and consolidates the\n detection data into a single data frame.\n\n\n#### Value\n\nA data frame containing detection information for the specified species in different areas.\n\n\n#### Examples\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Example usage:\ndetections_data <- lfa_get_detections_species(\"example_species\")\n```\n:::\n\n\n\n#### Usage\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlfa_get_detections_species(species)\n```\n:::\n\n\n\n\n### `lfa_get_detections`\n\nRetrieve aggregated detection data for multiple species.\n\n\n#### Concept\n\ndata retrieval functions\n\n\n#### Description\n\nThis function obtains aggregated detection data for multiple species by iterating\n through the list of species obtained from [`lfa_get_species`](#lfagetspecies) . For each\n species, it calls [`lfa_get_detections_species`](#lfagetdetectionsspecies) to retrieve the\n corresponding detection data and aggregates the results into a single data frame.\n The resulting data frame includes columns for the species, tree detection data,\n and the area in which the detections occurred.\n\n\n#### Keyword\n\naggregation\n\n\n#### Seealso\n\n[`lfa_get_species`](#lfagetspecies) , [`lfa_get_detections_species`](#lfagetdetectionsspecies) \n \n Other data retrieval functions:\n [`lfa_get_species`](#lfagetspecies)\n\n\n#### Value\n\nA data frame containing aggregated detection data for multiple species.\n\n\n#### Examples\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlfa_get_detections()\n\n# Retrieve aggregated detection data for multiple species\ndetections_data <- lfa_get_detections()\n```\n:::\n\n\n\n#### Usage\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlfa_get_detections()\n```\n:::\n\n\n\n\n### `lfa_get_flag_path`\n\nGet the path to a flag file indicating the completion of a specific process.\n\n\n#### Arguments\n\nArgument      |Description\n------------- |----------------\n`flag_name`     |     A character string specifying the name of the flag file. It should be a descriptive and unique identifier for the process being flagged.\n\n\n#### Description\n\nThis function constructs and returns the path to a hidden flag file, which serves as an indicator that a particular processing step has been completed. The flag file is created in a designated location within the working directory.\n\n\n#### Value\n\nA character string representing the absolute path to the hidden flag file.\n\n\n#### Examples\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Get the flag path for a process named \"data_processing\"\nlfa_get_flag_path(\"data_processing\")\n```\n:::\n\n\n\n#### Usage\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlfa_get_flag_path(flag_name)\n```\n:::\n\n\n\n\n### `lfa_get_neighbor_paths`\n\nGet Paths to Neighbor GeoPackage Files\n\n\n#### Description\n\nThis function retrieves the file paths to GeoPackage files containing neighbor information for each detection area.\n The GeoPackage files are assumed to be named \"neighbours.gpkg\" and organized in a directory structure under the \"data\" folder.\n\n\n#### Value\n\nA character vector containing file paths to GeoPackage files for each detection area's neighbors.\n\n\n#### Examples\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Get paths to neighbor GeoPackage files for all areas\npaths <- lfa_get_neighbor_paths()\n\n# Print the obtained file paths\nprint(paths)\n```\n:::\n\n\n\n#### Usage\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlfa_get_neighbor_paths()\n```\n:::\n\n\n\n\n### `lfa_get_species`\n\nGet a list of species from the data directory.\n\n\n#### Concept\n\ndata retrieval functions\n\n\n#### Description\n\nThis function retrieves a list of species by scanning the \"data\" directory\n located in the current working directory.\n\n\n#### Keyword\n\ndata\n\n\n#### References\n\nThis function relies on the [`list.dirs`](#list.dirs) function for directory listing.\n\n\n#### Seealso\n\n[`list.dirs`](#list.dirs) \n \n Other data retrieval functions:\n [`lfa_get_detections`](#lfagetdetections)\n\n\n#### Value\n\nA character vector containing the names of species found in the \"data\" directory.\n\n\n#### Examples\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Retrieve the list of species\nspecies_list <- lfa_get_species()\n```\n:::\n\n\n\n#### Usage\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlfa_get_species()\n```\n:::\n\n\n\n\n### `lfa_ground_correction`\n\nCorrect the point clouds for correct ground imagery\n\n\n#### Arguments\n\nArgument      |Description\n------------- |----------------\n`ctg`     |     An LASCatalog object. If not null, it will perform the actions on this object, if NULL inferring the catalog from the tile_location\n`tile_location`     |     A tile_location type object holding the information about the location of the cataog. This is used to save the catalog after processing too.\n\n\n#### Author\n\nJakob Danel\n\n\n#### Description\n\nThis function is needed to correct the Z value of the point cloud, relative to the real\n ground height. After using this function to your catalog, the Z values can be seen as the\n real elevation about the ground. At the moment the function uses the `tin()` function from\n the `lidr` package. NOTE : The operation is inplace and can not be reverted, the old values\n of the point cloud will be deleted!\n\n\n#### Value\n\nA catalog with the corrected z values. The catalog is always stored at tile_location and\n holding only the transformed values.\n\n\n#### Usage\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlfa_ground_correction(ctg, tile_location)\n```\n:::\n\n\n\n\n### `lfa_init_data_structure`\n\nInitialize data structure for species and areas\n\n\n#### Arguments\n\nArgument      |Description\n------------- |----------------\n`sf_species`     |     A data frame with information about species and associated areas.\n\n\n#### Description\n\nThis function initializes the data structure for storing species and associated areas.\n\n\n#### Details\n\nThe input data frame, `sf_species` , should have at least the following columns:\n  \n\n*  \"species\": The names of the species for which the data structure needs to be initialized. \n\n*  \"name\": The names of the associated areas. \n \n The function creates directories based on the species and area information provided in\n the `sf_species` data frame. It checks whether the directories already exist and creates\n them if they don't.\n\n\n#### Value\n\nNone\n\n\n#### Examples\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Example species data frame\nsf_species <- data.frame(\nspecies = c(\"SpeciesA\", \"SpeciesB\"),\nname = c(\"Area1\", \"Area2\"),\n# Other necessary columns\n)\n\nlfa_init_data_structure(sf_species)\n\n# Example species data frame\nsf_species <- data.frame(\nspecies = c(\"SpeciesA\", \"SpeciesB\"),\nname = c(\"Area1\", \"Area2\"),\n# Other necessary columns\n)\n\nlfa_init_data_structure(sf_species)\n```\n:::\n\n\n\n#### Usage\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlfa_init_data_structure(sf_species)\n```\n:::\n\n\n\n\n### `lfa_init`\n\nInitialize LFA (LiDAR forest analysis) data processing\n\n\n#### Arguments\n\nArgument      |Description\n------------- |----------------\n`sf_file`     |     A character string specifying the path to the shapefile containing spatial features of research areas.\n\n\n#### Description\n\nThis function initializes the LFA data processing by reading a shapefile containing\n spatial features of research areas, downloading the specified areas, and creating\n tile location objects for each area.\n\n\n#### Details\n\nThis function reads a shapefile ( `sf_file` ) using the `sf` package, which should\n contain information about research areas. It then calls the `lfa_download_areas` \n function to download the specified areas and `lfa_create_tile_location_objects` \n to create tile location objects based on Lidar data files in those areas. The\n shapefile MUST follow the following requirements:\n  \n\n*  Each geometry must be a single object of type polygon \n\n*  Each entry must have the following attributes:  \n\n*  species: A string describing the tree species of the area. \n\n*  name: A string describing the location of the area.\n\n\n#### Value\n\nA vector containing tile location objects.\n\n\n#### Examples\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Initialize LFA processing with the default shapefile\nlfa_init()\n\n# Initialize LFA processing with a custom shapefile\nlfa_init(\"custom_areas.shp\")\n\n# Example usage with the default shapefile\nlfa_init()\n\n# Example usage with a custom shapefile\nlfa_init(\"custom_areas.shp\")\n```\n:::\n\n\n\n#### Usage\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlfa_init(sf_file = \"research_areas.shp\")\n```\n:::\n\n\n\n\n### `lfa_intersect_areas`\n\nIntersect Lidar Catalog with Spatial Features\n\n\n#### Arguments\n\nArgument      |Description\n------------- |----------------\n`ctg`     |     A LAScatalog object representing the Lidar data to be processed.\n`tile_location`     |     A tile location object representing the specific area of interest.\n`areas_sf`     |     Spatial features defining areas.\n\n\n#### Description\n\nThis function intersects a Lidar catalog with a specific area defined by spatial features.\n\n\n#### Details\n\nThe function intersects the Lidar catalog specified by `ctg` with a specific area defined by\n the `tile_location` object and `areas_sf` . It removes points outside the specified area and\n returns a modified LAScatalog object.\n \n The specified area is identified based on the `species` and `name` attributes in the\n `tile_location` object. If a matching area is not found in `areas_sf` , the function\n stops with an error.\n \n The function then transforms the spatial reference of the identified area to match that of\n the Lidar catalog using `sf::st_transform` .\n \n The processing is applied to each chunk in the catalog using the `identify_area` function,\n which merges spatial information and filters out points that are not classified as inside\n the identified area. After processing, the function writes the modified LAS files back to\n the original file locations, removing points outside the specified area.\n \n If an error occurs during the processing of a chunk, a warning is issued, and the function\n continues processing the next chunks. If no points are found after filtering, a warning is\n issued, and NULL is returned.\n\n\n#### Seealso\n\nOther functions in the Lidar forest analysis (LFA) package.\n\n\n#### Value\n\nA modified LAScatalog object with points outside the specified area removed.\n\n\n#### Examples\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Example usage\nlfa_intersect_areas(ctg, tile_location, areas_sf)\n\n# Example usage\nlfa_intersect_areas(ctg, tile_location, areas_sf)\n```\n:::\n\n\n\n#### Usage\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlfa_intersect_areas(ctg, tile_location, areas_sf)\n```\n:::\n\n\n\n\n### `lfa_jsd_from_vec`\n\nCompute Jensen-Shannon Divergence from Vectors\n\n\n#### Arguments\n\nArgument      |Description\n------------- |----------------\n`x`     |     A numeric vector.\n`y`     |     A numeric vector.\n\n\n#### Description\n\nThis function calculates the Jensen-Shannon Divergence (JSD) between two vectors.\n\n\n#### Value\n\nJensen-Shannon Divergence between the density distributions of x and y.\n\n\n#### Examples\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- rnorm(100)\ny <- rnorm(100, mean = 2)\nlfa_jsd_from_vec(x, y)\n```\n:::\n\n\n\n#### Usage\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlfa_jsd_from_vec(x, y)\n```\n:::\n\n\n\n\n### `lfa_jsd`\n\nJensen-Shannon Divergence Calculation\n\n\n#### Arguments\n\nArgument      |Description\n------------- |----------------\n`p`     |     A numeric vector representing the probability distribution P.\n`q`     |     A numeric vector representing the probability distribution Q.\n`epsilon`     |     A small positive constant added to both P and Q to avoid logarithm of zero. Default is 1e-10.\n\n\n#### Description\n\nThis function calculates the Jensen-Shannon Divergence (JSD) between two probability distributions P and Q.\n\n\n#### Details\n\nThe JSD is computed using the Kullback-Leibler Divergence (KLD) as follows:\n `sum((p * log((p + epsilon) / (m + epsilon)) + q * log((q + epsilon) / (m + epsilon))) / 2)` \n where `m = (p + q) / 2` .\n\n\n#### Seealso\n\n[`kld`](#kld) , [`sum`](#sum) , [`log`](#log)\n\n\n#### Value\n\nA numeric value representing the Jensen-Shannon Divergence between P and Q.\n\n\n#### Examples\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Calculate JSD between two probability distributions\np_distribution <- c(0.2, 0.3, 0.5)\nq_distribution <- c(0.1, 0, 0.9)\njsd_result <- jsd(p_distribution, q_distribution)\nprint(jsd_result)\n```\n:::\n\n\n\n#### Usage\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlfa_jsd(p, q, epsilon = 1e-10)\n```\n:::\n\n\n\n\n### `lfa_kld_from_vec`\n\nCompute Kullback-Leibler Divergence from Vectors\n\n\n#### Arguments\n\nArgument      |Description\n------------- |----------------\n`x`     |     A numeric vector.\n`y`     |     A numeric vector.\n\n\n#### Description\n\nThis function calculates the Kullback-Leibler Divergence (KLD) between two vectors.\n\n\n#### Value\n\nKullback-Leibler Divergence between the density distributions of x and y.\n\n\n#### Examples\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- rnorm(100)\ny <- rnorm(100, mean = 2)\nlfa_kld_from_vec(x, y)\n```\n:::\n\n\n\n#### Usage\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlfa_kld_from_vec(x, y)\n```\n:::\n\n\n\n\n### `lfa_kld`\n\nKullback-Leibler Divergence Calculation\n\n\n#### Arguments\n\nArgument      |Description\n------------- |----------------\n`p`     |     A numeric vector representing the probability distribution P.\n`q`     |     A numeric vector representing the probability distribution Q.\n`epsilon`     |     A small positive constant added to both P and Q to avoid logarithm of zero. Default is 1e-10.\n\n\n#### Description\n\nThis function calculates the Kullback-Leibler Divergence (KLD) between two probability distributions P and Q.\n\n\n#### Details\n\nThe KLD is computed using the formula:\n `sum(p * log((p + epsilon) / (q + epsilon)))` \n This avoids issues when the denominator (Q) contains zero probabilities.\n\n\n#### Seealso\n\n[`sum`](#sum) , [`log`](#log)\n\n\n#### Value\n\nA numeric value representing the Kullback-Leibler Divergence between P and Q.\n\n\n#### Examples\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Calculate KLD between two probability distributions\np_distribution <- c(0.2, 0.3, 0.5)\nq_distribution <- c(0.1, 0, 0.9)\nkld_result <- kld(p_distribution, q_distribution)\nprint(kld_result)\n```\n:::\n\n\n\n#### Usage\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlfa_kld(p, q, epsilon = 1e-10)\n```\n:::\n\n\n\n\n### `lfa_ks_test`\n\nKolmogorov-Smirnov Test Wrapper Function\n\n\n#### Arguments\n\nArgument      |Description\n------------- |----------------\n`x`     |     A numeric vector representing the first sample.\n`y`     |     A numeric vector representing the second sample.\n`output_variable`     |     A character string specifying the output variable to extract from the ks.test result. Default is \"p.value\". Other possible values include \"statistic\" and \"alternative\".\n`...`     |     Additional arguments to be passed to the ks.test function.\n\n\n#### Description\n\nThis function serves as a wrapper for the Kolmogorov-Smirnov (KS) test between two samples.\n\n\n#### Details\n\nThe function uses the ks.test function to perform a two-sample KS test and returns the specified output variable.\n The default output variable is the p-value. Other possible output variables include \"statistic\" and \"alternative\".\n\n\n#### Seealso\n\n[`ks.test`](#ks.test)\n\n\n#### Value\n\nA numeric value representing the specified output variable from the KS test result.\n\n\n#### Examples\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Perform KS test and extract the p-value\nresult <- lfa_ks_test(sample1, sample2)\nprint(result)\n\n# Perform KS test and extract the test statistic\nresult_statistic <- lfa_ks_test(sample1, sample2, output_variable = \"statistic\")\nprint(result_statistic)\n```\n:::\n\n\n\n#### Usage\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlfa_ks_test(x, y, output_variable = \"p.value\", ...)\n```\n:::\n\n\n\n\n### `lfa_load_ctg_if_not_present`\n\nLoading the catalog if it is not present\n\n\n#### Arguments\n\nArgument      |Description\n------------- |----------------\n`ctg`     |     Catalog object. Can be NULL\n`tile_location`     |     The location to look for the catalog tiles, if their are not present\n\n\n#### Description\n\nThis function checks if the catalog is `NULL` . If it is it will load the\n catalog from the `tile_location`\n\n\n#### Value\n\nThe provided ctg object if not null, else the catalog for the tiles\n of the tile_location.\n\n\n#### Usage\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlfa_load_ctg_if_not_present(ctg, tile_location)\n```\n:::\n\n\n\n\n### `lfa_map_tile_locations`\n\nMap Function Over Tile Locations\n\n\n#### Arguments\n\nArgument      |Description\n------------- |----------------\n`tile_locations`     |     A list of tile location objects.\n`map_function`     |     The mapping function to be applied to each tile location.\n`...`     |     Additional arguments to be passed to the mapping function.\n\n\n#### Description\n\nThis function applies a specified mapping function to each tile location in a list.\n\n\n#### Details\n\nThis function iterates over each tile location in the provided list ( `tile_locations` )\n and applies the specified mapping function ( `map_function` ) to each tile location.\n The mapping function should accept a tile location object as its first argument, and\n additional arguments can be passed using the ellipsis ( `...` ) syntax.\n \n This function is useful for performing operations on multiple tile locations concurrently,\n such as loading Lidar data, processing areas, or other tasks that involve tile locations.\n\n\n#### Seealso\n\nThe mapping function provided should be compatible with the structure and requirements\n of the tile locations and the specific task being performed.\n\n\n#### Value\n\nNone\n\n\n#### Examples\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Example usage\nlfa_map_tile_locations(tile_locations, my_mapping_function, param1 = \"value\")\n\n# Example usage\nlfa_map_tile_locations(tile_locations, my_mapping_function, param1 = \"value\")\n```\n:::\n\n\n\n#### Usage\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlfa_map_tile_locations(tile_locations, map_function, check_flag = NULL, ...)\n```\n:::\n\n\n\n\n### `lfa_merge_and_save`\n\nMerge and Save Text Files in a Directory\n\n\n#### Arguments\n\nArgument      |Description\n------------- |----------------\n`input_directory`     |     The path to the input directory containing text files.\n`output_name`     |     The name for the output file where the merged content will be saved.\n\n\n#### Description\n\nThis function takes an input directory and an output name as arguments.\n It merges the textual content of all files in the specified directory into\n a single string, with each file's content separated by a newline character.\n The merged content is then saved into a file named after the output name\n in the same directory. After the merging is complete, all input files are\n deleted.\n\n\n#### Details\n\nThis function reads the content of each text file in the specified input directory\n and concatenates them into a single string. Each file's content is separated by a newline\n character. The merged content is then saved into a file named after the output name\n in the same directory. Finally, all input files are deleted from the directory.\n\n\n#### Seealso\n\n[`readLines`](#readlines) , [`writeLines`](#writelines) , [`file.remove`](#file.remove)\n\n\n#### Value\n\nThis function does not explicitly return any value. It prints a message\n indicating the successful completion of the merging and saving process.\n\n\n#### Examples\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Merge text files in the \"data_files\" directory and save the result in \"merged_output\"\nlfa_merge_and_save(\"data_files\", \"merged_output\")\n\n# Merge text files in the \"data_files\" directory and save the result in \"merged_output\"\nlfa_merge_and_save(\"data_files\", \"merged_output\")\n```\n:::\n\n\n\n#### Usage\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlfa_merge_and_save(input_directory, output_name)\n```\n:::\n\n\n\n\n### `lfa_plot_confusion_matrix`\n\nPlot Confusion Matrix\n\n\n#### Arguments\n\nArgument      |Description\n------------- |----------------\n`conf_matrix`     |     Confusion matrix, typically obtained from classification evaluation.\n\n\n#### Description\n\nThis function generates a heatmap plot of a confusion matrix using ggplot2.\n\n\n#### Details\n\nThe function takes a confusion matrix as input and generates a heatmap plot using ggplot2.\n The plot represents the relationship between the predicted and actual classes, with cell colors indicating the frequency of each combination.\n Additionally, the plot includes labels for accuracy and kappa statistics based on the confusion matrix.\n\n\n#### Value\n\nA ggplot object representing the confusion matrix heatmap plot.\n\n\n#### Examples\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Example confusion matrix\ncm <- table(predicted = c(\"A\", \"B\", \"A\", \"B\"), actual = c(\"A\", \"A\", \"B\", \"B\"))\n# Plot confusion matrix\nlfa_plot_confusion_matrix(cm)\n```\n:::\n\n\n\n#### Usage\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlfa_plot_confusion_matrix(conf_matrix)\n```\n:::\n\n\n\n\n### `lfa_precision_per_class`\n\nCalculate Precision per Class from Confusion Matrix\n\n\n#### Arguments\n\nArgument      |Description\n------------- |----------------\n`confusion_matrix`     |     Confusion matrix obtained from a classification evaluation.\n\n\n#### Description\n\nThis function calculates precision for each class based on the provided confusion matrix.\n\n\n#### Details\n\nPrecision is a measure of the accuracy of the positive predictions for a specific class. It is calculated as the ratio of true positives to the sum of true positives and false positives.\n\n\n#### Seealso\n\n[`lfa_recall_per_class`](#lfarecallperclass) , [`lfa_f1_score_per_class`](#lfaf1scoreperclass)\n\n\n#### Value\n\nA numeric vector representing precision for each class.\n\n\n#### Examples\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Example confusion matrix\ncm <- table(predicted = c(\"A\", \"B\", \"A\", \"B\"), actual = c(\"A\", \"A\", \"B\", \"B\"))\n# Calculate precision per class\nprecision_vector <- lfa_precision_per_class(cm)\n```\n:::\n\n\n\n#### Usage\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlfa_precision_per_class(confusion_matrix)\n```\n:::\n\n\n\n\n### `lfa_random_forest`\n\nRandom Forest Classifier with Leave-One-Out Cross-Validation\n\n\n#### Arguments\n\nArgument      |Description\n------------- |----------------\n`tree_data`     |     A data frame containing the tree data, including the response variable (\"specie\") and predictor variables.\n`excluded_input_columns`     |     A character vector specifying columns to be excluded from predictor variables.\n`response_variable`     |     The response variable to be predicted (default is \"specie\").\n`seed`     |     An integer to set the seed for reproducibility (default is 123).\n`...`     |     Additional parameters to be passed to the randomForest function.\n\n\n#### Description\n\nThis function performs a random forest classification using leave-one-out cross-validation for each area in the input tree data.\n It returns a list containing various results, including predicted species, confusion matrix, accuracy, and the formula used for modeling.\n\n\n#### Value\n\nA list containing the following elements:\n  \n\n*   `predicted_species_absolute` : A data frame with observed and predicted species for each area. \n\n*   `predicted_species_relative` : A data frame wit the relative precictions per speices and areas, normalized by the total predictions in each area. \n\n*   `confusion_matrix` : A confusion matrix showing the counts of predicted vs. observed species. \n\n*   `accuracy` : The accuracy of the model, calculated as the sum of diagonal elements in the confusion matrix divided by the total count. \n\n*   `formula` : The formula used for modeling.\n\n\n#### Examples\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Assuming tree_data is defined\nresults <- lfa_random_forest(tree_data, excluded_input_columns = c(\"column1\", \"column2\"))\n\n# Print the list of results\nprint(results)\n```\n:::\n\n\n\n#### Usage\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlfa_random_forest(\n  tree_data,\n  excluded_input_columns,\n  response_variable = \"specie\",\n  ntree = 100,\n  seed = 123,\n  ...\n)\n```\n:::\n\n\n\n\n### `lfa_rasterize_chunk`\n\nRasterize Lidar Chunk\n\n\n#### Arguments\n\nArgument      |Description\n------------- |----------------\n`chunk`     |     Lidar chunk object to be rasterized.\n`...`     |     Additional arguments to be passed to the underlying lidR::rasterize_canopy function.\n\n\n#### Description\n\nThis function rasterizes a Lidar chunk to generate a raster representation of the canopy.\n\n\n#### Details\n\nThe function takes a Lidar chunk as input and uses lidR::rasterize_canopy to generate a raster representation of the canopy.\n Additional arguments can be passed to customize the rasterization process.\n\n\n#### Value\n\nA raster layer representing the rasterized canopy.\n\n\n#### Examples\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Example Lidar chunk\nlidar_chunk <- readLAS(\"lidar_data.las\", select = \"xyz\")\n# Rasterize Lidar chunk\nrasterized_canopy <- lfa_rasterize_chunk(lidar_chunk)\n```\n:::\n\n\n\n#### Usage\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlfa_rasterize_chunk(chunk, ...)\n```\n:::\n\n\n\n\n### `lfa_rd_to_qmd`\n\nConvert Rd File to Markdown\n\n\n#### Arguments\n\nArgument      |Description\n------------- |----------------\n`rdfile`     |     The path to the Rd file or a parsed Rd object.\n`outfile`     |     The path to the output Markdown file (including the file extension).\n`append`     |     Logical, indicating whether to append to an existing file (default is FALSE).\n\n\n#### Description\n\nIMPORTANT NOTE: \n This function is nearly identical to the `Rd2md::Rd2markdown` function from the `Rd2md` \n package. We needed to implement our own version of it because of various reasons:\n  \n\n*  The algorithm uses hardcoded header sizes (h1 and h2 in original) which is not feasible for our use-case of the markdown. \n\n*  We needed to add some Quarto Markdown specifics, e.g. to make sure that the examples will not be runned. \n\n*  We want to exclude certain tags from our implementation.\n\n\n#### Details\n\nFor that reason we copied the method and made changes as needed and also added this custom documentation.\n \n This function converts an Rd (R documentation) file to Markdown format (.md) and\n saves the converted file at the specified location. The function allows appending\n to an existing file or creating a new one. The resulting Markdown file includes\n sections for the function's name, title, and additional content such as examples,\n usage, arguments, and other sections present in the Rd file.\n \n The function performs the following steps:\n  \n\n*  Parses the Rd file using the Rd2md package. \n\n*  Creates a Markdown file with sections for the function's name, title, and additional content. \n\n*  Appends the content to an existing file if `append` is set to TRUE. \n\n*  Saves the resulting Markdown file at the specified location.\n\n\n#### Seealso\n\n[`Rd2md::parseRd`](#rd2md::parserd)\n\n\n#### Value\n\nThis function does not explicitly return any value. It saves the converted Markdown file\n at the specified location as described in the details section.\n\n\n#### Examples\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Convert Rd file to Markdown and save it\nlfa_rd_to_md(\"path/to/your/file.Rd\", \"path/to/your/output/file.md\")\n\n# Convert Rd file to Markdown and append to an existing file\nlfa_rd_to_md(\"path/to/your/file.Rd\", \"path/to/existing/output/file.md\", append = TRUE)\n```\n:::\n\n\n\n#### Usage\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlfa_rd_to_qmd(rdfile, outfile, append = FALSE)\n```\n:::\n\n\n\n\n### `lfa_rd_to_results`\n\nConvert Rd Files to Markdown and Merge Results\n\n\n#### Description\n\nThis function converts all Rd (R documentation) files in the \"man\" directory\n to Markdown format (.qmd) and saves the converted files in the \"results/appendix/package-docs\" directory.\n It then merges the converted Markdown files into a single string and saves\n the merged content into a file named \"docs.qmd\" in the \"results/appendix/package-docs\" directory.\n\n\n#### Details\n\nThe function performs the following steps:\n  \n\n*  Removes any existing \"docs.qmd\" file in the \"results/appendix/package-docs\" directory. \n\n*  Finds all Rd files in the \"man\" directory. \n\n*  Converts each Rd file to Markdown format (.qmd) using the `lfa_rd_to_qmd` function. \n\n*  Saves the converted Markdown files in the \"results/appendix/package-docs\" directory. \n\n*  Merges the content of all converted Markdown files into a single string. \n\n*  Saves the merged content into a file named \"docs.qmd\" in the \"results/appendix/package-docs\" directory.\n\n\n#### Seealso\n\n[`lfa_rd_to_qmd`](#lfardtoqmd) , [`lfa_merge_and_save`](#lfamergeandsave)\n\n\n#### Value\n\nThis function does not explicitly return any value. It performs the conversion,\n merging, and saving operations as described in the details section.\n\n\n#### Examples\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Convert Rd files to Markdown and merge the results\nlfa_rd_to_results()\n```\n:::\n\n\n\n#### Usage\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlfa_rd_to_results()\n```\n:::\n\n\n\n\n### `lfa_read_area_as_catalog`\n\nRead LiDAR data from a specified species and location as a catalog.\n\n\n#### Arguments\n\nArgument      |Description\n------------- |----------------\n`specie`     |     A character string specifying the species of interest.\n`location_name`     |     A character string specifying the name of the location.\n\n\n#### Description\n\nThis function constructs the file path based on the specified `specie` and `location_name` ,\n lists the directories at that path, and reads the LiDAR data into a `lidR::LAScatalog` .\n\n\n#### Value\n\nA `lidR::LAScatalog` object containing the LiDAR data from the specified location and species.\n\n\n#### Examples\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlfa_read_area_as_catalog(\"beech\", \"location1\")\n```\n:::\n\n\n\n#### Usage\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlfa_read_area_as_catalog(specie, location_name)\n```\n:::\n\n\n\n\n### `lfa_recall_per_class`\n\nCalculate Recall per Class from Confusion Matrix\n\n\n#### Arguments\n\nArgument      |Description\n------------- |----------------\n`confusion_matrix`     |     Confusion matrix obtained from a classification evaluation.\n\n\n#### Description\n\nThis function calculates recall for each class based on the provided confusion matrix.\n\n\n#### Details\n\nRecall (Sensitivity or True Positive Rate) is a measure of the ability of a classification model to identify all relevant instances. It is calculated as the ratio of true positives to the sum of true positives and false negatives.\n\n\n#### Seealso\n\n[`lfa_precision_per_class`](#lfaprecisionperclass)\n\n\n#### Value\n\nA numeric vector representing recall for each class.\n\n\n#### Examples\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Example confusion matrix\ncm <- table(predicted = c(\"A\", \"B\", \"A\", \"B\"), actual = c(\"A\", \"A\", \"B\", \"B\"))\n# Calculate recall per class\nrecall_vector <- lfa_recall_per_class(cm)\n```\n:::\n\n\n\n#### Usage\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlfa_recall_per_class(confusion_matrix)\n```\n:::\n\n\n\n\n### `lfa_run_test_asymmetric`\n\nAsymmetric Pairwise Test for Categories\n\n\n#### Arguments\n\nArgument      |Description\n------------- |----------------\n`data`     |     A data frame containing the relevant columns.\n`data_column`     |     A character string specifying the column containing the numerical data.\n`category_column`     |     A character string specifying the column containing the categorical variable.\n`test_function`     |     A function used to perform the pairwise test between two sets of data. It should accept two vectors of numeric data and additional parameters specified by `...` . The function should return a numeric value representing the test result.\n`...`     |     Additional parameters to be passed to the `test_function` .\n\n\n#### Description\n\nThis function performs an asymmetric pairwise test for categories using a user-defined `test_function` .\n\n\n#### Details\n\nThe function calculates the test results for each unique combination of categories using the specified\n `test_function` . The resulting table is asymmetric, containing the test results for comparisons\n from the rows to the columns.\n\n\n#### Seealso\n\n[`outer`](#outer) , [`Vectorize`](#vectorize)\n\n\n#### Value\n\nA data frame representing the results of the asymmetric pairwise tests between categories.\n\n\n#### Examples\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Define a custom test function\ncustom_test_function <- function(x, y) {\n# Your test logic here\n# Return a numeric result\nreturn(mean(x) - mean(y))\n}\n\n# Perform an asymmetric pairwise test\nresult <- lfa_run_test_asymmetric(your_data, \"numeric_column\", \"category_column\", custom_test_function)\n```\n:::\n\n\n\n#### Usage\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlfa_run_test_asymmetric(data, data_column, category_column, test_function, ...)\n```\n:::\n\n\n\n\n### `lfa_run_test_symmetric`\n\nSymmetric Pairwise Test for Categories\n\n\n#### Arguments\n\nArgument      |Description\n------------- |----------------\n`data`     |     A data frame containing the relevant columns.\n`data_column`     |     A character string specifying the column containing the numerical data.\n`category_column`     |     A character string specifying the column containing the categorical variable.\n`test_function`     |     A function used to perform the pairwise test between two sets of data. It should accept two vectors of numeric data and additional parameters specified by `...` . The function should return a numeric value representing the test result.\n`...`     |     Additional parameters to be passed to the `test_function` .\n\n\n#### Description\n\nThis function performs a symmetric pairwise test for categories using a user-defined `test_function` .\n\n\n#### Details\n\nThe function calculates the test results for each unique combination of categories using the specified\n `test_function` . The resulting table is symmetric, containing the test results for comparisons\n from the rows to the columns. The upper triangle of the matrix is filled with `NA` to avoid duplicate results.\n\n\n#### Seealso\n\n[`outer`](#outer) , [`Vectorize`](#vectorize)\n\n\n#### Value\n\nA data frame representing the results of the symmetric pairwise tests between categories.\n\n\n#### Examples\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Define a custom test function\ncustom_test_function <- function(x, y) {\n# Your test logic here\n# Return a numeric result\nreturn(mean(x) - mean(y))\n}\n\n# Perform a symmetric pairwise test\nresult <- lfa_run_test_symmetric(your_data, \"numeric_column\", \"category_column\", custom_test_function)\n```\n:::\n\n\n\n#### Usage\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlfa_run_test_symmetric(data, data_column, category_column, test_function, ...)\n```\n:::\n\n\n\n\n### `lfa_save_all_neighbours`\n\nSave Neighbors for All Areas\n\n\n#### Arguments\n\nArgument      |Description\n------------- |----------------\n`n`     |     The number of nearest trees to find for each tree (default is 100).\n\n\n#### Description\n\nThis function iterates through all detection areas, finds the n nearest trees for each tree,\n and saves the result to a GeoPackage file for each area.\n\n\n#### Examples\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Save neighbors for all areas with default value (n=100)\nlfa_save_all_neighbours()\n\n# Save neighbors for all areas with a specific value of n (e.g., n=50)\nlfa_save_all_neighbours(n = 50)\n```\n:::\n\n\n\n#### Usage\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlfa_save_all_neighbours(n = 100)\n```\n:::\n\n\n\n\n### `lfa_segmentation`\n\nSegment the elements of an point cloud by trees\n\n\n#### Arguments\n\nArgument      |Description\n------------- |----------------\n`ctg`     |     An LASCatalog object. If not null, it will perform the actions on this object, if NULL inferring the catalog from the tile_location\n`tile_location`     |     A tile_location type object holding the information about the location of the catalog. This is used to save the catalog after processing too.\n\n\n#### Author\n\nJakob Danel\n\n\n#### Description\n\nThis function will try to to divide the hole point cloud into unique trees.\n Therefore it is assigning for each chunk of the catalog  a `treeID` for each\n point. Therefore the algorithm uses the `li2012` implementation with the\n following parameters: `li2012(dt1 = 2, dt2 = 3, R = 2, Zu = 10, hmin = 5, speed_up = 12)` \n NOTE : The operation is in place and can not be reverted, the old values\n of the point cloud will be deleted!\n\n\n#### Value\n\nA catalog where each chunk has additional `treeID` values indicating the belonging tree.\n\n\n#### Usage\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlfa_segmentation(ctg, tile_location)\n```\n:::\n\n\n\n\n### `lfa_set_flag`\n\nSet a flag to indicate the completion of a specific process.\n\n\n#### Arguments\n\nArgument      |Description\n------------- |----------------\n`flag_name`     |     A character string specifying the name of the flag file. It should be a descriptive and unique identifier for the process being flagged.\n\n\n#### Description\n\nThis function creates a hidden flag file at a specified location within the working directory to indicate that a particular processing step has been completed. If the flag file already exists, a warning is issued.\n\n\n#### Value\n\nThis function does not have a formal return value.\n\n\n#### Examples\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Set the flag for a process named \"data_processing\"\nlfa_set_flag(\"data_processing\")\n```\n:::\n\n\n\n#### Usage\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlfa_set_flag(flag_name)\n```\n:::\n\n\n\n\n### `lfa_visit_all_areas`\n\nVisit All Areas and Apply Preprocessing Function\n\n\n#### Arguments\n\nArgument      |Description\n------------- |----------------\n`preprocessing_function`     |     The preprocessing function to be applied to each area. It should take specie, area, and additional parameters as inputs.\n`areas`     |     Data frame containing information about different areas, including columns \"specie\" and \"area.\"\n`...`     |     Additional arguments to be passed to the preprocessing function.\n\n\n#### Description\n\nThis function iterates over all specified areas and applies a preprocessing function to each one.\n\n\n#### Details\n\nThe function iterates over all areas specified in the 'areas' parameter, and for each area, it applies the provided preprocessing function.\n The 'areas' parameter is expected to be a data frame with columns \"specie\" and \"area,\" containing information about different areas to visit.\n Additional arguments passed via '...' are forwarded to the preprocessing function.\n\n\n#### Seealso\n\n[`lfa_get_all_areas`](#lfagetallareas)\n\n\n#### Value\n\nA list containing the results of applying the preprocessing function to each area.\n\n\n#### Examples\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Example preprocessing function\nmy_preprocessing_function <- function(specie, area, ...) {\n# Your preprocessing logic here\n# Return the result\nreturn(result)\n}\n# Visit all areas and apply the preprocessing function\nresults_list <- lfa_visit_all_areas(my_preprocessing_function)\n```\n:::\n\n\n\n#### Usage\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlfa_visit_all_areas(preprocessing_function, areas = lfa_get_all_areas(), ...)\n```\n:::\n\n\n\n\n### `lfa_visualize_rf_metrics`\n\nVisualize Precision and Recall Metrics for Random Forest Classification\n\n\n#### Arguments\n\nArgument      |Description\n------------- |----------------\n`metrics_df`     |     Data frame containing precision and recall metrics for each class.\n\n\n#### Description\n\nThis function creates a bar plot to visualize precision and recall metrics for each class obtained from a Random Forest classification.\n\n\n#### Details\n\nThe function creates a bar plot to visualize precision and recall metrics for each class obtained from a Random Forest classification.\n\n\n#### Seealso\n\n[`lfa_calculate_rf_metrics`](#lfacalculaterfmetrics)\n\n\n#### Value\n\nA ggplot object representing the bar plot of precision and recall metrics.\n\n\n#### Examples\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Example data frame containing precision and recall metrics\nexample_metrics_df <- data.frame(\nClass = c(\"ClassA\", \"ClassB\"),\nPrecision = c(0.85, 0.92),\nRecall = c(0.78, 0.88)\n)\n# Visualize precision and recall metrics\nlfa_visualize_rf_metrics(example_metrics_df)\n```\n:::\n\n\n\n#### Usage\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlfa_visualize_rf_metrics(metrics_df)\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<script src=\"site_libs/kePrint-0.0.1/kePrint.js\"></script>\n<link href=\"site_libs/lightable-0.0.1/lightable.css\" rel=\"stylesheet\" />\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}