[
  {
    "objectID": "methods/distribution-analysis.html",
    "href": "methods/distribution-analysis.html",
    "title": "",
    "section": "",
    "text": "Analysis of data distributions is a critical aspect of our research, with a focus on comparing two or more distributions. Our objective extends beyond evaluating the disparities between species; we also aim to assess differences within a species. To gain a comprehensive understanding of the data, we employ various visualization techniques, including histograms, density functions, and box plots.\nIn tandem with visualizations, descriptive statistics, such as means, standard errors, and quantiles, are leveraged to provide key insights into the central tendency and variability of the data.\nFor a more quantitative analysis of distribution dissimilarity, statistical tests are employed. The Kullback-Leibler (KL) difference serves as a measure to compare the similarity of a set of distributions. This involves converting distributions into their density functions, with the standard error serving as the bandwidth. The KL difference is calculated for each pair of distributions, as it is asymmetric. For the two distributions the KL difference is defined as following [@kullback1951kullback]:\n\\[\nD_{KL}(P \\, \\| \\, Q) = \\sum_i P(i) \\log\\left(\\frac{P(i)}{Q(i)}\\right)\n\\]\nTo obtain a symmetric score, the Jensen-Shannon Divergence (JSD) is utilized [@grosse2002analysis], expressed by the formula:\n\\[\nJS(P || Q) = \\frac{1}{2} * KL(P || M) + \\frac{1}{2} * KL(Q || M)\n\\] Here, \\(M = \\frac{1}{2} * (P + Q)\\). The JSD provides a balanced measure of dissimilarity between distributions [@Brownlee2019Calculate]. For comparing the different scores to each other, we will use averages.\nAdditionally, the Kolmogorov-Smirnov Test is implemented to assess whether two distributions significantly differ from each other. This statistical test offers a formal evaluation of the dissimilarity between empirical distribution functions."
  },
  {
    "objectID": "methods/distribution-analysis.html#analysis-of-different-distributions",
    "href": "methods/distribution-analysis.html#analysis-of-different-distributions",
    "title": "",
    "section": "",
    "text": "Analysis of data distributions is a critical aspect of our research, with a focus on comparing two or more distributions. Our objective extends beyond evaluating the disparities between species; we also aim to assess differences within a species. To gain a comprehensive understanding of the data, we employ various visualization techniques, including histograms, density functions, and box plots.\nIn tandem with visualizations, descriptive statistics, such as means, standard errors, and quantiles, are leveraged to provide key insights into the central tendency and variability of the data.\nFor a more quantitative analysis of distribution dissimilarity, statistical tests are employed. The Kullback-Leibler (KL) difference serves as a measure to compare the similarity of a set of distributions. This involves converting distributions into their density functions, with the standard error serving as the bandwidth. The KL difference is calculated for each pair of distributions, as it is asymmetric. For the two distributions the KL difference is defined as following [@kullback1951kullback]:\n\\[\nD_{KL}(P \\, \\| \\, Q) = \\sum_i P(i) \\log\\left(\\frac{P(i)}{Q(i)}\\right)\n\\]\nTo obtain a symmetric score, the Jensen-Shannon Divergence (JSD) is utilized [@grosse2002analysis], expressed by the formula:\n\\[\nJS(P || Q) = \\frac{1}{2} * KL(P || M) + \\frac{1}{2} * KL(Q || M)\n\\] Here, \\(M = \\frac{1}{2} * (P + Q)\\). The JSD provides a balanced measure of dissimilarity between distributions [@Brownlee2019Calculate]. For comparing the different scores to each other, we will use averages.\nAdditionally, the Kolmogorov-Smirnov Test is implemented to assess whether two distributions significantly differ from each other. This statistical test offers a formal evaluation of the dissimilarity between empirical distribution functions."
  },
  {
    "objectID": "methods/preprocessing.html",
    "href": "methods/preprocessing.html",
    "title": "",
    "section": "",
    "text": "In this research study, the management and processing of a large dataset are crucial considerations. The dataset’s substantial size necessitates careful maintenance to ensure efficient handling. Furthermore, the data should be easily processable and editable to facilitate necessary corrections and precalculations within the context of our research objectives. To achieve our goals, we have implemented a framework that automatically derives data based on a shapefile, delineating areas of interest. The processed data and results of precalculations are stored in a straightforward manner to enhance accessibility. Additionally, we have designed functions that establish a user-friendly interface, enabling the execution of algorithms on subsets of the data, such as distinct species. These interfaces are not only directly callable by users but can also be integrated into other functions to automate processes. The overarching aim is to streamline the entire preprocessing workflow using a single script, leveraging only the shapefile as a basis. This subsection details the accomplishments of our R-package in realizing these goals, outlining the preprocessing steps undertaken and justifying their necessity in the context of our research.\nThe data are stored in a data subdirectory of the root directory in the format species/location-name/tile-name. To automate the matching of areas of interest with the catalog from the Land NRW1, we utilize the intersecting tool developed by Heisig2. This tool, allows for the automatic retrieval and placement of data downloaded from the Land NRW catalog. To enhance data accessibility, we have devised an object that incorporates species, location name, and tile name (the NRW internal identifier) for each area This object facilitates the specification of the area to be processed. Additionally, we have defined an initialization function that downloads all tiles, returning a list of tile location objects for subsequent processing. A pivotal component of the package’s preprocessing functionality is the map function, which iterates over a list of tile locations (effectively the entire dataset) and accepts a processing function as an argument. The subsequent paragraph outlines the specific preprocessing steps employed, all of which are implemented within the mapping function.\nTo facilitate memory-handling capabilities, each of the tiles, where one area can span multiple tiles, has been split into manageable chunks. We employed a 50x50m size for each tile, resulting in the division of original 1km x 1km files into 400 tiles. These tiles are stored in our directory structure, with each tile housed in a directory named after its tile name and assigned an id as the filename. Implementation-wise, the lidr::catalog_retile function was instrumental in achieving this segmentation. The resulting smaller chunks allow for efficient iteration during subsequent preprocessing steps.\nThe next phase involves reducing our data to the actual size by intersecting the tiles with the defined area of interest. Using the lidR::merge_spatial function, we intersect the area derived from the shapefile, removing all point cloud items outside this region. Due to our tile-wise approach, empty tiles may arise, and in such cases, those tiles are simply deleted.\nFollowing the size reduction to our dataset, the next step involves correcting the z values. The z values in the data are originally relative to the ellipsoid used for referencing, but we require them to be relative to the ground. To achieve this, we utilize the lidR::tin function, which extrapolates a convex hull between all ground points (classified by the data provider) and calculates the z value based on this structure.\nSubsequently, we aim to perform segmentation for each distinct tree, marking each item of the point cloud with a tree ID. We employ the algorithm described by @li2012, using parameters li2012(dt1 = 2, dt2 = 3, R = 2, Zu = 10, hmin = 5, speed_up = 12). The meanings of these parameters are elucidated in Li et al.’s work [@li2012].\nFinally, the last preprocessing step involves individual tree detection, seeking a single POINT object for each tree. The lidR::lmf function, an implementation of the tree data using a local maximum approach, is utilized for this purpose [@popescu2004]. The results are stored in GeoPackage files within our data structure.\nSee ?@sec-appendix-preprocessing for the implementation of the preprocessing."
  },
  {
    "objectID": "methods/preprocessing.html#preprocessing",
    "href": "methods/preprocessing.html#preprocessing",
    "title": "",
    "section": "",
    "text": "In this research study, the management and processing of a large dataset are crucial considerations. The dataset’s substantial size necessitates careful maintenance to ensure efficient handling. Furthermore, the data should be easily processable and editable to facilitate necessary corrections and precalculations within the context of our research objectives. To achieve our goals, we have implemented a framework that automatically derives data based on a shapefile, delineating areas of interest. The processed data and results of precalculations are stored in a straightforward manner to enhance accessibility. Additionally, we have designed functions that establish a user-friendly interface, enabling the execution of algorithms on subsets of the data, such as distinct species. These interfaces are not only directly callable by users but can also be integrated into other functions to automate processes. The overarching aim is to streamline the entire preprocessing workflow using a single script, leveraging only the shapefile as a basis. This subsection details the accomplishments of our R-package in realizing these goals, outlining the preprocessing steps undertaken and justifying their necessity in the context of our research.\nThe data are stored in a data subdirectory of the root directory in the format species/location-name/tile-name. To automate the matching of areas of interest with the catalog from the Land NRW1, we utilize the intersecting tool developed by Heisig2. This tool, allows for the automatic retrieval and placement of data downloaded from the Land NRW catalog. To enhance data accessibility, we have devised an object that incorporates species, location name, and tile name (the NRW internal identifier) for each area This object facilitates the specification of the area to be processed. Additionally, we have defined an initialization function that downloads all tiles, returning a list of tile location objects for subsequent processing. A pivotal component of the package’s preprocessing functionality is the map function, which iterates over a list of tile locations (effectively the entire dataset) and accepts a processing function as an argument. The subsequent paragraph outlines the specific preprocessing steps employed, all of which are implemented within the mapping function.\nTo facilitate memory-handling capabilities, each of the tiles, where one area can span multiple tiles, has been split into manageable chunks. We employed a 50x50m size for each tile, resulting in the division of original 1km x 1km files into 400 tiles. These tiles are stored in our directory structure, with each tile housed in a directory named after its tile name and assigned an id as the filename. Implementation-wise, the lidr::catalog_retile function was instrumental in achieving this segmentation. The resulting smaller chunks allow for efficient iteration during subsequent preprocessing steps.\nThe next phase involves reducing our data to the actual size by intersecting the tiles with the defined area of interest. Using the lidR::merge_spatial function, we intersect the area derived from the shapefile, removing all point cloud items outside this region. Due to our tile-wise approach, empty tiles may arise, and in such cases, those tiles are simply deleted.\nFollowing the size reduction to our dataset, the next step involves correcting the z values. The z values in the data are originally relative to the ellipsoid used for referencing, but we require them to be relative to the ground. To achieve this, we utilize the lidR::tin function, which extrapolates a convex hull between all ground points (classified by the data provider) and calculates the z value based on this structure.\nSubsequently, we aim to perform segmentation for each distinct tree, marking each item of the point cloud with a tree ID. We employ the algorithm described by @li2012, using parameters li2012(dt1 = 2, dt2 = 3, R = 2, Zu = 10, hmin = 5, speed_up = 12). The meanings of these parameters are elucidated in Li et al.’s work [@li2012].\nFinally, the last preprocessing step involves individual tree detection, seeking a single POINT object for each tree. The lidR::lmf function, an implementation of the tree data using a local maximum approach, is utilized for this purpose [@popescu2004]. The results are stored in GeoPackage files within our data structure.\nSee ?@sec-appendix-preprocessing for the implementation of the preprocessing."
  },
  {
    "objectID": "methods/preprocessing.html#footnotes",
    "href": "methods/preprocessing.html#footnotes",
    "title": "",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nhttps://www.opengeodata.nrw.de/produkte/geobasis/hm/3dm_l_las/3dm_l_las/, last visited 7th Dec 2023↩︎\nhttps://github.com/joheisig/GEDIcalibratoR, last visited 7th Dec 2023↩︎"
  },
  {
    "objectID": "report.html",
    "href": "report.html",
    "title": "Evaluating Tree Species Diversity in Forest Ecosystems Using LiDAR Data: A Exploration in NRW",
    "section": "",
    "text": "Forests, referred as the “world’s air-conditioning system” or the “lungs of the planet,” play a critical role in maintaining the global environment, as noted by King Charles III. Delving into forests and their diverse tree species is essential for our comprehension of both local ecosystems and the broader globe. The combination of tree species significantly contributes to the functionality and biodiversity of a forest, as emphasized by Mori et al. in their work on forest tree biodiversity (Mori, Lertzman, and Gustafsson 2017). Different tree species face distinct threats, posing challenges to both the environment and human populations. For instance, the Oak processionary moth, highlighted by Sobczyk et al, (Sobczyk 2014) in their study on the impact of the oak processionary moth, and the bark beetle, discussed in the work of Müller et al. on bark beetle infestations (Müller and Imhof 2019), exemplify the varying risks associated with specific tree types. Forests play a pivotal role in climate regulation by absorbing carbon dioxide (CO\\(_2\\)) and providing habitats for a multitude of animal and plant species. Approximately 80% of all terrestrial species find their home in forests, housing more than four-fifths of all known animal and plant species outside the oceans (n.d.). Recognizing the importance of gaining a comprehensive understanding of forests is imperative, particularly in unraveling the (spatial) distribution patterns of different tree species. Such insights are crucial for informed conservation efforts, sustainable management, and addressing the diverse ecological challenges that forests face.\nOften, forest monitoring relies on Sentinel data, offering valuable insights through various applications such as time series analysis of the deforestation process (Cremer et al. 2020), forest classification (Dostálová et al. 2021), and detection of forest succession (Szostak, Hawryło, and Piela 2018). However, employing Sentinel data is not without challenges. Dependency on cloud coverage and limited resolution, such as the \\(5\\times5\\)m resolution on Sentinel-1 (Agency 2024), can hinder the accurate identification of individual trees. To overcome these limitations, LiDAR data emerges as a promising alternative. LiDAR provides higher resolutions and utilizes the intensity of the returned signal as an indicator of the forest structure (Gonzalez). The aim is to investigate whether LiDAR is an appropriate tool for distinguishing between tree species, with a focus on oak, beech, pine, and spruce – the most common species in North Rhine-Westphalia (NRW). This choice ensures comparable environmental conditions, including climate and altitude.\nThe methodology involves employing different statistical tools to analyze the distribution of LiDAR returns. Specifically, the study utilizes the random forest algorithm to predict the species of detected trees based on LiDAR data. This approach aims to enhance the precision and capabilities of forest monitoring, especially in regions like NRW, by leveraging LiDAR technology for species-specific insights. Our motivation and methodical approach leading to the following research question:\nCan LiDAR technology be effectively employed to distinguish between tree species in monocultural forests in North Rhine-Westphalia (NRW), and how do the distinctive characteristics of individual tree species contribute to the accuracy of LiDAR-based classification?\nWe formulate the following hypothesis:\n\nLiDAR data can effectively differentiate between tree species in monocultural forests in NRW, and there are statistically significant differences in the LiDAR-derived metrics among the various tree species.\nRandom Forest classification can be used to predict the tree species of trees in monoculteral forests.\nRandom Forest classification performance varies significantly depending on the set of LiDAR parameters used, indicating that certain combinations of parameters contribute more effectively to accurate tree species classification."
  },
  {
    "objectID": "report.html#data-acquisition",
    "href": "report.html#data-acquisition",
    "title": "Evaluating Tree Species Diversity in Forest Ecosystems Using LiDAR Data: A Exploration in NRW",
    "section": "2.1 Data acquisition",
    "text": "2.1 Data acquisition\nOur primary objective is to identify patches where one tree species exhibits a high level of dominance, striving to capture monocultural stands within the diverse forests of Nordrhein-Westfalia (NRW). Recognizing the practical challenges of finding true monocultures, we aim to identify patches where one species is highly dominant, enabling meaningful comparisons across different species.\nThe study is framed within the NRW region due to the availability of an easily accessible dataset. Our focus includes four prominent tree species in NRW: oak, beech, spruce, and pine, representing the most prevalent species in the region. To ensure the validity of our findings, we derive three patches for each species, thereby confirming that observed variables are characteristic of a particular species rather than a specific patch. Each patch is carefully selected to encompass an area of approximately 10-50 hectares and contain between 500 and 5,000 trees. Striking a balance between relevance and manageability, these patches avoid excessive size to enhance the likelihood of capturing varied species mixes and ensure compatibility with local hardware.\nSpecific Goals:\n\nRetrieve patches with highly dominant tree species.\nMinimize or eliminate the presence of human-made structures within the selected patches.\n\nTo achieve our goals, we utilized the waldmonitor dataset (Welle et al. 2022) and the map provided by (Blickensdoerfer 2022), both indicating dominant tree species in NRW. We identified patches of feasible size where both sources predicted the presence of a specific species. Further validation involved examining sentinel images of these forest regions to assess the evenness of structures, leaf color distribution, and the absence of significant human-made structures such as roads or buildings. The subsequent preprocessing steps, detailed in the following subsection, involved refining our selected patches and deriving relevant variables, such as tree distribution and density, to ensure that the chosen areas align with the desired research domains."
  },
  {
    "objectID": "report.html#preprocessing",
    "href": "report.html#preprocessing",
    "title": "Evaluating Tree Species Diversity in Forest Ecosystems Using LiDAR Data: A Exploration in NRW",
    "section": "2.2 Preprocessing",
    "text": "2.2 Preprocessing\nIn this research study, the management and processing of a large dataset are crucial considerations. The dataset’s substantial size necessitates careful maintenance to ensure efficient handling. Furthermore, the data should be easily processable and editable to facilitate necessary corrections and precalculations within the context of our research objectives. To achieve our goals, we have implemented a framework that automatically derives data based on a shapefile, delineating areas of interest. The processed data and results of precalculations are stored in a straightforward manner to enhance accessibility. Additionally, we have designed functions that establish a user-friendly interface, enabling the execution of algorithms on subsets of the data, such as distinct species. These interfaces are not only directly callable by users but can also be integrated into other functions to automate processes. The overarching aim is to streamline the entire preprocessing workflow using a single script, leveraging only the shapefile as a basis. This subsection details the accomplishments of our R-package in realizing these goals, outlining the preprocessing steps undertaken and justifying their necessity in the context of our research.\nThe data are stored in a data subdirectory of the root directory in the format species/location-name/tile-name. To automate the matching of areas of interest with the catalog from the Land NRW1, we utilize the intersecting tool developed by Heisig2. This tool, allows for the automatic retrieval and placement of data downloaded from the Land NRW catalog. To enhance data accessibility, we have devised an object that incorporates species, location name, and tile name (the NRW internal identifier) for each area this object facilitates the specification of the area to be processed. Additionally, we have defined an initialization function that downloads all tiles, returning a list of tile location objects for subsequent processing. A pivotal component of the package’s preprocessing functionality is the map function, which iterates over a list of tile locations (effectively the entire dataset) and accepts a processing function as an argument. The subsequent paragraph outlines the specific preprocessing steps employed, all of which are implemented within the mapping function.\nTo facilitate memory-handling capabilities, each of the tiles, where one area can span multiple tiles, has been split into manageable chunks. We employed a \\(50\\times50\\)m size for each tile, resulting in the division of original \\(1\\times1\\)km files into 400 tiles. These tiles are stored in our directory structure, with each tile housed in a directory named after its tile name and assigned an id as the filename. Implementation-wise, the lidr::catalog_retile function was instrumental in achieving this segmentation. The resulting smaller chunks allow for efficient iteration during subsequent preprocessing steps.\nThe next phase involves reducing our data to the actual size by intersecting the tiles with the defined area of interest. Using the lidR::merge_spatial function, we intersect the area derived from the shapefile, removing all point cloud items outside this region. Due to our tile-wise approach, empty tiles may arise, and in such cases, those tiles are simply deleted.\nFollowing the size reduction to our dataset, the next step involves correcting the z values. The z values in the data are originally relative to the ellipsoid used for referencing, but we require them to be relative to the ground. To achieve this, we utilize the lidR::tin function, which extrapolates a convex hull between all ground points (classified by the data provider) and calculates the z value based on this structure.\nSubsequently, we aim to perform segmentation for each distinct tree, marking each item of the point cloud with a tree ID. We employ the algorithm described by Li et al. (2012), using parameters li2012(dt1 = 2, dt2 = 3, R = 2, Zu = 10, hmin = 5, speed_up = 12). The meanings of these parameters are elucidated in Li et al.’s work (Li et al. 2012).\nFinally, the last preprocessing step involves individual tree detection, seeking a single POINT object for each tree. The lidR::lmf function, an implementation of the tree data using a local maximum approach, is utilized for this purpose (Popescu and Wynne 2004). The results are stored in GeoPackage files within our data structure.\nSee Section 6.2 for the implementation of the preprocessing."
  },
  {
    "objectID": "report.html#analysis-of-different-distributions",
    "href": "report.html#analysis-of-different-distributions",
    "title": "Evaluating Tree Species Diversity in Forest Ecosystems Using LiDAR Data: A Exploration in NRW",
    "section": "2.3 Analysis of different distributions",
    "text": "2.3 Analysis of different distributions\nAnalysis of data distributions is a critical aspect of our research, with a focus on comparing two or more distributions. Our objective extends beyond evaluating the disparities between species; we also aim to assess differences within a species. To gain a comprehensive understanding of the data, we employ various visualization techniques, including histograms, density functions, and box plots.\nIn tandem with visualizations, descriptive statistics, such as means, standard errors, and quantiles, are leveraged to provide key insights into the central tendency and variability of the data.\nFor a more quantitative analysis of distribution dissimilarity, statistical tests are employed. The Kullback-Leibler (KL) difference serves as a measure to compare the similarity of a set of distributions. This involves converting distributions into their density functions, with the standard error serving as the bandwidth. The KL difference is calculated for each pair of distributions, as it is asymmetric. For the two distributions the KL difference is defined as following (Kullback 1951):\n\\[\nD_{KL}(P \\, \\| \\, Q) = \\sum_i P(i) \\log\\left(\\frac{P(i)}{Q(i)}\\right)\n\\]\nTo obtain a symmetric score, the Jensen-Shannon Divergence (JSD) is utilized (Grosse et al. 2002), expressed by the formula:\n\\[\nJS(P || Q) = \\frac{1}{2} * KL(P || M) + \\frac{1}{2} * KL(Q || M)\n\\] Here, \\(M = \\frac{1}{2} * (P + Q)\\). The JSD provides a balanced measure of dissimilarity between distributions (Brownlee 2019). For comparing the different scores to each other, we will use averages.\nAdditionally, the Kolmogorov-Smirnov Test is implemented to assess whether two distributions significantly differ from each other. This statistical test offers a formal evaluation of the dissimilarity between empirical distribution functions."
  },
  {
    "objectID": "report.html#researched-areas",
    "href": "report.html#researched-areas",
    "title": "Evaluating Tree Species Diversity in Forest Ecosystems Using LiDAR Data: A Exploration in NRW",
    "section": "3.1 Researched areas",
    "text": "3.1 Researched areas\n\n\nCode\nlibrary(ggplot2)\nsf::sf_use_s2(FALSE)\npatches &lt;- sf::read_sf(\"research_areas.shp\") |&gt; sf::st_centroid()\n\nde &lt;- sf::read_sf(\"results/results/states_de/Bundesländer_2017_mit_Einwohnerzahl.shp\") # Source: https://hub.arcgis.com/datasets/esri-de-content::bundesl%C3%A4nder-2017-mit-einwohnerzahl/explore?location=51.099647%2C10.454033%2C7.43\nnrw &lt;- de[5,] |&gt; sf::st_geometry()\n\n\nggplot() + geom_sf(data = nrw) + \n    geom_sf(data = patches, mapping = aes(col = species))\n\n\n\n\n\nFigure 1: Locations of the different patches with the dominant species for that patch. The patches centroids are displayed on a basemap describing the borders from NRW.\n\n\n\n\nWe draw three patches for each species from different regions (see Table 1). We download the LiDAR data for those patches and runned all preprocessing steps as described. We than checked with certain derived parameters (e.g. tree heights, tree distributions or tree density) that all patches contain valid forest data. In that step we discovered, that in one patch some forest clearance took place in the near past. This patch was removed from the dataset and was replaced with a new one.\nIn our research, drawing patches evenly distributed across Nordrhein-Westfalia is inherently constrained by natural factors. Consequently, the patches for oak and pine predominantly originate from the Münsterland region, as illustrated in Figure 1. For spruce, the patches were derived from Sauerland, reflecting the prevalence of spruce forests in this specific region within NRW, as corroborated by Welle et al. (Welle et al. 2022) and Blickensdörfer et al. (Blickensdoerfer 2022). Beech patches, on the other hand, were generated from diverse locations within NRW. Across all patches, no human-made objects were identified, with the exception of small paths for pedestrians and forestry vehicles.\nThe distribution of area and detections is notable for each four species. Beech covers 69,791.9 hectares with a total of 5,954 detections, oak spans 63,232.49 hectares with 5,354 detections, pine extends across 72,862.4 hectares with 8,912 detections, and spruce encompasses 57,940.02 hectares with 8,619 detections. Both the amount of detections and the corresponding area exhibit a relatively uniform distribution across the diverse patches, as summarized in Table 1.\nWith the selected dataset described, we intentionally chose three patches for each four species that exhibit a practical and usable size for our research objectives. These carefully chosen patches align with the conditions essential for our study, providing comprehensive and representative data for in-depth analysis and meaningful insights into the characteristics of each tree species within the specified areas.\n\n\nCode\nshp &lt;- sf::read_sf(\"research_areas.shp\")\ntable &lt;- lfa::lfa_get_all_areas()\n\nsf::sf_use_s2(FALSE)\nfor (row in 1:nrow(table)) {\n  area &lt;-\n    dplyr::filter(shp, shp$species == table[row, \"specie\"] &\n                    shp$name == table[row, \"area\"])\n  area_size &lt;- area |&gt; sf::st_area()\n  point &lt;- area |&gt; sf::st_centroid() |&gt; sf::st_coordinates()\n  table[row,\"point\"] &lt;- paste0(\"(\",round(point[1], digits = 4),\", \",round(point[2],digits = 4),\")\")\n  \n  table[row, \"area_size\"] = round(area_size,digits = 2) #paste0(round(area_size,digits = 2), \" m²\")\n  \n  amount_det &lt;- nrow(lfa::lfa_get_detection_area(table[row, \"specie\"], table[row, \"area\"]))\n  if(is.null(amount_det)){\n    cat(nrow(lfa::lfa_get_detection_area(table[row, \"specie\"], table[row, \"area\"])),table[row, \"specie\"],table[row, \"area\"])\n  }\n  table[row, \"amount_detections\"] = amount_det\n  \n  # table[row, \"specie\"] &lt;- lfa::lfa_capitalize_first_char(table[row,\"specie\"])\n  table[row, \"area\"] &lt;- lfa::lfa_capitalize_first_char(table[row,\"area\"])\n  }\ntable$area &lt;- gsub(\"_\", \" \", table$area)\ntable$area &lt;- gsub(\"ue\", \"ü\", table$area)\ntable = table[,!names(table) %in% c(\"specie\")]\n\nknitr::kable(table, \"html\", col.names = c(\"Patch Name\",\"Location\",\"Area size (m²)\",\"Amount tree detections\" ), caption = NULL, digits = 2, escape = TRUE) |&gt;\n  kableExtra::kable_styling(\n    bootstrap_options = c(\"striped\", \"hold_position\", \"bordered\",\"responsive\"),\n    stripe_index = c(1:3,7:9),\n    full_width = FALSE\n  ) |&gt;\n  kableExtra::pack_rows(\"Beech\", 1, 3) |&gt;\n  kableExtra::pack_rows(\"Oak\", 4, 6) |&gt;\n  kableExtra::pack_rows(\"Pine\", 7, 9) |&gt;\n  kableExtra::pack_rows(\"Spruce\", 10, 12) |&gt;\n  kableExtra::column_spec(1, bold = TRUE)\n\n\n\n\n\nTable 1: Summary of researched patches grouped by species, with their location, area and the amount of detected trees.\n\n\nPatch Name\nLocation\nArea size (m²)\nAmount tree detections\n\n\n\n\nBeech\n\n\nBielefeld brackwede\n(8.5244, 51.9902)\n161410.57\n1443\n\n\nBillerbeck\n(7.3273, 51.9987)\n185887.25\n1732\n\n\nWülfenrath\n(7.0769, 51.2917)\n350621.21\n2779\n\n\nOak\n\n\nHamm\n(7.8618, 51.6639)\n269397.22\n2441\n\n\nMünster\n(7.6187, 51.9174)\n164116.61\n1270\n\n\nRinkerode\n(7.6744, 51.8598)\n198811.09\n1643\n\n\nPine\n\n\nGreffen\n(8.1697, 51.9913)\n49418.81\n513\n\n\nMesum\n(7.5403, 52.2573)\n405072.85\n5031\n\n\nTelgte\n(7.7816, 52.0024)\n274132.34\n3368\n\n\nSpruce\n\n\nBrilon\n(8.5352, 51.4084)\n211478.20\n3342\n\n\nOberhundem\n(8.1861, 51.0909)\n151895.53\n2471\n\n\nOsterwald\n(8.3721, 51.2151)\n216026.43\n2806"
  },
  {
    "objectID": "report.html#sec-appendix-preprocessing",
    "href": "report.html#sec-appendix-preprocessing",
    "title": "Evaluating Tree Species Diversity in Forest Ecosystems Using LiDAR Data: A Exploration in NRW",
    "section": "6.2 Script which can be used to do all preprocessing",
    "text": "6.2 Script which can be used to do all preprocessing\nLoad the file with the research areas\n\nsf &lt;- sf::read_sf(here::here(\"research_areas.shp\"), quiet = TRUE)\n\nInit the project\n\nlibrary(lfa)\nsf::sf_use_s2(FALSE)\nlocations &lt;- lfa_init(\"research_areas.shp\")\n\nDo all of the preprocessing steps\n\n#lfa::lfa_map_tile_locations(locations, lfa::retile,check_flag = \"retile\")\n\n\nlfa::lfa_map_tile_locations(locations, lfa::lfa_intersect_areas, ctg = NULL, areas_sf = sf,check_flag = \"intersect\")\nlfa::lfa_map_tile_locations(locations, lfa::lfa_ground_correction, ctg = NULL,check_flag = \"z_correction\")\nlfa::lfa_map_tile_locations(locations, lfa::lfa_segmentation, ctg = NULL,check_flag = \"segmentation\")\nlfa::lfa_map_tile_locations(locations, lfa::lfa_detection, catalog = NULL, write_to_file = TRUE,check_flag = \"detection\")"
  },
  {
    "objectID": "report.html#documentation",
    "href": "report.html#documentation",
    "title": "Forest Data Analysis Report",
    "section": "6.3 Documentation",
    "text": "6.3 Documentation\n\n6.3.1 lfa_calculate_patch_density\nCalculate patch density for specified areas based on detection data\n\nArguments\n\n\n\n\n\n\n\nArgument\nDescription\n\n\n\n\nareas_location\nThe file path to a shapefile containing spatial polygons representing the areas for which patch density needs to be calculated. Default is “research_areas.shp”.\n\n\ndetections\nA data frame containing detection information, where each row represents a detection and includes the ‘area’ column specifying the corresponding area. Default is obtained using lfa_get_detections().\n\n\n\n\n\nDescription\nThis function calculates patch density for specified areas using detection data. It reads the spatial polygons from a shapefile, computes the area size for each patch, counts the number of detections in each patch, and calculates the patch density.\n\n\nValue\nA data frame with patch density information for each specified area. Columns include ‘name’ (area name), ‘geometry’ (polygon geometry), ‘area_size’ (patch area size), ‘detections’ (number of detections in the patch), and ‘density’ (computed patch density).\n\n\nExamples\n\n# Assuming you have a shapefile 'your_research_areas.shp' and detection data\n# from lfa_get_detections()\ndensity_data &lt;- lfa_calculate_patch_density(areas_location = \"your_research_areas.shp\")\nprint(density_data)\n\n\n\nUsage\n\nlfa_calculate_patch_density(\n  areas_location = \"research_areas.shp\",\n  detections = lfa::lfa_get_detections()\n)\n\n\n\n\n6.3.2 lfa_calculate_rf_metrics\nCalculate Precision and Recall Metrics for Random Forest Classification\n\nArguments\n\n\n\n\n\n\n\nArgument\nDescription\n\n\n\n\nconf_matrix\nConfusion matrix obtained from a Random Forest classification.\n\n\n\n\n\nDescription\nThis function calculates precision and recall metrics for each class based on the provided confusion matrix from a Random Forest classification.\n\n\nDetails\nThe function calculates precision and recall metrics for each class based on the confusion matrix obtained from a Random Forest classification.\n\n\nSeealso\nlfa_precision_per_class , lfa_recall_per_class\n\n\nValue\nA data frame containing precision and recall metrics for each class.\n\n\nExamples\n\n# Example confusion matrix from a Random Forest classification\nrf_cm &lt;- table(predicted = c(\"A\", \"B\", \"A\", \"B\"), actual = c(\"A\", \"A\", \"B\", \"B\"))\n# Calculate precision and recall metrics\nrf_metrics_df &lt;- lfa_calculate_rf_metrics(rf_cm)\n\n\n\nUsage\n\nlfa_calculate_rf_metrics(conf_matrix)\n\n\n\n\n6.3.3 lfa_capitalize_first_char\nCapitalize First Character of a String\n\nArguments\n\n\n\nArgument\nDescription\n\n\n\n\ninput_string\nA single-character string to be processed.\n\n\n\n\n\nConcept\nString Manipulation\n\n\nDescription\nThis function takes a string as input and returns the same string with the first character capitalized. If the first character is already capitalized, the function does nothing. If the first character is not from the alphabet, an error is thrown.\n\n\nDetails\nThis function performs the following steps:\n\nChecks if the input is a single-character string.\nVerifies if the first character is from the alphabet (A-Z or a-z).\nIf the first character is not already capitalized, it capitalizes it.\nReturns the modified string.\n\n\n\nKeyword\nalphabet\n\n\nNote\nThis function is case-sensitive and assumes ASCII characters.\n\n\nReferences\nNone\n\n\nSeealso\nThis function is related to the basic string manipulation functions in base R.\n\n\nValue\nA modified string with the first character capitalized if it is not already. If the first character is already capitalized, the original string is returned.\n\n\nExamples\n\n# Capitalize the first character of a string\ncapitalize_first_char(\"hello\") # Returns \"Hello\"\ncapitalize_first_char(\"World\") # Returns \"World\"\n\n# Error example (non-alphabetic first character)\ncapitalize_first_char(\"123abc\") # Throws an error\n\n\n\nUsage\n\nlfa_capitalize_first_char(input_string)\n\n\n\n\n6.3.4 lfa_check_flag\nCheck if a flag is set, indicating the completion of a specific process.\n\nArguments\n\n\n\n\n\n\n\nArgument\nDescription\n\n\n\n\nflag_name\nA character string specifying the name of the flag file. It should be a descriptive and unique identifier for the process being checked.\n\n\n\n\n\nDescription\nThis function checks for the existence of a hidden flag file at a specified location within the working directory. If the flag file is found, a message is printed, and the function returns TRUE to indicate that the associated processing step has already been completed. If the flag file is not found, the function returns FALSE , indicating that further processing can proceed.\n\n\nValue\nA logical value indicating whether the flag is set ( TRUE ) or not ( FALSE ).\n\n\nExamples\n\n# Check if the flag for a process named \"data_processing\" is set\nlfa_check_flag(\"data_processing\")\n\n\n\nUsage\n\nlfa_check_flag(flag_name)\n\n\n\n\n6.3.5 lfa_chm\nCreate Canopy Height Model (CHM) from Lidar Data\n\nArguments\n\n\n\n\n\n\n\nArgument\nDescription\n\n\n\n\nspecie\nCharacter string indicating the species name.\n\n\narea\nCharacter string indicating the specific area or location.\n\n\nres\nNumeric value indicating the spatial resolution of the CHM. Default is 0.5.\n\n\nsave_to_file\nLogical. If TRUE, the generated CHM will be saved to a GeoTIFF file. Default is TRUE.\n\n\noverwrite\nLogical. If TRUE, existing CHM file will be overwritten. Default is FALSE.\n\n\n...\nAdditional arguments to be passed to the underlying functions, such as lidR::catalog_map.\n\n\n\n\n\nDescription\nThis function generates a Canopy Height Model (CHM) from Lidar data using the lidR package.\n\n\nDetails\nThe behavior of the function with different input parameters is as follows:\n\nWhen a CHM file already exists at the specified path and overwrite is FALSE, the function loads the existing CHM and returns it.\nIf the CHM file does not exist or overwrite is TRUE, the function processes Lidar data using lfa_rasterize_chunk and creates a CHM.\nThe spatial resolution of the CHM can be controlled with the res parameter.\nIf save_to_file is TRUE, the generated CHM will be saved to a GeoTIFF file.\n\n\n\nSeealso\nlfa_read_area_as_catalog , catalog_map , terra::rast , terra::writeRaster\n\n\nValue\nA raster layer representing the Canopy Height Model (CHM).\n\n\nExamples\n\n# Generate CHM for a specific species and area\nchm &lt;- lfa_chm(specie = \"ExampleSpecies\", area = \"ExampleArea\", res = 1.0)\n\n# Generate CHM and save it to a file\nchm &lt;- lfa_chm(specie = \"ExampleSpecies\", area = \"ExampleArea\", res = 1.0, save_to_file = TRUE)\n\n\n\nUsage\n\nlfa_chm(specie, area, res = 0.5, save_to_file = TRUE, overwrite = FALSE, ...)\n\n\n\n\n6.3.6 lfa_combine_sf_obj\nCombine Spatial Feature Objects from Multiple GeoPackage Files\n\nArguments\n\n\n\n\n\n\n\nArgument\nDescription\n\n\n\n\npaths\nA character vector containing file paths to GeoPackage files with neighbor information.\n\n\narea_infos\nA data frame or list containing information about the corresponding detection areas, including “area” and “specie” columns.\n\n\n\n\n\nDescription\nThis function reads spatial feature objects (sf) from multiple GeoPackage files and combines them into a single sf object. Each GeoPackage file is assumed to contain neighbor information for a specific detection area, and the resulting sf object includes additional columns indicating the corresponding area and species information.\n\n\nValue\nA combined sf object with additional columns for area and specie information.\n\n\nExamples\n\n# Assuming paths and area_infos are defined\ncombined_sf &lt;- lfa_combine_sf_obj(paths, area_infos)\n\n# Print the combined sf object\nprint(combined_sf)\n\n\n\nUsage\n\nlfa_combine_sf_obj(paths, area_infos)\n\n\n\n\n6.3.7 lfa_count_returns_all_areas\nCount tree returns for all species and areas, returning a consolidated data frame.\n\nDescription\nThis function iterates through all species and areas obtained from the function lfa_get_all_areas . For each combination of species and area, it reads the corresponding area as a catalog, counts the returns per tree using lfa_count_returns_per_tree , and consolidates the results into a data frame. The resulting data frame includes columns for the species, area, and return counts per tree.\n\n\nKeyword\ncounting\n\n\nSeealso\nlfa_get_all_areas , lfa_read_area_as_catalog , lfa_count_returns_per_tree\n\n\nValue\nA data frame with columns for species, area, and return counts per tree.\n\n\nExamples\n\n# Count tree returns for all species and areas\nreturns_counts &lt;- lfa_count_returns_all_areas()\n\n\n\nUsage\n\nlfa_count_returns_all_areas()\n\n\n\n\n6.3.8 lfa_count_returns_per_tree\nCount returns per tree for a given lidR catalog.\n\nArguments\n\n\n\n\n\n\n\nArgument\nDescription\n\n\n\n\nctg\nA lidR catalog object containing LAS files to be processed.\n\n\n\n\n\nDescription\nThis function takes a lidR catalog as input and counts the returns per tree. It uses the lidR package to read LAS files from the catalog and performs the counting operation on each tree. The result is a data frame containing the counts of returns for each unique tree ID within the lidR catalog.\n\n\nKeyword\ncounting\n\n\nSeealso\nlidR::readLAS , lidR::is.empty , base::table , dplyr::bind_rows\n\n\nValue\nA data frame with columns for tree ID and the corresponding count of returns.\n\n\nExamples\n\n# Count returns per tree for a lidR catalog\nctg &lt;- lfa_read_area_as_catalog(\"SpeciesA\", \"Area1\")\nreturns_counts_per_tree &lt;- lfa_count_returns_per_tree(ctg)\n\n\n\nUsage\n\nlfa_count_returns_per_tree(ctg)\n\n\n\n\n6.3.9 lfa_create_boxplot\nCreate a box plot from a data frame\n\nArguments\n\n\n\n\n\n\n\nArgument\nDescription\n\n\n\n\ndata\nA data frame containing the data.\n\n\nvalue_column\nThe name of the column containing the values for the box plot.\n\n\ncategory_column1\nThe name of the column containing the first categorical variable.\n\n\ncategory_column2\nThe name of the column containing the second categorical variable.\n\n\ntitle\nAn optional title for the plot. If not provided, a default title is generated based on the data frame name.\n\n\n\n\n\nDescription\nThis function generates a box plot using ggplot2 based on the specified data frame and columns.\n\n\nDetails\nThe function creates a box plot where the x-axis is based on the second categorical variable, the y-axis is based on the specified value column, and the box plots are colored based on the first categorical variable. The grouping of box plots is done based on the unique values in the second categorical variable.\n\n\nValue\nA ggplot object representing the box plot.\n\n\nExamples\n\n# Assuming you have a data frame 'your_data' with columns 'value', 'category1', and 'category2'\ncreate_boxplot(your_data, \"value\", \"category1\", \"category2\")\n\n\n\nUsage\n\nlfa_create_boxplot(\n  data,\n  value_column,\n  category_column1,\n  category_column2,\n  title = NULL\n)\n\n\n\n\n6.3.10 lfa_create_density_plots\nCreate density plots for groups in a data frame\n\nArguments\n\n\n\n\n\n\n\nArgument\nDescription\n\n\n\n\ndata\nA data frame containing the data.\n\n\nvalue_column\nThe name of the column containing the values for the density plot.\n\n\ncategory_column1\nThe name of the column containing the categorical variable for grouping.\n\n\ncategory_column2\nThe name of the column containing the categorical variable for arranging plots.\n\n\ntitle\nAn optional title for the plot. If not provided, a default title is generated based on the data frame name.\n\n\nxlims\nOptional limits for the x-axis. Should be a numeric vector with two elements (lower and upper bounds).\n\n\nylims\nOptional limits for the y-axis. Should be a numeric vector with two elements (lower and upper bounds).\n\n\n\n\n\nDescription\nThis function generates density plots using ggplot2 based on the specified data frame and columns.\n\n\nDetails\nThe function creates density plots where the x-axis is based on the specified value column, and the density plots are colored based on the first categorical variable. The arrangement of plots is done based on the unique values in the second categorical variable. The plots are arranged in a 2x2 grid.\n\n\nValue\nA ggplot object representing the density plots arranged in a 2x2 grid.\n\n\nExamples\n\n# Assuming you have a data frame 'your_data' with columns 'value', 'category1', and 'category2'\ncreate_density_plots(your_data, \"value\", \"category1\", \"category2\", title = \"Density Plots\", xlims = c(0, 10), ylims = c(0, 0.5))\n\n\n\nUsage\n\nlfa_create_density_plots(\n  data,\n  value_column,\n  category_column1 = \"area\",\n  category_column2 = \"specie\",\n  title = NULL,\n  xlims = NULL,\n  ylims = NULL\n)\n\n\n\n\n6.3.11 lfa_create_grouped_bar_plot\nCreate a barplot using ggplot2\n\nArguments\n\n\n\n\n\n\n\nArgument\nDescription\n\n\n\n\nxlab\nLabel for x-Axis.\n\n\nylab\nLabel for y-Axis.\n\n\ntitle\nTitle of the plot.\n\n\ndf\nA data frame containing the relevant columns for the barplot.\n\n\nvalue_column\nThe column containing the values to be plotted.\n\n\nlabel_column\nThe column used for labeling the bars on the x-axis. Default is “name”.\n\n\ngrouping_column\nThe column used for grouping the bars. Default is “species”.\n\n\n\n\n\nDescription\nThis function generates a barplot using ggplot2 based on the specified data frame columns. The barplot displays the values from the specified column, grouped by another column. The grouping can be further differentiated by color if desired.\n\n\nValue\nA ggplot2 barplot.\n\n\nExamples\n\n# Assuming you have a data frame 'your_data_frame' with columns \"name\", \"species\", and \"value\"\nlfa_create_barplot(your_data_frame, value_column = \"value\", label_column = \"name\", grouping_column = \"species\")\n\n\n\nUsage\n\nlfa_create_grouped_bar_plot(\n  data,\n  grouping_var,\n  value_col,\n  label_col,\n  xlab = \"Name of Patch\",\n  ylab = \"Density\",\n  title = \"Tree density across the different patches, grouped by specie\"\n)\n\n\n\n\n6.3.12 lfa_create_neighbor_mean_curves\nCreate neighbor mean curves for specified areas\n\nArguments\n\n\n\n\n\n\n\nArgument\nDescription\n\n\n\n\nneighbors\nA data frame containing information about neighbors, where each column represents a specific neighbor, and each row corresponds to an area.\n\n\nuse_avg\nLogical. If TRUE, the function computes average curves across all neighbors. If FALSE, it computes curves for individual neighbors.\n\n\n\n\n\nDescription\nThis function generates mean curves for a specified set of areas based on neighbor data. The user can choose to compute mean curves for individual neighbors or averages across neighbors.\n\n\nValue\nA data frame with mean curves for each specified area. Columns represent areas, and rows represent index values.\n\n\nExamples\n\n# Assuming you have a data frame 'your_neighbors_data' with neighbor information\nmean_curves &lt;- lfa_create_neighbor_mean_curves(your_neighbors_data, use_avg = TRUE)\nprint(mean_curves)\n\n\n\nUsage\n\nlfa_create_neighbor_mean_curves(neighbors, use_avg = FALSE)\n\n\n\n\n6.3.13 lfa_create_plot_per_area\nCreate a line plot per area with one color per specie\n\nArguments\n\n\n\n\n\n\n\nArgument\nDescription\n\n\n\n\ndata\nA data frame with numeric columns and a column named ‘specie’ for species information.\n\n\n\n\n\nDescription\nThis function takes a data frame containing numeric columns and creates a line plot using ggplot2. Each line in the plot represents a different area, with one color per specie.\n\n\nValue\nA ggplot2 line plot.\n\n\nExamples\n\ndata &lt;- data.frame(\nspecie = rep(c(\"Species1\", \"Species2\", \"Species3\"), each = 10),\ncolumn1 = rnorm(30),\ncolumn2 = rnorm(30),\ncolumn3 = rnorm(30)\n)\nlfa_create_plot_per_area(data)\n\n\n\nUsage\n\nlfa_create_plot_per_area(data)\n\n\n\n\n6.3.14 lfa_create_ppp_from_area\nCreate a point pattern from tree detections in a specified area for a given species.\n\nArguments\n\n\n\n\n\n\n\nArgument\nDescription\n\n\n\n\nspecies_identifier\nA character string specifying the target species for which the point pattern is to be generated.\n\n\narea_identifier\nA character string specifying the target area for which the point pattern is to be generated.\n\n\n\n\n\nDescription\nThis function generates a point pattern from tree detections for a specific species within a defined area. It filters the detections using the provided species_identifier and area_identifier parameters. The area is defined by a shapefile named “research_areas.shp,” and the resulting point pattern is created within the specified area.\n\n\nKeyword\ndata\n\n\nSeealso\nlfa_get_detections , sf::st_transform , sf::st_union , spatstat.geom::as.owin , spatstat.geom::as.ppp\n\n\nValue\nA point pattern representing tree detections for the specified species within the defined area.\n\n\nExamples\n\nlfa_create_ppp_from_area(species_identifier = \"SpeciesA\", area_identifier = \"Area1\")\n\n# Create a point pattern for a specific species in a given area\npp &lt;- lfa_create_ppp_from_area(species_identifier = \"SpeciesA\", area_identifier = \"Area1\")\n\n\n\nUsage\n\nlfa_create_ppp_from_area(species_identifier, area_identifier)\n\n\n\n\n6.3.15 lfa_create_stacked_distributions_plot\nCreate a stacked distribution plot for tree detections, visualizing the distribution of a specified variable on the x-axis, differentiated by another variable.\n\nArguments\n\n\n\n\n\n\n\nArgument\nDescription\n\n\n\n\ntrees\nA data frame containing tree detection data.\n\n\nx_value\nA character string specifying the column name used for finding the values on the x-axis of the histogram.\n\n\nfill_value\nA character string specifying the column name by which the data are differentiated in the plot.\n\n\nbin\nAn integer specifying the number of bins for the histogram. Default is 100.\n\n\nylab\nA character string specifying the y-axis label. Default is “Amount trees.”\n\n\nxlim\nA numeric vector of length 2 specifying the x-axis limits. Default is c(0, 100).\n\n\nylim\nA numeric vector of length 2 specifying the y-axis limits. Default is c(0, 1000).\n\n\ntitle\nThe title of the plot.\n\n\n\n\n\nDescription\nThis function generates a stacked distribution plot using the ggplot2 package, providing a visual representation of the distribution of a specified variable ( x_value ) on the x-axis, with differentiation based on another variable ( fill_value ). The data for the plot are derived from the provided trees data frame.\n\n\nKeyword\ndata\n\n\nSeealso\nggplot2::geom_histogram , ggplot2::facet_wrap , ggplot2::ylab , ggplot2::scale_fill_brewer , ggplot2::coord_cartesian\n\n\nValue\nA ggplot object representing the stacked distribution plot.\n\n\nExamples\n\n# Create a stacked distribution plot for variable \"Z,\" differentiated by \"area\"\ntrees &lt;- lfa_get_detections()\nlfa_create_stacked_distributions_plot(trees, \"Z\", \"area\")\n\n\n\nUsage\n\nlfa_create_stacked_distributions_plot(\n  trees,\n  x_value,\n  fill_value,\n  bin = 100,\n  ylab = \"Amount trees\",\n  xlim = c(0, 100),\n  ylim = c(0, 1000),\n  title =\n    \"Histograms of height distributions between species 'beech', 'oak', 'pine' and 'spruce' divided by the different areas of Interest\"\n)\n\n\n\n\n6.3.16 lfa_create_stacked_histogram\nCreate a stacked histogram for tree detections, summing up the values for each species.\n\nArguments\n\n\n\n\n\n\n\nArgument\nDescription\n\n\n\n\ntrees\nA data frame containing tree detection data.\n\n\nx_value\nA character string specifying the column name used for finding the values on the x-axis of the histogram.\n\n\nfill_value\nA character string specifying the column name by which the data are differentiated in the plot.\n\n\nbin\nAn integer specifying the number of bins for the histogram. Default is 30.\n\n\nylab\nA character string specifying the y-axis label. Default is “Frequency.”\n\n\nxlim\nA numeric vector of length 2 specifying the x-axis limits. Default is c(0, 100).\n\n\nylim\nA numeric vector of length 2 specifying the y-axis limits. Default is NULL.\n\n\n\n\n\nDescription\nThis function generates a stacked histogram using the ggplot2 package, summing up the values for each species and visualizing the distribution of a specified variable ( x_value ) on the x-axis, differentiated by another variable ( fill_value ). The data for the plot are derived from the provided trees data frame.\n\n\nKeyword\ndata\n\n\nSeealso\nggplot2::geom_histogram , ggplot2::ylab , ggplot2::scale_fill_brewer , ggplot2::coord_cartesian\n\n\nValue\nA ggplot object representing the stacked histogram.\n\n\nExamples\n\n# Create a stacked histogram for variable \"Z,\" differentiated by \"area\"\ntrees &lt;- lfa_get_detections()\nlfa_create_stacked_histogram(trees, \"Z\", \"area\")\n\n\n\nUsage\n\nlfa_create_stacked_histogram(\n  trees,\n  x_value,\n  fill_value,\n  bin = 30,\n  ylab = \"Frequency\",\n  xlim = c(0, 100),\n  ylim = NULL\n)\n\n\n\n\n6.3.17 lfa_create_tile_location_objects\nCreate tile location objects\n\nAuthor\nJakob Danel\n\n\nDescription\nThis function traverses a directory structure to find LAZ files and creates tile location objects for each file. The function looks into the the data directory of the repository/working directory. It then creates tile_location objects based on the folder structure. The folder structure should not be touched by hand, but created by lfa_init_data_structure() which builds the structure based on a shape file.\n\n\nSeealso\ntile_location\n\n\nValue\nA vector containing tile location objects.\n\n\nExamples\n\nlfa_create_tile_location_objects()\n\nlfa_create_tile_location_objects()\n\n\n\nUsage\n\nlfa_create_tile_location_objects()\n\n\n\n\n6.3.18 lfa_detection\nPerform tree detection on a lidar catalog and optionally save the results to a file.\n\nArguments\n\n\n\n\n\n\n\nArgument\nDescription\n\n\n\n\ncatalog\nA lidar catalog containing point cloud data. If set to NULL, the function attempts to read the catalog from the specified tile location.\n\n\ntile_location\nAn object specifying the location of the lidar tile. If catalog is NULL, the function attempts to read the catalog from this tile location.\n\n\nwrite_to_file\nA logical value indicating whether to save the detected tree information to a file. Default is TRUE.\n\n\n\n\n\nDescription\nThis function utilizes lidar data to detect trees within a specified catalog. The detected tree information can be optionally saved to a file in the GeoPackage format. The function uses parallel processing to enhance efficiency.\n\n\nValue\nA sf style data frame containing information about the detected trees.\n\n\nExamples\n\n# Perform tree detection on a catalog and save the results to a file\nlfa_detection(catalog = my_catalog, tile_location = my_tile_location, write_to_file = TRUE)\n\n\n\nUsage\n\nlfa_detection(catalog, tile_location, write_to_file = TRUE)\n\n\n\n\n6.3.19 lfa_download_areas\nDownload areas based on spatial features\n\nArguments\n\n\n\n\n\n\n\nArgument\nDescription\n\n\n\n\nsf_areas\nSpatial features representing areas to be downloaded. It must include columns like “species” “name” See details for more information.\n\n\n\n\n\nAuthor\nJakob Danel\n\n\nDescription\nThis function initiates the data structure and downloads areas based on spatial features.\n\n\nDetails\nThe input data frame, sf_areas , must have the following columns:\n\n“species”: The species associated with the area.\n“name”: The name of the area.\n\nThe function uses the lfa_init_data_structure function to set up the data structure and then iterates through the rows of sf_areas to download each specified area.\n\n\nValue\nNone\n\n\nExamples\n\nlfa_download_areas(sf_areas)\n\n\n# Example spatial features data frame\nsf_areas &lt;- data.frame(\nspecies = c(\"SpeciesA\", \"SpeciesB\"),\nname = c(\"Area1\", \"Area2\"),\n# Must include also other attributes specialized to sf objects\n# such as geometry, for processing of the download\n)\n\nlfa_download_areas(sf_areas)\n\n\n\nUsage\n\nlfa_download_areas(sf_areas)\n\n\n\n\n6.3.20 lfa_download\nDownload an las file from the state NRW from a specific location\n\nArguments\n\n\n\n\n\n\n\nArgument\nDescription\n\n\n\n\nspecies\nThe species of the tree which is observed at this location\n\n\nname\nThe name of the area that is observed\n\n\nlocation\nAn sf object, which holds the location information for the area where the tile should be downloaded from.\n\n\n\n\n\nDescription\nIt will download the file and save it to data/ list(list(“html”), list(list(“”))) / list(list(“html”), list(list(“”))) with the name of the tile\n\n\nValue\nThe LASCatalog object of the downloaded file\n\n\nUsage\n\nlfa_download(species, name, location)\n\n\n\n\n6.3.21 lfa_find_n_nearest_trees\nFind n Nearest Trees\n\nArguments\n\n\n\n\n\n\n\nArgument\nDescription\n\n\n\n\ntrees\nA sf object containing tree coordinates.\n\n\nn\nThe number of nearest trees to find for each tree (default is 100).\n\n\n\n\n\nDescription\nThis function calculates the distances to the n nearest trees for each tree in the input dataset.\n\n\nValue\nA data frame with additional columns representing the distances to the n nearest trees.\n\n\nExamples\n\n# Load tree data using lfa_get_detections() (not provided)\ntree_data &lt;- lfa_get_detections()\n\n# Filter tree data for a specific species and area\ntree_data = tree_data[tree_data$specie == \"pine\" & tree_data$area == \"greffen\", ]\n\n# Find the 100 nearest trees for each tree in the filtered dataset\ntree_data &lt;- lfa_find_n_nearest_trees(tree_data)\n\n\n\nUsage\n\nlfa_find_n_nearest_trees(trees, n = 100)\n\n\n\n\n6.3.22 lfa_generate_result_table_tests\nGenerate Result Table for Tests\n\nArguments\n\n\n\nArgument\nDescription\n\n\n\n\ntable\nA data frame representing the result table.\n\n\n\n\n\nDescription\nThis function generates a result table for tests using the knitr::kable function.\n\n\nDetails\nThis function uses the knitr::kable function to create a formatted table, making it suitable for HTML output. The input table is expected to be a data frame with test results, and the resulting table will have capitalized row and column names with lines between columns and rows.\n\n\nValue\nA formatted table suitable for HTML output with lines between columns and rows.\n\n\nExamples\n\n# Generate a result table for tests\nresult_table &lt;- data.frame(\nTest1 = c(0.05, 0.10, 0.03),\nTest2 = c(0.02, 0.08, 0.01),\nTest3 = c(0.08, 0.12, 0.05)\n)\nformatted_table &lt;- lfa_generate_result_table_tests(result_table)\nprint(formatted_table)\n\n\n\nUsage\n\nlfa_generate_result_table_tests(table, caption = \"Table Caption\")\n\n\n\n\n6.3.23 lfa_get_all_areas\nRetrieve a data frame containing all species and corresponding areas.\n\nDescription\nThis function scans the “data” directory within the current working directory to obtain a list of species. It then iterates through each species to retrieve the list of areas associated with that species. The resulting data frame contains two columns: “specie” representing the species and “area” representing the corresponding area.\n\n\nKeyword\ndata\n\n\nSeealso\nlist.dirs\n\n\nValue\nA data frame with columns “specie” and “area” containing information about all species and their associated areas.\n\n\nExamples\n\n# Retrieve a data frame with information about all species and areas\nall_areas_df &lt;- lfa_get_all_areas()\n\n\n\nUsage\n\nlfa_get_all_areas()\n\n\n\n\n6.3.24 lfa_get_detection_area\nGet Detection for an area\n\nArguments\n\n\n\nArgument\nDescription\n\n\n\n\nspecies\nA character string specifying the target species.\n\n\nname\nA character string specifying the name of the tile.\n\n\n\n\n\nDescription\nRetrieves the tree detection information for a specified species and tile.\n\n\nDetails\nThis function reads tree detection data from geopackage files within the specified tile location for a given species. It then combines the data into a single SF data frame and returns it. The function assumes that the tree detection files follow a naming convention with the pattern “_detection.gpkg”.\n\n\nKeyword\nspatial\n\n\nReferences\nThis function is part of the LiDAR Forest Analysis (LFA) package.\n\n\nSeealso\nget_tile_dir\n\n\nValue\nA Simple Features (SF) data frame containing tree detection information for the specified species and tile.\n\n\nExamples\n\n# Retrieve tree detection data for species \"example_species\" in tile \"example_tile\"\ntrees_data &lt;- lfa_get_detection_tile_location(\"example_species\", \"example_tile\")\n\n# Example usage:\ntrees_data &lt;- lfa_get_detection_tile_location(\"example_species\", \"example_tile\")\n\n# No trees found scenario:\nempty_data &lt;- lfa_get_detection_tile_location(\"nonexistent_species\", \"nonexistent_tile\")\n# The result will be an empty data frame if no trees are found for the specified species and tile.\n\n# Error handling:\n# In case of invalid inputs, the function may throw errors. Ensure correct species and tile names are provided.\n\n\n\nUsage\n\nlfa_get_detection_area(species, name)\n\n\n\n\n6.3.25 lfa_get_detections_species\nRetrieve detections for a specific species.\n\nArguments\n\n\n\nArgument\nDescription\n\n\n\n\nspecies\nA character string specifying the target species.\n\n\n\n\n\nDescription\nThis function retrieves detection data for a given species from multiple areas.\n\n\nDetails\nThe function looks for detection data in the “data” directory for the specified species. It then iterates through each subdirectory (representing different areas) and consolidates the detection data into a single data frame.\n\n\nValue\nA data frame containing detection information for the specified species in different areas.\n\n\nExamples\n\n# Example usage:\ndetections_data &lt;- lfa_get_detections_species(\"example_species\")\n\n\n\nUsage\n\nlfa_get_detections_species(species)\n\n\n\n\n6.3.26 lfa_get_detections\nRetrieve aggregated detection data for multiple species.\n\nConcept\ndata retrieval functions\n\n\nDescription\nThis function obtains aggregated detection data for multiple species by iterating through the list of species obtained from lfa_get_species . For each species, it calls lfa_get_detections_species to retrieve the corresponding detection data and aggregates the results into a single data frame. The resulting data frame includes columns for the species, tree detection data, and the area in which the detections occurred.\n\n\nKeyword\naggregation\n\n\nSeealso\nlfa_get_species , lfa_get_detections_species\nOther data retrieval functions: lfa_get_species\n\n\nValue\nA data frame containing aggregated detection data for multiple species.\n\n\nExamples\n\nlfa_get_detections()\n\n# Retrieve aggregated detection data for multiple species\ndetections_data &lt;- lfa_get_detections()\n\n\n\nUsage\n\nlfa_get_detections()\n\n\n\n\n6.3.27 lfa_get_flag_path\nGet the path to a flag file indicating the completion of a specific process.\n\nArguments\n\n\n\n\n\n\n\nArgument\nDescription\n\n\n\n\nflag_name\nA character string specifying the name of the flag file. It should be a descriptive and unique identifier for the process being flagged.\n\n\n\n\n\nDescription\nThis function constructs and returns the path to a hidden flag file, which serves as an indicator that a particular processing step has been completed. The flag file is created in a designated location within the working directory.\n\n\nValue\nA character string representing the absolute path to the hidden flag file.\n\n\nExamples\n\n# Get the flag path for a process named \"data_processing\"\nlfa_get_flag_path(\"data_processing\")\n\n\n\nUsage\n\nlfa_get_flag_path(flag_name)\n\n\n\n\n6.3.28 lfa_get_neighbor_paths\nGet Paths to Neighbor GeoPackage Files\n\nDescription\nThis function retrieves the file paths to GeoPackage files containing neighbor information for each detection area. The GeoPackage files are assumed to be named “neighbours.gpkg” and organized in a directory structure under the “data” folder.\n\n\nValue\nA character vector containing file paths to GeoPackage files for each detection area’s neighbors.\n\n\nExamples\n\n# Get paths to neighbor GeoPackage files for all areas\npaths &lt;- lfa_get_neighbor_paths()\n\n# Print the obtained file paths\nprint(paths)\n\n\n\nUsage\n\nlfa_get_neighbor_paths()\n\n\n\n\n6.3.29 lfa_get_species\nGet a list of species from the data directory.\n\nConcept\ndata retrieval functions\n\n\nDescription\nThis function retrieves a list of species by scanning the “data” directory located in the current working directory.\n\n\nKeyword\ndata\n\n\nReferences\nThis function relies on the list.dirs function for directory listing.\n\n\nSeealso\nlist.dirs\nOther data retrieval functions: lfa_get_detections\n\n\nValue\nA character vector containing the names of species found in the “data” directory.\n\n\nExamples\n\n# Retrieve the list of species\nspecies_list &lt;- lfa_get_species()\n\n\n\nUsage\n\nlfa_get_species()\n\n\n\n\n6.3.30 lfa_ground_correction\nCorrect the point clouds for correct ground imagery\n\nArguments\n\n\n\n\n\n\n\nArgument\nDescription\n\n\n\n\nctg\nAn LASCatalog object. If not null, it will perform the actions on this object, if NULL inferring the catalog from the tile_location\n\n\ntile_location\nA tile_location type object holding the information about the location of the cataog. This is used to save the catalog after processing too.\n\n\n\n\n\nAuthor\nJakob Danel\n\n\nDescription\nThis function is needed to correct the Z value of the point cloud, relative to the real ground height. After using this function to your catalog, the Z values can be seen as the real elevation about the ground. At the moment the function uses the tin() function from the lidr package. NOTE : The operation is inplace and can not be reverted, the old values of the point cloud will be deleted!\n\n\nValue\nA catalog with the corrected z values. The catalog is always stored at tile_location and holding only the transformed values.\n\n\nUsage\n\nlfa_ground_correction(ctg, tile_location)\n\n\n\n\n6.3.31 lfa_init_data_structure\nInitialize data structure for species and areas\n\nArguments\n\n\n\n\n\n\n\nArgument\nDescription\n\n\n\n\nsf_species\nA data frame with information about species and associated areas.\n\n\n\n\n\nDescription\nThis function initializes the data structure for storing species and associated areas.\n\n\nDetails\nThe input data frame, sf_species , should have at least the following columns:\n\n“species”: The names of the species for which the data structure needs to be initialized.\n“name”: The names of the associated areas.\n\nThe function creates directories based on the species and area information provided in the sf_species data frame. It checks whether the directories already exist and creates them if they don’t.\n\n\nValue\nNone\n\n\nExamples\n\n# Example species data frame\nsf_species &lt;- data.frame(\nspecies = c(\"SpeciesA\", \"SpeciesB\"),\nname = c(\"Area1\", \"Area2\"),\n# Other necessary columns\n)\n\nlfa_init_data_structure(sf_species)\n\n# Example species data frame\nsf_species &lt;- data.frame(\nspecies = c(\"SpeciesA\", \"SpeciesB\"),\nname = c(\"Area1\", \"Area2\"),\n# Other necessary columns\n)\n\nlfa_init_data_structure(sf_species)\n\n\n\nUsage\n\nlfa_init_data_structure(sf_species)\n\n\n\n\n6.3.32 lfa_init\nInitialize LFA (LiDAR forest analysis) data processing\n\nArguments\n\n\n\n\n\n\n\nArgument\nDescription\n\n\n\n\nsf_file\nA character string specifying the path to the shapefile containing spatial features of research areas.\n\n\n\n\n\nDescription\nThis function initializes the LFA data processing by reading a shapefile containing spatial features of research areas, downloading the specified areas, and creating tile location objects for each area.\n\n\nDetails\nThis function reads a shapefile ( sf_file ) using the sf package, which should contain information about research areas. It then calls the lfa_download_areas function to download the specified areas and lfa_create_tile_location_objects to create tile location objects based on Lidar data files in those areas. The shapefile MUST follow the following requirements:\n\nEach geometry must be a single object of type polygon\nEach entry must have the following attributes:\nspecies: A string describing the tree species of the area.\nname: A string describing the location of the area.\n\n\n\nValue\nA vector containing tile location objects.\n\n\nExamples\n\n# Initialize LFA processing with the default shapefile\nlfa_init()\n\n# Initialize LFA processing with a custom shapefile\nlfa_init(\"custom_areas.shp\")\n\n# Example usage with the default shapefile\nlfa_init()\n\n# Example usage with a custom shapefile\nlfa_init(\"custom_areas.shp\")\n\n\n\nUsage\n\nlfa_init(sf_file = \"research_areas.shp\")\n\n\n\n\n6.3.33 lfa_intersect_areas\nIntersect Lidar Catalog with Spatial Features\n\nArguments\n\n\n\n\n\n\n\nArgument\nDescription\n\n\n\n\nctg\nA LAScatalog object representing the Lidar data to be processed.\n\n\ntile_location\nA tile location object representing the specific area of interest.\n\n\nareas_sf\nSpatial features defining areas.\n\n\n\n\n\nDescription\nThis function intersects a Lidar catalog with a specific area defined by spatial features.\n\n\nDetails\nThe function intersects the Lidar catalog specified by ctg with a specific area defined by the tile_location object and areas_sf . It removes points outside the specified area and returns a modified LAScatalog object.\nThe specified area is identified based on the species and name attributes in the tile_location object. If a matching area is not found in areas_sf , the function stops with an error.\nThe function then transforms the spatial reference of the identified area to match that of the Lidar catalog using sf::st_transform .\nThe processing is applied to each chunk in the catalog using the identify_area function, which merges spatial information and filters out points that are not classified as inside the identified area. After processing, the function writes the modified LAS files back to the original file locations, removing points outside the specified area.\nIf an error occurs during the processing of a chunk, a warning is issued, and the function continues processing the next chunks. If no points are found after filtering, a warning is issued, and NULL is returned.\n\n\nSeealso\nOther functions in the Lidar forest analysis (LFA) package.\n\n\nValue\nA modified LAScatalog object with points outside the specified area removed.\n\n\nExamples\n\n# Example usage\nlfa_intersect_areas(ctg, tile_location, areas_sf)\n\n# Example usage\nlfa_intersect_areas(ctg, tile_location, areas_sf)\n\n\n\nUsage\n\nlfa_intersect_areas(ctg, tile_location, areas_sf)\n\n\n\n\n6.3.34 lfa_jsd_from_vec\nCompute Jensen-Shannon Divergence from Vectors\n\nArguments\n\n\n\nArgument\nDescription\n\n\n\n\nx\nA numeric vector.\n\n\ny\nA numeric vector.\n\n\n\n\n\nDescription\nThis function calculates the Jensen-Shannon Divergence (JSD) between two vectors.\n\n\nValue\nJensen-Shannon Divergence between the density distributions of x and y.\n\n\nExamples\n\nx &lt;- rnorm(100)\ny &lt;- rnorm(100, mean = 2)\nlfa_jsd_from_vec(x, y)\n\n\n\nUsage\n\nlfa_jsd_from_vec(x, y)\n\n\n\n\n6.3.35 lfa_jsd\nJensen-Shannon Divergence Calculation\n\nArguments\n\n\n\n\n\n\n\nArgument\nDescription\n\n\n\n\np\nA numeric vector representing the probability distribution P.\n\n\nq\nA numeric vector representing the probability distribution Q.\n\n\nepsilon\nA small positive constant added to both P and Q to avoid logarithm of zero. Default is 1e-10.\n\n\n\n\n\nDescription\nThis function calculates the Jensen-Shannon Divergence (JSD) between two probability distributions P and Q.\n\n\nDetails\nThe JSD is computed using the Kullback-Leibler Divergence (KLD) as follows: sum((p * log((p + epsilon) / (m + epsilon)) + q * log((q + epsilon) / (m + epsilon))) / 2) where m = (p + q) / 2 .\n\n\nSeealso\nkld , sum , log\n\n\nValue\nA numeric value representing the Jensen-Shannon Divergence between P and Q.\n\n\nExamples\n\n# Calculate JSD between two probability distributions\np_distribution &lt;- c(0.2, 0.3, 0.5)\nq_distribution &lt;- c(0.1, 0, 0.9)\njsd_result &lt;- jsd(p_distribution, q_distribution)\nprint(jsd_result)\n\n\n\nUsage\n\nlfa_jsd(p, q, epsilon = 1e-10)\n\n\n\n\n6.3.36 lfa_kld_from_vec\nCompute Kullback-Leibler Divergence from Vectors\n\nArguments\n\n\n\nArgument\nDescription\n\n\n\n\nx\nA numeric vector.\n\n\ny\nA numeric vector.\n\n\n\n\n\nDescription\nThis function calculates the Kullback-Leibler Divergence (KLD) between two vectors.\n\n\nValue\nKullback-Leibler Divergence between the density distributions of x and y.\n\n\nExamples\n\nx &lt;- rnorm(100)\ny &lt;- rnorm(100, mean = 2)\nlfa_kld_from_vec(x, y)\n\n\n\nUsage\n\nlfa_kld_from_vec(x, y)\n\n\n\n\n6.3.37 lfa_kld\nKullback-Leibler Divergence Calculation\n\nArguments\n\n\n\n\n\n\n\nArgument\nDescription\n\n\n\n\np\nA numeric vector representing the probability distribution P.\n\n\nq\nA numeric vector representing the probability distribution Q.\n\n\nepsilon\nA small positive constant added to both P and Q to avoid logarithm of zero. Default is 1e-10.\n\n\n\n\n\nDescription\nThis function calculates the Kullback-Leibler Divergence (KLD) between two probability distributions P and Q.\n\n\nDetails\nThe KLD is computed using the formula: sum(p * log((p + epsilon) / (q + epsilon))) This avoids issues when the denominator (Q) contains zero probabilities.\n\n\nSeealso\nsum , log\n\n\nValue\nA numeric value representing the Kullback-Leibler Divergence between P and Q.\n\n\nExamples\n\n# Calculate KLD between two probability distributions\np_distribution &lt;- c(0.2, 0.3, 0.5)\nq_distribution &lt;- c(0.1, 0, 0.9)\nkld_result &lt;- kld(p_distribution, q_distribution)\nprint(kld_result)\n\n\n\nUsage\n\nlfa_kld(p, q, epsilon = 1e-10)\n\n\n\n\n6.3.38 lfa_ks_test\nKolmogorov-Smirnov Test Wrapper Function\n\nArguments\n\n\n\n\n\n\n\nArgument\nDescription\n\n\n\n\nx\nA numeric vector representing the first sample.\n\n\ny\nA numeric vector representing the second sample.\n\n\noutput_variable\nA character string specifying the output variable to extract from the ks.test result. Default is “p.value”. Other possible values include “statistic” and “alternative”.\n\n\n...\nAdditional arguments to be passed to the ks.test function.\n\n\n\n\n\nDescription\nThis function serves as a wrapper for the Kolmogorov-Smirnov (KS) test between two samples.\n\n\nDetails\nThe function uses the ks.test function to perform a two-sample KS test and returns the specified output variable. The default output variable is the p-value. Other possible output variables include “statistic” and “alternative”.\n\n\nSeealso\nks.test\n\n\nValue\nA numeric value representing the specified output variable from the KS test result.\n\n\nExamples\n\n# Perform KS test and extract the p-value\nresult &lt;- lfa_ks_test(sample1, sample2)\nprint(result)\n\n# Perform KS test and extract the test statistic\nresult_statistic &lt;- lfa_ks_test(sample1, sample2, output_variable = \"statistic\")\nprint(result_statistic)\n\n\n\nUsage\n\nlfa_ks_test(x, y, output_variable = \"p.value\", ...)\n\n\n\n\n6.3.39 lfa_load_ctg_if_not_present\nLoading the catalog if it is not present\n\nArguments\n\n\n\n\n\n\n\nArgument\nDescription\n\n\n\n\nctg\nCatalog object. Can be NULL\n\n\ntile_location\nThe location to look for the catalog tiles, if their are not present\n\n\n\n\n\nDescription\nThis function checks if the catalog is NULL . If it is it will load the catalog from the tile_location\n\n\nValue\nThe provided ctg object if not null, else the catalog for the tiles of the tile_location.\n\n\nUsage\n\nlfa_load_ctg_if_not_present(ctg, tile_location)\n\n\n\n\n6.3.40 lfa_map_tile_locations\nMap Function Over Tile Locations\n\nArguments\n\n\n\n\n\n\n\nArgument\nDescription\n\n\n\n\ntile_locations\nA list of tile location objects.\n\n\nmap_function\nThe mapping function to be applied to each tile location.\n\n\n...\nAdditional arguments to be passed to the mapping function.\n\n\n\n\n\nDescription\nThis function applies a specified mapping function to each tile location in a list.\n\n\nDetails\nThis function iterates over each tile location in the provided list ( tile_locations ) and applies the specified mapping function ( map_function ) to each tile location. The mapping function should accept a tile location object as its first argument, and additional arguments can be passed using the ellipsis ( ... ) syntax.\nThis function is useful for performing operations on multiple tile locations concurrently, such as loading Lidar data, processing areas, or other tasks that involve tile locations.\n\n\nSeealso\nThe mapping function provided should be compatible with the structure and requirements of the tile locations and the specific task being performed.\n\n\nValue\nNone\n\n\nExamples\n\n# Example usage\nlfa_map_tile_locations(tile_locations, my_mapping_function, param1 = \"value\")\n\n# Example usage\nlfa_map_tile_locations(tile_locations, my_mapping_function, param1 = \"value\")\n\n\n\nUsage\n\nlfa_map_tile_locations(tile_locations, map_function, check_flag = NULL, ...)\n\n\n\n\n6.3.41 lfa_merge_and_save\nMerge and Save Text Files in a Directory\n\nArguments\n\n\n\n\n\n\n\nArgument\nDescription\n\n\n\n\ninput_directory\nThe path to the input directory containing text files.\n\n\noutput_name\nThe name for the output file where the merged content will be saved.\n\n\n\n\n\nDescription\nThis function takes an input directory and an output name as arguments. It merges the textual content of all files in the specified directory into a single string, with each file’s content separated by a newline character. The merged content is then saved into a file named after the output name in the same directory. After the merging is complete, all input files are deleted.\n\n\nDetails\nThis function reads the content of each text file in the specified input directory and concatenates them into a single string. Each file’s content is separated by a newline character. The merged content is then saved into a file named after the output name in the same directory. Finally, all input files are deleted from the directory.\n\n\nSeealso\nreadLines , writeLines , file.remove\n\n\nValue\nThis function does not explicitly return any value. It prints a message indicating the successful completion of the merging and saving process.\n\n\nExamples\n\n# Merge text files in the \"data_files\" directory and save the result in \"merged_output\"\nlfa_merge_and_save(\"data_files\", \"merged_output\")\n\n# Merge text files in the \"data_files\" directory and save the result in \"merged_output\"\nlfa_merge_and_save(\"data_files\", \"merged_output\")\n\n\n\nUsage\n\nlfa_merge_and_save(input_directory, output_name)\n\n\n\n\n6.3.42 lfa_plot_confusion_matrix\nPlot Confusion Matrix\n\nArguments\n\n\n\n\n\n\n\nArgument\nDescription\n\n\n\n\nconf_matrix\nConfusion matrix, typically obtained from classification evaluation.\n\n\n\n\n\nDescription\nThis function generates a heatmap plot of a confusion matrix using ggplot2.\n\n\nDetails\nThe function takes a confusion matrix as input and generates a heatmap plot using ggplot2. The plot represents the relationship between the predicted and actual classes, with cell colors indicating the frequency of each combination. Additionally, the plot includes labels for accuracy and kappa statistics based on the confusion matrix.\n\n\nValue\nA ggplot object representing the confusion matrix heatmap plot.\n\n\nExamples\n\n# Example confusion matrix\ncm &lt;- table(predicted = c(\"A\", \"B\", \"A\", \"B\"), actual = c(\"A\", \"A\", \"B\", \"B\"))\n# Plot confusion matrix\nlfa_plot_confusion_matrix(cm)\n\n\n\nUsage\n\nlfa_plot_confusion_matrix(conf_matrix)\n\n\n\n\n6.3.43 lfa_precision_per_class\nCalculate Precision per Class from Confusion Matrix\n\nArguments\n\n\n\n\n\n\n\nArgument\nDescription\n\n\n\n\nconfusion_matrix\nConfusion matrix obtained from a classification evaluation.\n\n\n\n\n\nDescription\nThis function calculates precision for each class based on the provided confusion matrix.\n\n\nDetails\nPrecision is a measure of the accuracy of the positive predictions for a specific class. It is calculated as the ratio of true positives to the sum of true positives and false positives.\n\n\nSeealso\nlfa_recall_per_class , lfa_f1_score_per_class\n\n\nValue\nA numeric vector representing precision for each class.\n\n\nExamples\n\n# Example confusion matrix\ncm &lt;- table(predicted = c(\"A\", \"B\", \"A\", \"B\"), actual = c(\"A\", \"A\", \"B\", \"B\"))\n# Calculate precision per class\nprecision_vector &lt;- lfa_precision_per_class(cm)\n\n\n\nUsage\n\nlfa_precision_per_class(confusion_matrix)\n\n\n\n\n6.3.44 lfa_random_forest\nRandom Forest Classifier with Leave-One-Out Cross-Validation\n\nArguments\n\n\n\n\n\n\n\nArgument\nDescription\n\n\n\n\ntree_data\nA data frame containing the tree data, including the response variable (“specie”) and predictor variables.\n\n\nexcluded_input_columns\nA character vector specifying columns to be excluded from predictor variables.\n\n\nresponse_variable\nThe response variable to be predicted (default is “specie”).\n\n\nseed\nAn integer to set the seed for reproducibility (default is 123).\n\n\n...\nAdditional parameters to be passed to the randomForest function.\n\n\n\n\n\nDescription\nThis function performs a random forest classification using leave-one-out cross-validation for each area in the input tree data. It returns a list containing various results, including predicted species, confusion matrix, accuracy, and the formula used for modeling.\n\n\nValue\nA list containing the following elements:\n\npredicted_species_absolute : A data frame with observed and predicted species for each area.\npredicted_species_relative : A data frame wit the relative precictions per speices and areas, normalized by the total predictions in each area.\nconfusion_matrix : A confusion matrix showing the counts of predicted vs. observed species.\naccuracy : The accuracy of the model, calculated as the sum of diagonal elements in the confusion matrix divided by the total count.\nformula : The formula used for modeling.\n\n\n\nExamples\n\n# Assuming tree_data is defined\nresults &lt;- lfa_random_forest(tree_data, excluded_input_columns = c(\"column1\", \"column2\"))\n\n# Print the list of results\nprint(results)\n\n\n\nUsage\n\nlfa_random_forest(\n  tree_data,\n  excluded_input_columns,\n  response_variable = \"specie\",\n  ntree = 100,\n  seed = 123,\n  ...\n)\n\n\n\n\n6.3.45 lfa_rasterize_chunk\nRasterize Lidar Chunk\n\nArguments\n\n\n\n\n\n\n\nArgument\nDescription\n\n\n\n\nchunk\nLidar chunk object to be rasterized.\n\n\n...\nAdditional arguments to be passed to the underlying lidR::rasterize_canopy function.\n\n\n\n\n\nDescription\nThis function rasterizes a Lidar chunk to generate a raster representation of the canopy.\n\n\nDetails\nThe function takes a Lidar chunk as input and uses lidR::rasterize_canopy to generate a raster representation of the canopy. Additional arguments can be passed to customize the rasterization process.\n\n\nValue\nA raster layer representing the rasterized canopy.\n\n\nExamples\n\n# Example Lidar chunk\nlidar_chunk &lt;- readLAS(\"lidar_data.las\", select = \"xyz\")\n# Rasterize Lidar chunk\nrasterized_canopy &lt;- lfa_rasterize_chunk(lidar_chunk)\n\n\n\nUsage\n\nlfa_rasterize_chunk(chunk, ...)\n\n\n\n\n6.3.46 lfa_rd_to_qmd\nConvert Rd File to Markdown\n\nArguments\n\n\n\n\n\n\n\nArgument\nDescription\n\n\n\n\nrdfile\nThe path to the Rd file or a parsed Rd object.\n\n\noutfile\nThe path to the output Markdown file (including the file extension).\n\n\nappend\nLogical, indicating whether to append to an existing file (default is FALSE).\n\n\n\n\n\nDescription\nIMPORTANT NOTE: This function is nearly identical to the Rd2md::Rd2markdown function from the Rd2md package. We needed to implement our own version of it because of various reasons:\n\nThe algorithm uses hardcoded header sizes (h1 and h2 in original) which is not feasible for our use-case of the markdown.\nWe needed to add some Quarto Markdown specifics, e.g. to make sure that the examples will not be runned.\nWe want to exclude certain tags from our implementation.\n\n\n\nDetails\nFor that reason we copied the method and made changes as needed and also added this custom documentation.\nThis function converts an Rd (R documentation) file to Markdown format (.md) and saves the converted file at the specified location. The function allows appending to an existing file or creating a new one. The resulting Markdown file includes sections for the function’s name, title, and additional content such as examples, usage, arguments, and other sections present in the Rd file.\nThe function performs the following steps:\n\nParses the Rd file using the Rd2md package.\nCreates a Markdown file with sections for the function’s name, title, and additional content.\nAppends the content to an existing file if append is set to TRUE.\nSaves the resulting Markdown file at the specified location.\n\n\n\nSeealso\nRd2md::parseRd\n\n\nValue\nThis function does not explicitly return any value. It saves the converted Markdown file at the specified location as described in the details section.\n\n\nExamples\n\n# Convert Rd file to Markdown and save it\nlfa_rd_to_md(\"path/to/your/file.Rd\", \"path/to/your/output/file.md\")\n\n# Convert Rd file to Markdown and append to an existing file\nlfa_rd_to_md(\"path/to/your/file.Rd\", \"path/to/existing/output/file.md\", append = TRUE)\n\n\n\nUsage\n\nlfa_rd_to_qmd(rdfile, outfile, append = FALSE)\n\n\n\n\n6.3.47 lfa_rd_to_results\nConvert Rd Files to Markdown and Merge Results\n\nDescription\nThis function converts all Rd (R documentation) files in the “man” directory to Markdown format (.qmd) and saves the converted files in the “results/appendix/package-docs” directory. It then merges the converted Markdown files into a single string and saves the merged content into a file named “docs.qmd” in the “results/appendix/package-docs” directory.\n\n\nDetails\nThe function performs the following steps:\n\nRemoves any existing “docs.qmd” file in the “results/appendix/package-docs” directory.\nFinds all Rd files in the “man” directory.\nConverts each Rd file to Markdown format (.qmd) using the lfa_rd_to_qmd function.\nSaves the converted Markdown files in the “results/appendix/package-docs” directory.\nMerges the content of all converted Markdown files into a single string.\nSaves the merged content into a file named “docs.qmd” in the “results/appendix/package-docs” directory.\n\n\n\nSeealso\nlfa_rd_to_qmd , lfa_merge_and_save\n\n\nValue\nThis function does not explicitly return any value. It performs the conversion, merging, and saving operations as described in the details section.\n\n\nExamples\n\n# Convert Rd files to Markdown and merge the results\nlfa_rd_to_results()\n\n\n\nUsage\n\nlfa_rd_to_results()\n\n\n\n\n6.3.48 lfa_read_area_as_catalog\nRead LiDAR data from a specified species and location as a catalog.\n\nArguments\n\n\n\n\n\n\n\nArgument\nDescription\n\n\n\n\nspecie\nA character string specifying the species of interest.\n\n\nlocation_name\nA character string specifying the name of the location.\n\n\n\n\n\nDescription\nThis function constructs the file path based on the specified specie and location_name , lists the directories at that path, and reads the LiDAR data into a lidR::LAScatalog .\n\n\nValue\nA lidR::LAScatalog object containing the LiDAR data from the specified location and species.\n\n\nExamples\n\nlfa_read_area_as_catalog(\"beech\", \"location1\")\n\n\n\nUsage\n\nlfa_read_area_as_catalog(specie, location_name)\n\n\n\n\n6.3.49 lfa_recall_per_class\nCalculate Recall per Class from Confusion Matrix\n\nArguments\n\n\n\n\n\n\n\nArgument\nDescription\n\n\n\n\nconfusion_matrix\nConfusion matrix obtained from a classification evaluation.\n\n\n\n\n\nDescription\nThis function calculates recall for each class based on the provided confusion matrix.\n\n\nDetails\nRecall (Sensitivity or True Positive Rate) is a measure of the ability of a classification model to identify all relevant instances. It is calculated as the ratio of true positives to the sum of true positives and false negatives.\n\n\nSeealso\nlfa_precision_per_class\n\n\nValue\nA numeric vector representing recall for each class.\n\n\nExamples\n\n# Example confusion matrix\ncm &lt;- table(predicted = c(\"A\", \"B\", \"A\", \"B\"), actual = c(\"A\", \"A\", \"B\", \"B\"))\n# Calculate recall per class\nrecall_vector &lt;- lfa_recall_per_class(cm)\n\n\n\nUsage\n\nlfa_recall_per_class(confusion_matrix)\n\n\n\n\n6.3.50 lfa_run_test_asymmetric\nAsymmetric Pairwise Test for Categories\n\nArguments\n\n\n\n\n\n\n\nArgument\nDescription\n\n\n\n\ndata\nA data frame containing the relevant columns.\n\n\ndata_column\nA character string specifying the column containing the numerical data.\n\n\ncategory_column\nA character string specifying the column containing the categorical variable.\n\n\ntest_function\nA function used to perform the pairwise test between two sets of data. It should accept two vectors of numeric data and additional parameters specified by ... . The function should return a numeric value representing the test result.\n\n\n...\nAdditional parameters to be passed to the test_function .\n\n\n\n\n\nDescription\nThis function performs an asymmetric pairwise test for categories using a user-defined test_function .\n\n\nDetails\nThe function calculates the test results for each unique combination of categories using the specified test_function . The resulting table is asymmetric, containing the test results for comparisons from the rows to the columns.\n\n\nSeealso\nouter , Vectorize\n\n\nValue\nA data frame representing the results of the asymmetric pairwise tests between categories.\n\n\nExamples\n\n# Define a custom test function\ncustom_test_function &lt;- function(x, y) {\n# Your test logic here\n# Return a numeric result\nreturn(mean(x) - mean(y))\n}\n\n# Perform an asymmetric pairwise test\nresult &lt;- lfa_run_test_asymmetric(your_data, \"numeric_column\", \"category_column\", custom_test_function)\n\n\n\nUsage\n\nlfa_run_test_asymmetric(data, data_column, category_column, test_function, ...)\n\n\n\n\n6.3.51 lfa_run_test_symmetric\nSymmetric Pairwise Test for Categories\n\nArguments\n\n\n\n\n\n\n\nArgument\nDescription\n\n\n\n\ndata\nA data frame containing the relevant columns.\n\n\ndata_column\nA character string specifying the column containing the numerical data.\n\n\ncategory_column\nA character string specifying the column containing the categorical variable.\n\n\ntest_function\nA function used to perform the pairwise test between two sets of data. It should accept two vectors of numeric data and additional parameters specified by ... . The function should return a numeric value representing the test result.\n\n\n...\nAdditional parameters to be passed to the test_function .\n\n\n\n\n\nDescription\nThis function performs a symmetric pairwise test for categories using a user-defined test_function .\n\n\nDetails\nThe function calculates the test results for each unique combination of categories using the specified test_function . The resulting table is symmetric, containing the test results for comparisons from the rows to the columns. The upper triangle of the matrix is filled with NA to avoid duplicate results.\n\n\nSeealso\nouter , Vectorize\n\n\nValue\nA data frame representing the results of the symmetric pairwise tests between categories.\n\n\nExamples\n\n# Define a custom test function\ncustom_test_function &lt;- function(x, y) {\n# Your test logic here\n# Return a numeric result\nreturn(mean(x) - mean(y))\n}\n\n# Perform a symmetric pairwise test\nresult &lt;- lfa_run_test_symmetric(your_data, \"numeric_column\", \"category_column\", custom_test_function)\n\n\n\nUsage\n\nlfa_run_test_symmetric(data, data_column, category_column, test_function, ...)\n\n\n\n\n6.3.52 lfa_save_all_neighbours\nSave Neighbors for All Areas\n\nArguments\n\n\n\n\n\n\n\nArgument\nDescription\n\n\n\n\nn\nThe number of nearest trees to find for each tree (default is 100).\n\n\n\n\n\nDescription\nThis function iterates through all detection areas, finds the n nearest trees for each tree, and saves the result to a GeoPackage file for each area.\n\n\nExamples\n\n# Save neighbors for all areas with default value (n=100)\nlfa_save_all_neighbours()\n\n# Save neighbors for all areas with a specific value of n (e.g., n=50)\nlfa_save_all_neighbours(n = 50)\n\n\n\nUsage\n\nlfa_save_all_neighbours(n = 100)\n\n\n\n\n6.3.53 lfa_segmentation\nSegment the elements of an point cloud by trees\n\nArguments\n\n\n\n\n\n\n\nArgument\nDescription\n\n\n\n\nctg\nAn LASCatalog object. If not null, it will perform the actions on this object, if NULL inferring the catalog from the tile_location\n\n\ntile_location\nA tile_location type object holding the information about the location of the catalog. This is used to save the catalog after processing too.\n\n\n\n\n\nAuthor\nJakob Danel\n\n\nDescription\nThis function will try to to divide the hole point cloud into unique trees. Therefore it is assigning for each chunk of the catalog a treeID for each point. Therefore the algorithm uses the li2012 implementation with the following parameters: li2012(dt1 = 2, dt2 = 3, R = 2, Zu = 10, hmin = 5, speed_up = 12) NOTE : The operation is in place and can not be reverted, the old values of the point cloud will be deleted!\n\n\nValue\nA catalog where each chunk has additional treeID values indicating the belonging tree.\n\n\nUsage\n\nlfa_segmentation(ctg, tile_location)\n\n\n\n\n6.3.54 lfa_set_flag\nSet a flag to indicate the completion of a specific process.\n\nArguments\n\n\n\n\n\n\n\nArgument\nDescription\n\n\n\n\nflag_name\nA character string specifying the name of the flag file. It should be a descriptive and unique identifier for the process being flagged.\n\n\n\n\n\nDescription\nThis function creates a hidden flag file at a specified location within the working directory to indicate that a particular processing step has been completed. If the flag file already exists, a warning is issued.\n\n\nValue\nThis function does not have a formal return value.\n\n\nExamples\n\n# Set the flag for a process named \"data_processing\"\nlfa_set_flag(\"data_processing\")\n\n\n\nUsage\n\nlfa_set_flag(flag_name)\n\n\n\n\n6.3.55 lfa_visit_all_areas\nVisit All Areas and Apply Preprocessing Function\n\nArguments\n\n\n\n\n\n\n\nArgument\nDescription\n\n\n\n\npreprocessing_function\nThe preprocessing function to be applied to each area. It should take specie, area, and additional parameters as inputs.\n\n\nareas\nData frame containing information about different areas, including columns “specie” and “area.”\n\n\n...\nAdditional arguments to be passed to the preprocessing function.\n\n\n\n\n\nDescription\nThis function iterates over all specified areas and applies a preprocessing function to each one.\n\n\nDetails\nThe function iterates over all areas specified in the ‘areas’ parameter, and for each area, it applies the provided preprocessing function. The ‘areas’ parameter is expected to be a data frame with columns “specie” and “area,” containing information about different areas to visit. Additional arguments passed via ‘…’ are forwarded to the preprocessing function.\n\n\nSeealso\nlfa_get_all_areas\n\n\nValue\nA list containing the results of applying the preprocessing function to each area.\n\n\nExamples\n\n# Example preprocessing function\nmy_preprocessing_function &lt;- function(specie, area, ...) {\n# Your preprocessing logic here\n# Return the result\nreturn(result)\n}\n# Visit all areas and apply the preprocessing function\nresults_list &lt;- lfa_visit_all_areas(my_preprocessing_function)\n\n\n\nUsage\n\nlfa_visit_all_areas(preprocessing_function, areas = lfa_get_all_areas(), ...)\n\n\n\n\n6.3.56 lfa_visualize_rf_metrics\nVisualize Precision and Recall Metrics for Random Forest Classification\n\nArguments\n\n\n\n\n\n\n\nArgument\nDescription\n\n\n\n\nmetrics_df\nData frame containing precision and recall metrics for each class.\n\n\n\n\n\nDescription\nThis function creates a bar plot to visualize precision and recall metrics for each class obtained from a Random Forest classification.\n\n\nDetails\nThe function creates a bar plot to visualize precision and recall metrics for each class obtained from a Random Forest classification.\n\n\nSeealso\nlfa_calculate_rf_metrics\n\n\nValue\nA ggplot object representing the bar plot of precision and recall metrics.\n\n\nExamples\n\n# Example data frame containing precision and recall metrics\nexample_metrics_df &lt;- data.frame(\nClass = c(\"ClassA\", \"ClassB\"),\nPrecision = c(0.85, 0.92),\nRecall = c(0.78, 0.88)\n)\n# Visualize precision and recall metrics\nlfa_visualize_rf_metrics(example_metrics_df)\n\n\n\nUsage\n\nlfa_visualize_rf_metrics(metrics_df)"
  },
  {
    "objectID": "report.html#footnotes",
    "href": "report.html#footnotes",
    "title": "Evaluating Tree Species Diversity in Forest Ecosystems Using LiDAR Data: A Exploration in NRW",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nhttps://www.opengeodata.nrw.de/produkte/geobasis/hm/3dm_l_las/3dm_l_las/, last visited 7th Dec 2023↩︎\nhttps://github.com/joheisig/GEDIcalibratoR, last visited 7th Dec 2023↩︎"
  },
  {
    "objectID": "appendix/preprocessing.html",
    "href": "appendix/preprocessing.html",
    "title": "",
    "section": "",
    "text": "Load the file with the research areas\n\nsf &lt;- sf::read_sf(here::here(\"research_areas.shp\"))\nprint(sf)\n\nSimple feature collection with 12 features and 3 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 7.071625 ymin: 51.08151 xmax: 8.539877 ymax: 52.25983\nGeodetic CRS:  WGS 84\n# A tibble: 12 × 4\n      id species name                                                   geometry\n   &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;                                             &lt;POLYGON [°]&gt;\n 1     1 oak     rinkerode           ((7.678922 51.85789, 7.675446 51.85752, 7.…\n 2     2 oak     hamm                ((7.858955 51.66699, 7.866444 51.66462, 7.…\n 3     3 oak     muenster            ((7.618908 51.9154, 7.617384 51.9172, 7.61…\n 4     4 pine    greffen             ((8.168691 51.98965, 8.167178 51.99075, 8.…\n 5     5 pine    telgte              ((7.779728 52.00662, 7.781616 52.00662, 7.…\n 6     6 pine    mesum               ((7.534424 52.25499, 7.53378 52.25983, 7.5…\n 7     7 beech   bielefeld_brackwede ((8.524749 51.9921, 8.528418 51.99079, 8.5…\n 8     8 beech   wuelfenrath         ((7.071625 51.29256, 7.072311 51.29334, 7.…\n 9     9 beech   billerbeck          ((7.324729 51.99783, 7.323548 51.99923, 7.…\n10    10 spruce  marienheide         ((7.558102 51.08358, 7.558317 51.08527, 7.…\n11    11 spruce  brilon              ((8.532195 51.41029, 8.535027 51.41064, 8.…\n12    12 spruce  osterwald           ((8.369328 51.21693, 8.371238 51.21718, 8.…\n\n\nInit the project\n\nlibrary(lfa)\nsf::sf_use_s2(FALSE)\nlocations &lt;- lfa_init(\"research_areas.shp\")\n\nDo all of the prprocessing steps\n\nlfa_map_tile_locations(locations,retile,check_flag = \"retile\")\n\nNo further processing: flag retile is set!Function is already computed, no further computings here\n\n\nNULL\n\nlfa_map_tile_locations(locations, lfa_intersect_areas, ctg = NULL, areas_sf = sf,check_flag = \"intersect\")\n\nNo further processing: flag intersect is set!Function is already computed, no further computings here\n\n\nNULL\n\nlfa_map_tile_locations(locations, lfa_ground_correction, ctg = NULL,check_flag = \"z_correction\")\n\nNo further processing: flag z_correction is set!Function is already computed, no further computings here\n\n\nNULL\n\nlfa_map_tile_locations(locations, lfa_segmentation, ctg = NULL,check_flag = \"segmentation\")\n\nNo further processing: flag segmentation is set!Function is already computed, no further computings here\n\n\nNULL\n\nlfa_map_tile_locations(locations, lfa_detection, catalog = NULL, write_to_file = TRUE,check_flag = \"detection\")\n\nNo further processing: flag detection is set!Function is already computed, no further computings here\n\n\nNULL"
  },
  {
    "objectID": "appendix/preprocessing.html#sec-appendix-preprocessing",
    "href": "appendix/preprocessing.html#sec-appendix-preprocessing",
    "title": "",
    "section": "",
    "text": "Load the file with the research areas\n\nsf &lt;- sf::read_sf(here::here(\"research_areas.shp\"))\nprint(sf)\n\nSimple feature collection with 12 features and 3 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 7.071625 ymin: 51.08151 xmax: 8.539877 ymax: 52.25983\nGeodetic CRS:  WGS 84\n# A tibble: 12 × 4\n      id species name                                                   geometry\n   &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;                                             &lt;POLYGON [°]&gt;\n 1     1 oak     rinkerode           ((7.678922 51.85789, 7.675446 51.85752, 7.…\n 2     2 oak     hamm                ((7.858955 51.66699, 7.866444 51.66462, 7.…\n 3     3 oak     muenster            ((7.618908 51.9154, 7.617384 51.9172, 7.61…\n 4     4 pine    greffen             ((8.168691 51.98965, 8.167178 51.99075, 8.…\n 5     5 pine    telgte              ((7.779728 52.00662, 7.781616 52.00662, 7.…\n 6     6 pine    mesum               ((7.534424 52.25499, 7.53378 52.25983, 7.5…\n 7     7 beech   bielefeld_brackwede ((8.524749 51.9921, 8.528418 51.99079, 8.5…\n 8     8 beech   wuelfenrath         ((7.071625 51.29256, 7.072311 51.29334, 7.…\n 9     9 beech   billerbeck          ((7.324729 51.99783, 7.323548 51.99923, 7.…\n10    10 spruce  marienheide         ((7.558102 51.08358, 7.558317 51.08527, 7.…\n11    11 spruce  brilon              ((8.532195 51.41029, 8.535027 51.41064, 8.…\n12    12 spruce  osterwald           ((8.369328 51.21693, 8.371238 51.21718, 8.…\n\n\nInit the project\n\nlibrary(lfa)\nsf::sf_use_s2(FALSE)\nlocations &lt;- lfa_init(\"research_areas.shp\")\n\nDo all of the prprocessing steps\n\nlfa_map_tile_locations(locations,retile,check_flag = \"retile\")\n\nNo further processing: flag retile is set!Function is already computed, no further computings here\n\n\nNULL\n\nlfa_map_tile_locations(locations, lfa_intersect_areas, ctg = NULL, areas_sf = sf,check_flag = \"intersect\")\n\nNo further processing: flag intersect is set!Function is already computed, no further computings here\n\n\nNULL\n\nlfa_map_tile_locations(locations, lfa_ground_correction, ctg = NULL,check_flag = \"z_correction\")\n\nNo further processing: flag z_correction is set!Function is already computed, no further computings here\n\n\nNULL\n\nlfa_map_tile_locations(locations, lfa_segmentation, ctg = NULL,check_flag = \"segmentation\")\n\nNo further processing: flag segmentation is set!Function is already computed, no further computings here\n\n\nNULL\n\nlfa_map_tile_locations(locations, lfa_detection, catalog = NULL, write_to_file = TRUE,check_flag = \"detection\")\n\nNo further processing: flag detection is set!Function is already computed, no further computings here\n\n\nNULL"
  },
  {
    "objectID": "appendix/package-docs/docs.html",
    "href": "appendix/package-docs/docs.html",
    "title": "",
    "section": "",
    "text": "lfa_capitalize_first_char\nCapitalize First Character of a String\n\nArguments\n\n\n\nArgument\nDescription\n\n\n\n\ninput_string\nA single-character string to be processed.\n\n\n\n\n\nConcept\nString Manipulation\n\n\nDescription\nThis function takes a string as input and returns the same string with the first character capitalized. If the first character is already capitalized, the function does nothing. If the first character is not from the alphabet, an error is thrown.\n\n\nDetails\nThis function performs the following steps:\n\nChecks if the input is a single-character string.\nVerifies if the first character is from the alphabet (A-Z or a-z).\nIf the first character is not already capitalized, it capitalizes it.\nReturns the modified string.\n\n\n\nKeyword\nalphabet\n\n\nNote\nThis function is case-sensitive and assumes ASCII characters.\n\n\nReferences\nNone\n\n\nSeealso\nThis function is related to the basic string manipulation functions in base R.\n\n\nValue\nA modified string with the first character capitalized if it is not already. If the first character is already capitalized, the original string is returned.\n\n\nExamples\n\n# Capitalize the first character of a string\ncapitalize_first_char(\"hello\") # Returns \"Hello\"\ncapitalize_first_char(\"World\") # Returns \"World\"\n\n# Error example (non-alphabetic first character)\ncapitalize_first_char(\"123abc\") # Throws an error\n\n\n\nUsage\n\nlfa_capitalize_first_char(input_string)\n\n\n\n\nlfa_check_flag\nCheck if a flag is set, indicating the completion of a specific process.\n\nArguments\n\n\n\n\n\n\n\nArgument\nDescription\n\n\n\n\nflag_name\nA character string specifying the name of the flag file. It should be a descriptive and unique identifier for the process being checked.\n\n\n\n\n\nDescription\nThis function checks for the existence of a hidden flag file at a specified location within the working directory. If the flag file is found, a message is printed, and the function returns TRUE to indicate that the associated processing step has already been completed. If the flag file is not found, the function returns FALSE , indicating that further processing can proceed.\n\n\nValue\nA logical value indicating whether the flag is set ( TRUE ) or not ( FALSE ).\n\n\nExamples\n\n# Check if the flag for a process named \"data_processing\" is set\nlfa_check_flag(\"data_processing\")\n\n\n\nUsage\n\nlfa_check_flag(flag_name)\n\n\n\n\nlfa_create_stacked_distributions_plot\nCreate a stacked distribution plot for tree detections, visualizing the distribution of a specified variable on the x-axis, differentiated by another variable.\n\nArguments\n\n\n\n\n\n\n\nArgument\nDescription\n\n\n\n\ntrees\nA data frame containing tree detection data.\n\n\nx_value\nA character string specifying the column name used for finding the values on the x-axis of the histogram.\n\n\nfill_value\nA character string specifying the column name by which the data are differentiated in the plot.\n\n\nbin\nAn integer specifying the number of bins for the histogram. Default is 100.\n\n\nylab\nA character string specifying the y-axis label. Default is “Amount trees.”\n\n\nxlim\nA numeric vector of length 2 specifying the x-axis limits. Default is c(0, 100).\n\n\nylim\nA numeric vector of length 2 specifying the y-axis limits. Default is c(0, 1000).\n\n\ntitle\nThe title of the plot.\n\n\n\n\n\nDescription\nThis function generates a stacked distribution plot using the ggplot2 package, providing a visual representation of the distribution of a specified variable ( x_value ) on the x-axis, with differentiation based on another variable ( fill_value ). The data for the plot are derived from the provided trees data frame.\n\n\nKeyword\ndata\n\n\nSeealso\nggplot2::geom_histogram , ggplot2::facet_wrap , ggplot2::ylab , ggplot2::scale_fill_brewer , ggplot2::coord_cartesian\n\n\nValue\nA ggplot object representing the stacked distribution plot.\n\n\nExamples\n\n# Create a stacked distribution plot for variable \"Z,\" differentiated by \"area\"\ntrees &lt;- lfa_get_detections()\nlfa_create_stacked_distributions_plot(trees, \"Z\", \"area\")\n\n\n\nUsage\n\nlfa_create_stacked_distributions_plot(\n  trees,\n  x_value,\n  fill_value,\n  bin = 100,\n  ylab = \"Amount trees\",\n  xlim = c(0, 100),\n  ylim = c(0, 1000),\n  title =\n    \"Histograms of height distributions between species 'beech', 'oak', 'pine' and 'spruce' divided by the different areas of Interest\"\n)\n\n\n\n\nlfa_create_tile_location_objects\nCreate tile location objects\n\nAuthor\nJakob Danel\n\n\nDescription\nThis function traverses a directory structure to find LAZ files and creates tile location objects for each file. The function looks into the the data directory of the repository/working directory. It then creates tile_location objects based on the folder structure. The folder structure should not be touched by hand, but created by lfa_init_data_structure() which builds the structure based on a shape file.\n\n\nSeealso\ntile_location\n\n\nValue\nA vector containing tile location objects.\n\n\nExamples\n\nlfa_create_tile_location_objects()\n\nlfa_create_tile_location_objects()\n\n\n\nUsage\n\nlfa_create_tile_location_objects()\n\n\n\n\nlfa_detection\nPerform tree detection on a lidar catalog and optionally save the results to a file.\n\nArguments\n\n\n\n\n\n\n\nArgument\nDescription\n\n\n\n\ncatalog\nA lidar catalog containing point cloud data. If set to NULL, the function attempts to read the catalog from the specified tile location.\n\n\ntile_location\nAn object specifying the location of the lidar tile. If catalog is NULL, the function attempts to read the catalog from this tile location.\n\n\nwrite_to_file\nA logical value indicating whether to save the detected tree information to a file. Default is TRUE.\n\n\n\n\n\nDescription\nThis function utilizes lidar data to detect trees within a specified catalog. The detected tree information can be optionally saved to a file in the GeoPackage format. The function uses parallel processing to enhance efficiency.\n\n\nValue\nA sf style data frame containing information about the detected trees.\n\n\nExamples\n\n# Perform tree detection on a catalog and save the results to a file\nlfa_detection(catalog = my_catalog, tile_location = my_tile_location, write_to_file = TRUE)\n\n\n\nUsage\n\nlfa_detection(catalog, tile_location, write_to_file = TRUE)\n\n\n\n\nlfa_download_areas\nDownload areas based on spatial features\n\nArguments\n\n\n\n\n\n\n\nArgument\nDescription\n\n\n\n\nsf_areas\nSpatial features representing areas to be downloaded. It must include columns like “species” “name” See details for more information.\n\n\n\n\n\nAuthor\nJakob Danel\n\n\nDescription\nThis function initiates the data structure and downloads areas based on spatial features.\n\n\nDetails\nThe input data frame, sf_areas , must have the following columns:\n\n“species”: The species associated with the area.\n“name”: The name of the area.\n\nThe function uses the lfa_init_data_structure function to set up the data structure and then iterates through the rows of sf_areas to download each specified area.\n\n\nValue\nNone\n\n\nExamples\n\nlfa_download_areas(sf_areas)\n\n\n# Example spatial features data frame\nsf_areas &lt;- data.frame(\nspecies = c(\"SpeciesA\", \"SpeciesB\"),\nname = c(\"Area1\", \"Area2\"),\n# Must include also other attributes specialized to sf objects\n# such as geometry, for processing of the download\n)\n\nlfa_download_areas(sf_areas)\n\n\n\nUsage\n\nlfa_download_areas(sf_areas)\n\n\n\n\nlfa_download\nDownload an las file from the state NRW from a specific location\n\nArguments\n\n\n\n\n\n\n\nArgument\nDescription\n\n\n\n\nspecies\nThe species of the tree which is observed at this location\n\n\nname\nThe name of the area that is observed\n\n\nlocation\nAn sf object, which holds the location information for the area where the tile should be downloaded from.\n\n\n\n\n\nDescription\nIt will download the file and save it to data/ list(list(“html”), list(list(“”))) / list(list(“html”), list(list(“”))) with the name of the tile\n\n\nValue\nThe LASCatalog object of the downloaded file\n\n\nUsage\n\nlfa_download(species, name, location)\n\n\n\n\nlfa_get_all_areas\nRetrieve a data frame containing all species and corresponding areas.\n\nDescription\nThis function scans the “data” directory within the current working directory to obtain a list of species. It then iterates through each species to retrieve the list of areas associated with that species. The resulting data frame contains two columns: “specie” representing the species and “area” representing the corresponding area.\n\n\nKeyword\ndata\n\n\nSeealso\nlist.dirs\n\n\nValue\nA data frame with columns “specie” and “area” containing information about all species and their associated areas.\n\n\nExamples\n\n# Retrieve a data frame with information about all species and areas\nall_areas_df &lt;- lfa_get_all_areas()\n\n\n\nUsage\n\nlfa_get_all_areas()\n\n\n\n\nlfa_get_detection_area\nGet Detection for an area\n\nArguments\n\n\n\nArgument\nDescription\n\n\n\n\nspecies\nA character string specifying the target species.\n\n\nname\nA character string specifying the name of the tile.\n\n\n\n\n\nDescription\nRetrieves the tree detection information for a specified species and tile.\n\n\nDetails\nThis function reads tree detection data from geopackage files within the specified tile location for a given species. It then combines the data into a single SF data frame and returns it. The function assumes that the tree detection files follow a naming convention with the pattern “_detection.gpkg”.\n\n\nKeyword\nspatial\n\n\nReferences\nThis function is part of the LiDAR Forest Analysis (LFA) package.\n\n\nSeealso\nget_tile_dir\n\n\nValue\nA Simple Features (SF) data frame containing tree detection information for the specified species and tile.\n\n\nExamples\n\n# Retrieve tree detection data for species \"example_species\" in tile \"example_tile\"\ntrees_data &lt;- lfa_get_detection_tile_location(\"example_species\", \"example_tile\")\n\n# Example usage:\ntrees_data &lt;- lfa_get_detection_tile_location(\"example_species\", \"example_tile\")\n\n# No trees found scenario:\nempty_data &lt;- lfa_get_detection_tile_location(\"nonexistent_species\", \"nonexistent_tile\")\n# The result will be an empty data frame if no trees are found for the specified species and tile.\n\n# Error handling:\n# In case of invalid inputs, the function may throw errors. Ensure correct species and tile names are provided.\n\n\n\nUsage\n\nlfa_get_detection_area(species, name)\n\n\n\n\nlfa_get_detections_species\nRetrieve detections for a specific species.\n\nArguments\n\n\n\nArgument\nDescription\n\n\n\n\nspecies\nA character string specifying the target species.\n\n\n\n\n\nDescription\nThis function retrieves detection data for a given species from multiple areas.\n\n\nDetails\nThe function looks for detection data in the “data” directory for the specified species. It then iterates through each subdirectory (representing different areas) and consolidates the detection data into a single data frame.\n\n\nValue\nA data frame containing detection information for the specified species in different areas.\n\n\nExamples\n\n# Example usage:\ndetections_data &lt;- lfa_get_detections_species(\"example_species\")\n\n\n\nUsage\n\nlfa_get_detections_species(species)\n\n\n\n\nlfa_get_flag_path\nGet the path to a flag file indicating the completion of a specific process.\n\nArguments\n\n\n\n\n\n\n\nArgument\nDescription\n\n\n\n\nflag_name\nA character string specifying the name of the flag file. It should be a descriptive and unique identifier for the process being flagged.\n\n\n\n\n\nDescription\nThis function constructs and returns the path to a hidden flag file, which serves as an indicator that a particular processing step has been completed. The flag file is created in a designated location within the working directory.\n\n\nValue\nA character string representing the absolute path to the hidden flag file.\n\n\nExamples\n\n# Get the flag path for a process named \"data_processing\"\nlfa_get_flag_path(\"data_processing\")\n\n\n\nUsage\n\nlfa_get_flag_path(flag_name)\n\n\n\n\nlfa_ground_correction\nCorrect the point clouds for correct ground imagery\n\nArguments\n\n\n\n\n\n\n\nArgument\nDescription\n\n\n\n\nctg\nAn LASCatalog object. If not null, it will perform the actions on this object, if NULL inferring the catalog from the tile_location\n\n\ntile_location\nA tile_location type object holding the information about the location of the cataog. This is used to save the catalog after processing too.\n\n\n\n\n\nAuthor\nJakob Danel\n\n\nDescription\nThis function is needed to correct the Z value of the point cloud, relative to the real ground height. After using this function to your catalog, the Z values can be seen as the real elevation about the ground. At the moment the function uses the tin() function from the lidr package. NOTE : The operation is inplace and can not be reverted, the old values of the point cloud will be deleted!\n\n\nValue\nA catalog with the corrected z values. The catalog is always stored at tile_location and holding only the transformed values.\n\n\nUsage\n\nlfa_ground_correction(ctg, tile_location)\n\n\n\n\nlfa_init_data_structure\nInitialize data structure for species and areas\n\nArguments\n\n\n\n\n\n\n\nArgument\nDescription\n\n\n\n\nsf_species\nA data frame with information about species and associated areas.\n\n\n\n\n\nDescription\nThis function initializes the data structure for storing species and associated areas.\n\n\nDetails\nThe input data frame, sf_species , should have at least the following columns:\n\n“species”: The names of the species for which the data structure needs to be initialized.\n“name”: The names of the associated areas.\n\nThe function creates directories based on the species and area information provided in the sf_species data frame. It checks whether the directories already exist and creates them if they don’t.\n\n\nValue\nNone\n\n\nExamples\n\n# Example species data frame\nsf_species &lt;- data.frame(\nspecies = c(\"SpeciesA\", \"SpeciesB\"),\nname = c(\"Area1\", \"Area2\"),\n# Other necessary columns\n)\n\nlfa_init_data_structure(sf_species)\n\n# Example species data frame\nsf_species &lt;- data.frame(\nspecies = c(\"SpeciesA\", \"SpeciesB\"),\nname = c(\"Area1\", \"Area2\"),\n# Other necessary columns\n)\n\nlfa_init_data_structure(sf_species)\n\n\n\nUsage\n\nlfa_init_data_structure(sf_species)\n\n\n\n\nlfa_init\nInitialize LFA (LiDAR forest analysis) data processing\n\nArguments\n\n\n\n\n\n\n\nArgument\nDescription\n\n\n\n\nsf_file\nA character string specifying the path to the shapefile containing spatial features of research areas.\n\n\n\n\n\nDescription\nThis function initializes the LFA data processing by reading a shapefile containing spatial features of research areas, downloading the specified areas, and creating tile location objects for each area.\n\n\nDetails\nThis function reads a shapefile ( sf_file ) using the sf package, which should contain information about research areas. It then calls the lfa_download_areas function to download the specified areas and lfa_create_tile_location_objects to create tile location objects based on Lidar data files in those areas. The shapefile MUST follow the following requirements:\n\nEach geometry must be a single object of type polygon\nEach entry must have the following attributes:\nspecies: A string describing the tree species of the area.\nname: A string describing the location of the area.\n\n\n\nValue\nA vector containing tile location objects.\n\n\nExamples\n\n# Initialize LFA processing with the default shapefile\nlfa_init()\n\n# Initialize LFA processing with a custom shapefile\nlfa_init(\"custom_areas.shp\")\n\n# Example usage with the default shapefile\nlfa_init()\n\n# Example usage with a custom shapefile\nlfa_init(\"custom_areas.shp\")\n\n\n\nUsage\n\nlfa_init(sf_file = \"research_areas.shp\")\n\n\n\n\nlfa_intersect_areas\nIntersect Lidar Catalog with Spatial Features\n\nArguments\n\n\n\n\n\n\n\nArgument\nDescription\n\n\n\n\nctg\nA LAScatalog object representing the Lidar data to be processed.\n\n\ntile_location\nA tile location object representing the specific area of interest.\n\n\nareas_sf\nSpatial features defining areas.\n\n\n\n\n\nDescription\nThis function intersects a Lidar catalog with a specific area defined by spatial features.\n\n\nDetails\nThe function intersects the Lidar catalog specified by ctg with a specific area defined by the tile_location object and areas_sf . It removes points outside the specified area and returns a modified LAScatalog object.\nThe specified area is identified based on the species and name attributes in the tile_location object. If a matching area is not found in areas_sf , the function stops with an error.\nThe function then transforms the spatial reference of the identified area to match that of the Lidar catalog using sf::st_transform .\nThe processing is applied to each chunk in the catalog using the identify_area function, which merges spatial information and filters out points that are not classified as inside the identified area. After processing, the function writes the modified LAS files back to the original file locations, removing points outside the specified area.\nIf an error occurs during the processing of a chunk, a warning is issued, and the function continues processing the next chunks. If no points are found after filtering, a warning is issued, and NULL is returned.\n\n\nSeealso\nOther functions in the Lidar forest analysis (LFA) package.\n\n\nValue\nA modified LAScatalog object with points outside the specified area removed.\n\n\nExamples\n\n# Example usage\nlfa_intersect_areas(ctg, tile_location, areas_sf)\n\n# Example usage\nlfa_intersect_areas(ctg, tile_location, areas_sf)\n\n\n\nUsage\n\nlfa_intersect_areas(ctg, tile_location, areas_sf)\n\n\n\n\nlfa_load_ctg_if_not_present\nLoading the catalog if it is not present\n\nArguments\n\n\n\n\n\n\n\nArgument\nDescription\n\n\n\n\nctg\nCatalog object. Can be NULL\n\n\ntile_location\nThe location to look for the catalog tiles, if their are not present\n\n\n\n\n\nDescription\nThis function checks if the catalog is NULL . If it is it will load the catalog from the tile_location\n\n\nValue\nThe provided ctg object if not null, else the catalog for the tiles of the tile_location.\n\n\nUsage\n\nlfa_load_ctg_if_not_present(ctg, tile_location)\n\n\n\n\nlfa_map_tile_locations\nMap Function Over Tile Locations\n\nArguments\n\n\n\n\n\n\n\nArgument\nDescription\n\n\n\n\ntile_locations\nA list of tile location objects.\n\n\nmap_function\nThe mapping function to be applied to each tile location.\n\n\n...\nAdditional arguments to be passed to the mapping function.\n\n\n\n\n\nDescription\nThis function applies a specified mapping function to each tile location in a list.\n\n\nDetails\nThis function iterates over each tile location in the provided list ( tile_locations ) and applies the specified mapping function ( map_function ) to each tile location. The mapping function should accept a tile location object as its first argument, and additional arguments can be passed using the ellipsis ( ... ) syntax.\nThis function is useful for performing operations on multiple tile locations concurrently, such as loading Lidar data, processing areas, or other tasks that involve tile locations.\n\n\nSeealso\nThe mapping function provided should be compatible with the structure and requirements of the tile locations and the specific task being performed.\n\n\nValue\nNone\n\n\nExamples\n\n# Example usage\nlfa_map_tile_locations(tile_locations, my_mapping_function, param1 = \"value\")\n\n# Example usage\nlfa_map_tile_locations(tile_locations, my_mapping_function, param1 = \"value\")\n\n\n\nUsage\n\nlfa_map_tile_locations(tile_locations, map_function, check_flag = NULL, ...)\n\n\n\n\nlfa_merge_and_save\nMerge and Save Text Files in a Directory\n\nArguments\n\n\n\n\n\n\n\nArgument\nDescription\n\n\n\n\ninput_directory\nThe path to the input directory containing text files.\n\n\noutput_name\nThe name for the output file where the merged content will be saved.\n\n\n\n\n\nDescription\nThis function takes an input directory and an output name as arguments. It merges the textual content of all files in the specified directory into a single string, with each file’s content separated by a newline character. The merged content is then saved into a file named after the output name in the same directory. After the merging is complete, all input files are deleted.\n\n\nDetails\nThis function reads the content of each text file in the specified input directory and concatenates them into a single string. Each file’s content is separated by a newline character. The merged content is then saved into a file named after the output name in the same directory. Finally, all input files are deleted from the directory.\n\n\nSeealso\nreadLines , writeLines , file.remove\n\n\nValue\nThis function does not explicitly return any value. It prints a message indicating the successful completion of the merging and saving process.\n\n\nExamples\n\n# Merge text files in the \"data_files\" directory and save the result in \"merged_output\"\nlfa_merge_and_save(\"data_files\", \"merged_output\")\n\n# Merge text files in the \"data_files\" directory and save the result in \"merged_output\"\nlfa_merge_and_save(\"data_files\", \"merged_output\")\n\n\n\nUsage\n\nlfa_merge_and_save(input_directory, output_name)\n\n\n\n\nlfa_rd_to_qmd\nConvert Rd File to Markdown\n\nArguments\n\n\n\n\n\n\n\nArgument\nDescription\n\n\n\n\nrdfile\nThe path to the Rd file or a parsed Rd object.\n\n\noutfile\nThe path to the output Markdown file (including the file extension).\n\n\nappend\nLogical, indicating whether to append to an existing file (default is FALSE).\n\n\n\n\n\nDescription\nIMPORTANT NOTE: This function is nearly identical to the Rd2md::Rd2markdown function from the Rd2md package. We needed to implement our own version of it because of various reasons:\n\nThe algorithm uses hardcoded header sizes (h1 and h2 in original) which is not feasible for our use-case of the markdown.\nWe needed to add some Quarto Markdown specifics, e.g. to make sure that the examples will not be runned.\nWe want to exclude certain tags from our implementation.\n\n\n\nDetails\nFor that reason we copied the method and made changes as needed and also added this custom documentation.\nThis function converts an Rd (R documentation) file to Markdown format (.md) and saves the converted file at the specified location. The function allows appending to an existing file or creating a new one. The resulting Markdown file includes sections for the function’s name, title, and additional content such as examples, usage, arguments, and other sections present in the Rd file.\nThe function performs the following steps:\n\nParses the Rd file using the Rd2md package.\nCreates a Markdown file with sections for the function’s name, title, and additional content.\nAppends the content to an existing file if append is set to TRUE.\nSaves the resulting Markdown file at the specified location.\n\n\n\nSeealso\nRd2md::parseRd\n\n\nValue\nThis function does not explicitly return any value. It saves the converted Markdown file at the specified location as described in the details section.\n\n\nExamples\n\n# Convert Rd file to Markdown and save it\nlfa_rd_to_md(\"path/to/your/file.Rd\", \"path/to/your/output/file.md\")\n\n# Convert Rd file to Markdown and append to an existing file\nlfa_rd_to_md(\"path/to/your/file.Rd\", \"path/to/existing/output/file.md\", append = TRUE)\n\n\n\nUsage\n\nlfa_rd_to_qmd(rdfile, outfile, append = FALSE)\n\n\n\n\nlfa_rd_to_results\nConvert Rd Files to Markdown and Merge Results\n\nDescription\nThis function converts all Rd (R documentation) files in the “man” directory to Markdown format (.qmd) and saves the converted files in the “results/appendix/package-docs” directory. It then merges the converted Markdown files into a single string and saves the merged content into a file named “docs.qmd” in the “results/appendix/package-docs” directory.\n\n\nDetails\nThe function performs the following steps:\n\nRemoves any existing “docs.qmd” file in the “results/appendix/package-docs” directory.\nFinds all Rd files in the “man” directory.\nConverts each Rd file to Markdown format (.qmd) using the lfa_rd_to_qmd function.\nSaves the converted Markdown files in the “results/appendix/package-docs” directory.\nMerges the content of all converted Markdown files into a single string.\nSaves the merged content into a file named “docs.qmd” in the “results/appendix/package-docs” directory.\n\n\n\nSeealso\nlfa_rd_to_qmd , lfa_merge_and_save\n\n\nValue\nThis function does not explicitly return any value. It performs the conversion, merging, and saving operations as described in the details section.\n\n\nExamples\n\n# Convert Rd files to Markdown and merge the results\nlfa_rd_to_results()\n\n\n\nUsage\n\nlfa_rd_to_results()\n\n\n\n\nlfa_read_area_as_catalog\nRead LiDAR data from a specified species and location as a catalog.\n\nArguments\n\n\n\n\n\n\n\nArgument\nDescription\n\n\n\n\nspecie\nA character string specifying the species of interest.\n\n\nlocation_name\nA character string specifying the name of the location.\n\n\n\n\n\nDescription\nThis function constructs the file path based on the specified specie and location_name , lists the directories at that path, and reads the LiDAR data into a lidR::LAScatalog .\n\n\nValue\nA lidR::LAScatalog object containing the LiDAR data from the specified location and species.\n\n\nExamples\n\nlfa_read_area_as_catalog(\"beech\", \"location1\")\n\n\n\nUsage\n\nlfa_read_area_as_catalog(specie, location_name)\n\n\n\n\nlfa_segmentation\nSegment the elements of an point cloud by trees\n\nArguments\n\n\n\n\n\n\n\nArgument\nDescription\n\n\n\n\nctg\nAn LASCatalog object. If not null, it will perform the actions on this object, if NULL inferring the catalog from the tile_location\n\n\ntile_location\nA tile_location type object holding the information about the location of the catalog. This is used to save the catalog after processing too.\n\n\n\n\n\nAuthor\nJakob Danel\n\n\nDescription\nThis function will try to to divide the hole point cloud into unique trees. Therefore it is assigning for each chunk of the catalog a treeID for each point. Therefore the algorithm uses the li2012 implementation with the following parameters: li2012(dt1 = 2, dt2 = 3, R = 2, Zu = 10, hmin = 5, speed_up = 12) NOTE : The operation is in place and can not be reverted, the old values of the point cloud will be deleted!\n\n\nValue\nA catalog where each chunk has additional treeID values indicating the belonging tree.\n\n\nUsage\n\nlfa_segmentation(ctg, tile_location)\n\n\n\n\nlfa_set_flag\nSet a flag to indicate the completion of a specific process.\n\nArguments\n\n\n\n\n\n\n\nArgument\nDescription\n\n\n\n\nflag_name\nA character string specifying the name of the flag file. It should be a descriptive and unique identifier for the process being flagged.\n\n\n\n\n\nDescription\nThis function creates a hidden flag file at a specified location within the working directory to indicate that a particular processing step has been completed. If the flag file already exists, a warning is issued.\n\n\nValue\nThis function does not have a formal return value.\n\n\nExamples\n\n# Set the flag for a process named \"data_processing\"\nlfa_set_flag(\"data_processing\")\n\n\n\nUsage\n\nlfa_set_flag(flag_name)"
  },
  {
    "objectID": "results/researched-areas.html",
    "href": "results/researched-areas.html",
    "title": "",
    "section": "",
    "text": "Code\nlibrary(ggplot2)\nsf::sf_use_s2(FALSE)\npatches &lt;- sf::read_sf(\"research_areas.shp\") |&gt; sf::st_centroid()\n\nde &lt;- sf::read_sf(\"results/results/states_de/Bundesländer_2017_mit_Einwohnerzahl.shp\") # Source: https://hub.arcgis.com/datasets/esri-de-content::bundesl%C3%A4nder-2017-mit-einwohnerzahl/explore?location=51.099647%2C10.454033%2C7.43\nnrw &lt;- de[5,] |&gt; sf::st_geometry()\n\n\nggplot() + geom_sf(data = nrw) + \n    geom_sf(data = patches, mapping = aes(col = species))\n\n\n\n\n\nFigure 1: Locations of the different patches with the dominant species for that patch. The patches centroids are displayed on a basemap describing the borders from NRW.\n\n\n\n\nWe draw three patches for each species from different regions (see Table 1). We download the LiDAR data for those patches and runned all preprocessing steps as described. We than checked with certain derived parameters (e.g. tree heights, tree distributions or tree density) that all patches contain valid forest data. In that step we discovered, that in one patch some forest clearance took place in the near past. This patch was removed from the dataset and was replaced with a new one.\nIn our research, drawing patches evenly distributed across Nordrhein-Westfalia is inherently constrained by natural factors. Consequently, the patches for oak and pine predominantly originate from the Münsterland region, as illustrated in Figure 1. For spruce, the patches were derived from Sauerland, reflecting the prevalence of spruce forests in this specific region within NRW, as corroborated by Welle et al. [@welle2014] and Blickensdörfer et al. [@Blickensdoerfer2022]. Beech patches, on the other hand, were generated from diverse locations within NRW. Across all patches, no human-made objects were identified, with the exception of small paths for pedestrians and forestry vehicles.\nThe distribution of area and detections is notable for each four species. Beech covers 69,791.9 hectares with a total of 5,954 detections, oak spans 63,232.49 hectares with 5,354 detections, pine extends across 72,862.4 hectares with 8,912 detections, and spruce encompasses 57,940.02 hectares with 8,619 detections. Both the amount of detections and the corresponding area exhibit a relatively uniform distribution across the diverse patches, as summarized in Table 1.\nWith the selected dataset described, we intentionally chose three patches for each four species that exhibit a practical and usable size for our research objectives. These carefully chosen patches align with the conditions essential for our study, providing comprehensive and representative data for in-depth analysis and meaningful insights into the characteristics of each tree species within the specified areas.\n\n\nCode\nshp &lt;- sf::read_sf(\"research_areas.shp\")\ntable &lt;- lfa::lfa_get_all_areas()\n\nsf::sf_use_s2(FALSE)\nfor (row in 1:nrow(table)) {\n  area &lt;-\n    dplyr::filter(shp, shp$species == table[row, \"specie\"] &\n                    shp$name == table[row, \"area\"])\n  area_size &lt;- area |&gt; sf::st_area()\n  point &lt;- area |&gt; sf::st_centroid() |&gt; sf::st_coordinates()\n  table[row,\"point\"] &lt;- paste0(\"(\",round(point[1], digits = 4),\", \",round(point[2],digits = 4),\")\")\n  \n  table[row, \"area_size\"] = round(area_size,digits = 2) #paste0(round(area_size,digits = 2), \" m²\")\n  \n  amount_det &lt;- nrow(lfa::lfa_get_detection_area(table[row, \"specie\"], table[row, \"area\"]))\n  if(is.null(amount_det)){\n    cat(nrow(lfa::lfa_get_detection_area(table[row, \"specie\"], table[row, \"area\"])),table[row, \"specie\"],table[row, \"area\"])\n  }\n  table[row, \"amount_detections\"] = amount_det\n  \n  # table[row, \"specie\"] &lt;- lfa::lfa_capitalize_first_char(table[row,\"specie\"])\n  table[row, \"area\"] &lt;- lfa::lfa_capitalize_first_char(table[row,\"area\"])\n  }\ntable$area &lt;- gsub(\"_\", \" \", table$area)\ntable$area &lt;- gsub(\"ue\", \"ü\", table$area)\ntable = table[,!names(table) %in% c(\"specie\")]\n\nknitr::kable(table, \"html\", col.names = c(\"Patch Name\",\"Location\",\"Area size (m²)\",\"Amount tree detections\" ), caption = NULL, digits = 2, escape = TRUE) |&gt;\n  kableExtra::kable_styling(\n    bootstrap_options = c(\"striped\", \"hold_position\", \"bordered\",\"responsive\"),\n    stripe_index = c(1:3,7:9),\n    full_width = FALSE\n  ) |&gt;\n  kableExtra::pack_rows(\"Beech\", 1, 3) |&gt;\n  kableExtra::pack_rows(\"Oak\", 4, 6) |&gt;\n  kableExtra::pack_rows(\"Pine\", 7, 9) |&gt;\n  kableExtra::pack_rows(\"Spruce\", 10, 12) |&gt;\n  kableExtra::column_spec(1, bold = TRUE)\n\n\n\n\n\nTable 1: Summary of researched patches grouped by species, with their location, area and the amount of detected trees.\n\n\nPatch Name\nLocation\nArea size (m²)\nAmount tree detections\n\n\n\n\nBeech\n\n\nBielefeld brackwede\n(8.5244, 51.9902)\n161410.57\n1443\n\n\nBillerbeck\n(7.3273, 51.9987)\n185887.25\n1732\n\n\nWülfenrath\n(7.0769, 51.2917)\n350621.21\n2779\n\n\nOak\n\n\nHamm\n(7.8618, 51.6639)\n269397.22\n2441\n\n\nMünster\n(7.6187, 51.9174)\n164116.61\n1270\n\n\nRinkerode\n(7.6744, 51.8598)\n198811.09\n1643\n\n\nPine\n\n\nGreffen\n(8.1697, 51.9913)\n49418.81\n513\n\n\nMesum\n(7.5403, 52.2573)\n405072.85\n5031\n\n\nTelgte\n(7.7816, 52.0024)\n274132.34\n3368\n\n\nSpruce\n\n\nBrilon\n(8.5352, 51.4084)\n211478.20\n3342\n\n\nOberhundem\n(8.1861, 51.0909)\n151895.53\n2471\n\n\nOsterwald\n(8.3721, 51.2151)\n216026.43\n2806"
  },
  {
    "objectID": "results/researched-areas.html#researched-areas",
    "href": "results/researched-areas.html#researched-areas",
    "title": "",
    "section": "",
    "text": "Code\nlibrary(ggplot2)\nsf::sf_use_s2(FALSE)\npatches &lt;- sf::read_sf(\"research_areas.shp\") |&gt; sf::st_centroid()\n\nde &lt;- sf::read_sf(\"results/results/states_de/Bundesländer_2017_mit_Einwohnerzahl.shp\") # Source: https://hub.arcgis.com/datasets/esri-de-content::bundesl%C3%A4nder-2017-mit-einwohnerzahl/explore?location=51.099647%2C10.454033%2C7.43\nnrw &lt;- de[5,] |&gt; sf::st_geometry()\n\n\nggplot() + geom_sf(data = nrw) + \n    geom_sf(data = patches, mapping = aes(col = species))\n\n\n\n\n\nFigure 1: Locations of the different patches with the dominant species for that patch. The patches centroids are displayed on a basemap describing the borders from NRW.\n\n\n\n\nWe draw three patches for each species from different regions (see Table 1). We download the LiDAR data for those patches and runned all preprocessing steps as described. We than checked with certain derived parameters (e.g. tree heights, tree distributions or tree density) that all patches contain valid forest data. In that step we discovered, that in one patch some forest clearance took place in the near past. This patch was removed from the dataset and was replaced with a new one.\nIn our research, drawing patches evenly distributed across Nordrhein-Westfalia is inherently constrained by natural factors. Consequently, the patches for oak and pine predominantly originate from the Münsterland region, as illustrated in Figure 1. For spruce, the patches were derived from Sauerland, reflecting the prevalence of spruce forests in this specific region within NRW, as corroborated by Welle et al. [@welle2014] and Blickensdörfer et al. [@Blickensdoerfer2022]. Beech patches, on the other hand, were generated from diverse locations within NRW. Across all patches, no human-made objects were identified, with the exception of small paths for pedestrians and forestry vehicles.\nThe distribution of area and detections is notable for each four species. Beech covers 69,791.9 hectares with a total of 5,954 detections, oak spans 63,232.49 hectares with 5,354 detections, pine extends across 72,862.4 hectares with 8,912 detections, and spruce encompasses 57,940.02 hectares with 8,619 detections. Both the amount of detections and the corresponding area exhibit a relatively uniform distribution across the diverse patches, as summarized in Table 1.\nWith the selected dataset described, we intentionally chose three patches for each four species that exhibit a practical and usable size for our research objectives. These carefully chosen patches align with the conditions essential for our study, providing comprehensive and representative data for in-depth analysis and meaningful insights into the characteristics of each tree species within the specified areas.\n\n\nCode\nshp &lt;- sf::read_sf(\"research_areas.shp\")\ntable &lt;- lfa::lfa_get_all_areas()\n\nsf::sf_use_s2(FALSE)\nfor (row in 1:nrow(table)) {\n  area &lt;-\n    dplyr::filter(shp, shp$species == table[row, \"specie\"] &\n                    shp$name == table[row, \"area\"])\n  area_size &lt;- area |&gt; sf::st_area()\n  point &lt;- area |&gt; sf::st_centroid() |&gt; sf::st_coordinates()\n  table[row,\"point\"] &lt;- paste0(\"(\",round(point[1], digits = 4),\", \",round(point[2],digits = 4),\")\")\n  \n  table[row, \"area_size\"] = round(area_size,digits = 2) #paste0(round(area_size,digits = 2), \" m²\")\n  \n  amount_det &lt;- nrow(lfa::lfa_get_detection_area(table[row, \"specie\"], table[row, \"area\"]))\n  if(is.null(amount_det)){\n    cat(nrow(lfa::lfa_get_detection_area(table[row, \"specie\"], table[row, \"area\"])),table[row, \"specie\"],table[row, \"area\"])\n  }\n  table[row, \"amount_detections\"] = amount_det\n  \n  # table[row, \"specie\"] &lt;- lfa::lfa_capitalize_first_char(table[row,\"specie\"])\n  table[row, \"area\"] &lt;- lfa::lfa_capitalize_first_char(table[row,\"area\"])\n  }\ntable$area &lt;- gsub(\"_\", \" \", table$area)\ntable$area &lt;- gsub(\"ue\", \"ü\", table$area)\ntable = table[,!names(table) %in% c(\"specie\")]\n\nknitr::kable(table, \"html\", col.names = c(\"Patch Name\",\"Location\",\"Area size (m²)\",\"Amount tree detections\" ), caption = NULL, digits = 2, escape = TRUE) |&gt;\n  kableExtra::kable_styling(\n    bootstrap_options = c(\"striped\", \"hold_position\", \"bordered\",\"responsive\"),\n    stripe_index = c(1:3,7:9),\n    full_width = FALSE\n  ) |&gt;\n  kableExtra::pack_rows(\"Beech\", 1, 3) |&gt;\n  kableExtra::pack_rows(\"Oak\", 4, 6) |&gt;\n  kableExtra::pack_rows(\"Pine\", 7, 9) |&gt;\n  kableExtra::pack_rows(\"Spruce\", 10, 12) |&gt;\n  kableExtra::column_spec(1, bold = TRUE)\n\n\n\n\n\nTable 1: Summary of researched patches grouped by species, with their location, area and the amount of detected trees.\n\n\nPatch Name\nLocation\nArea size (m²)\nAmount tree detections\n\n\n\n\nBeech\n\n\nBielefeld brackwede\n(8.5244, 51.9902)\n161410.57\n1443\n\n\nBillerbeck\n(7.3273, 51.9987)\n185887.25\n1732\n\n\nWülfenrath\n(7.0769, 51.2917)\n350621.21\n2779\n\n\nOak\n\n\nHamm\n(7.8618, 51.6639)\n269397.22\n2441\n\n\nMünster\n(7.6187, 51.9174)\n164116.61\n1270\n\n\nRinkerode\n(7.6744, 51.8598)\n198811.09\n1643\n\n\nPine\n\n\nGreffen\n(8.1697, 51.9913)\n49418.81\n513\n\n\nMesum\n(7.5403, 52.2573)\n405072.85\n5031\n\n\nTelgte\n(7.7816, 52.0024)\n274132.34\n3368\n\n\nSpruce\n\n\nBrilon\n(8.5352, 51.4084)\n211478.20\n3342\n\n\nOberhundem\n(8.1861, 51.0909)\n151895.53\n2471\n\n\nOsterwald\n(8.3721, 51.2151)\n216026.43\n2806"
  },
  {
    "objectID": "methods/data-aquisition.html",
    "href": "methods/data-aquisition.html",
    "title": "",
    "section": "",
    "text": "Our primary objective is to identify patches where one tree species exhibits a high level of dominance, striving to capture monocultural stands within the diverse forests of Nordrhein-Westfalia (NRW). Recognizing the practical challenges of finding true monocultures, we aim to identify patches where one species is highly dominant, enabling meaningful comparisons across different species.\nThe study is framed within the NRW region due to the availability of an easily accessible dataset. Our focus includes four prominent tree species in NRW: oak, beech, spruce, and pine, representing the most prevalent species in the region. To ensure the validity of our findings, we derive three patches for each species, thereby confirming that observed variables are characteristic of a particular species rather than a specific patch. Each patch is carefully selected to encompass an area of approximately 50-100 hectares and contain between 5,000 and 10,000 trees. Striking a balance between relevance and manageability, these patches avoid excessive size to enhance the likelihood of capturing varied species mixes and ensure compatibility with local hardware.\nSpecific Goals:\n\nRetrieve patches with highly dominant tree species.\nMinimize or eliminate the presence of human-made structures within the selected patches.\n\nTo achieve our goals, we utilized the waldmonitor dataset [@welle2014] and the map provided by [@Blickensdoerfer2022], both indicating dominant tree species in NRW. We identified patches of feasible size where both sources predicted the presence of a specific species. Further validation involved examining sentinel images of these forest regions to assess the evenness of structures, leaf color distribution, and the absence of significant human-made structures such as roads or buildings. The subsequent preprocessing steps, detailed in the following subsection, involved refining our selected patches and deriving relevant variables, such as tree distribution and density, to ensure that the chosen areas align with the desired research domains."
  },
  {
    "objectID": "methods/data-aquisition.html#data-acquisition",
    "href": "methods/data-aquisition.html#data-acquisition",
    "title": "",
    "section": "",
    "text": "Our primary objective is to identify patches where one tree species exhibits a high level of dominance, striving to capture monocultural stands within the diverse forests of Nordrhein-Westfalia (NRW). Recognizing the practical challenges of finding true monocultures, we aim to identify patches where one species is highly dominant, enabling meaningful comparisons across different species.\nThe study is framed within the NRW region due to the availability of an easily accessible dataset. Our focus includes four prominent tree species in NRW: oak, beech, spruce, and pine, representing the most prevalent species in the region. To ensure the validity of our findings, we derive three patches for each species, thereby confirming that observed variables are characteristic of a particular species rather than a specific patch. Each patch is carefully selected to encompass an area of approximately 50-100 hectares and contain between 5,000 and 10,000 trees. Striking a balance between relevance and manageability, these patches avoid excessive size to enhance the likelihood of capturing varied species mixes and ensure compatibility with local hardware.\nSpecific Goals:\n\nRetrieve patches with highly dominant tree species.\nMinimize or eliminate the presence of human-made structures within the selected patches.\n\nTo achieve our goals, we utilized the waldmonitor dataset [@welle2014] and the map provided by [@Blickensdoerfer2022], both indicating dominant tree species in NRW. We identified patches of feasible size where both sources predicted the presence of a specific species. Further validation involved examining sentinel images of these forest regions to assess the evenness of structures, leaf color distribution, and the absence of significant human-made structures such as roads or buildings. The subsequent preprocessing steps, detailed in the following subsection, involved refining our selected patches and deriving relevant variables, such as tree distribution and density, to ensure that the chosen areas align with the desired research domains."
  },
  {
    "objectID": "report.html#n-nearest-neighbours",
    "href": "report.html#n-nearest-neighbours",
    "title": "Forest Data Analysis Report",
    "section": "3.4 n-nearest Neighbours",
    "text": "3.4 n-nearest Neighbours\n\n\nCode\nneighbors &lt;- lfa::lfa_combine_sf_obj(lfa::lfa_get_neighbor_paths(),lfa::lfa_get_all_areas())\n\n\n\n3.4.1 Overview\nTo initiate our analysis, we first establish a framework for selecting neighbors by examining the distance development with different n, as illustrated in Figure 6. The curves share a similar design, but the actual values vary. Notably, as n increases, the distance between all patches also increases, indicating a broader spatial context.\nConsidering this trend, we extend our investigation beyond the nearest neighbor to include the 100th nearest neighbor. The \\(\\Delta\\)distance shows a consistent decrease with each increment in n, reinforcing our decision to limit exploration beyond n of a hundred. Additionally, the constraint is driven by practical considerations, as our sample size occasionally lacks the capacity to explore larger n values, resulting in inaccurate values due to the absence of the true nearest neighbor within the sample area.\n\n\nCode\nlfa::lfa_create_neighbor_mean_curves(neighbors) |&gt; lfa::lfa_create_plot_per_area()\n\n\n\n\n\nFigure 6: Average Distance to n-nearest neighbor from each patch. For simplicity colored by the dominant specie of each tree.\n\n\n\n\n\n\n3.4.2 The Nearest Neighbour\nOur initial focus centers on examining the distance to the nearest neighbor for each tree. Notably, the curve representing Spruce exhibits distinct characteristics compared to the three other curves—displaying a steeper profile with less variance, as depicted in Figure 7.\nFurther analysis of all patches reveals similar distributions, as evident in the boxplot shown in Figure 2 (Figure 8), where mean and variance demonstrate consistency across patches. However, these graphical statistics present challenges in effectively distinguishing between different tree species based on the distance to the nearest neighbor.\n\n\nCode\nlfa::lfa_create_density_plots(neighbors,value_column = \"Neighbor_1\",category_column1 = \"area\",category_column2 = \"specie\", title = \"Density plots for the nearest neighbor among species and areas\", xlims = c(0,15))\n\n\n\n\n\nFigure 7: Density plot of the distance to the nearest neighbor distribution across all patches grouped by the dominant species.\n\n\n\n\n\n\nCode\nlfa::lfa_create_boxplot(neighbors,value_column = \"Neighbor_1\",category_column1 = \"area\",category_column2 = \"specie\", title = \"Box plots for the nearest neighbor among species and areas\")\n\n\n\n\n\nFigure 8: Density plot of the distance to the nearest neighbor distribution across all patches grouped by the dominant species.\n\n\n\n\n\n\n3.4.3 The 100th nearest Neighbor\nMoving on to the analysis of the 100th nearest neighbor, intriguing patterns emerge. Peaks in the curves display varying heights and positions, with a notable example being the complete shift between Oak and Spruce, as illustrated in Figure 9.\nHowever, it is essential to acknowledge the high variance observed between curves within a species, such as Pine or Beech. While this variance could serve as a potential indicator, it comes with the caveat that the sample size must be substantial for reliable conclusions.\nExamining boxplots reveals numerous outliers above the boxes, hinting at potential edge effects on the sides of patches. This observation raises concerns about the adequacy of trees in these areas for a more in-depth analysis, posing challenges in deriving accurate insights.\n\n\nCode\nlfa::lfa_create_density_plots(neighbors,value_column = \"Neighbor_100\",category_column1 = \"area\",category_column2 = \"specie\", title = \"Density plots for the nearest neighbor along species and areas\", xlims = c(35,100))\n\n\n\n\n\nFigure 9: Density plot of the distance to the nearest neighbor distribution across all patches grouped by the dominant species.\n\n\n\n\n\n\nCode\nlfa::lfa_create_boxplot(neighbors,value_column = \"Neighbor_100\",category_column1 = \"area\",category_column2 = \"specie\", title = \"Box plots for the nearest neighbor along species and areas\")\n\n\n\n\n\nFigure 10: Density plot of the distance to the nearest neighbor distribution across all patches grouped by the dominant species.\n\n\n\n\n\nAverage distance to 100 nearest neighbors\n\n\nCode\nnames &lt;- paste0(\"Neighbor_\",1:100)\nneighbors$avg = rowMeans(dplyr::select(as.data.frame(neighbors),names))\n\n\nTurning our attention to the averages of the first 100 neighbors, our analysis indicates strikingly similar results. There is considerable variance observed between different species, as well as within individual species, as depicted in Figure 11.\nDespite the uniformity in average results, the issue of outliers persists, as evident in the boxplot representation shown in Figure 12. These outliers pose challenges and may be indicative of specific environmental conditions affecting tree distributions. Further exploration is required to better understand and mitigate the impact of outliers on our analysis.\n\n\nCode\nlfa::lfa_create_density_plots(neighbors,value_column = \"avg\",category_column1 = \"area\",category_column2 = \"specie\", title = \"Density plots for the average of 100 nearest neighbors\", xlims = c(25,60))\n\n\n\n\n\nFigure 11: Density plot of the average distance to the nearest neighbor (n=100) distribution across all patches grouped by the dominant species.\n\n\n\n\nThe neighbor analysis proves potentially useful for distinguishing between tree species, yet the observed variances within each species suggest that relying solely on distance to neighbors may not suffice.\nA critical consideration is the sample size problem, wherein more distinguishable patterns emerge with higher neighbor levels, but this necessitates a sufficiently large sample size. Unfortunately, deriving a clear relationship between sample size and the number of tree neighbors remains elusive in our current findings. This gap in understanding could be a pertinent subject for further research, delving into the intricate interplay between sample size and the effectiveness of neighbor analysis in species differentiation.\n\n\nCode\nlfa::lfa_create_boxplot(neighbors,value_column = \"avg\",category_column1 = \"area\",category_column2 = \"specie\", title = \"Box plots for the average to the nearest neighbor across all species and areas\")\n\n\n\n\n\nFigure 12: Density plot of the average distance to the nearest neighbor (n = 100) distribution across all patches grouped by the dominant species.\n\n\n\n\n\n\n\n3.4.4 Density of forest patches\nExamining densities provides valuable insights into identifying the dominant species within patches. Spruce stands out as the densest species, surpassing all other patches. Following closely in density is Pine, as depicted in Figure 1 (Figure 13).\nBeech and Oak exhibit similar density levels, with Beech consistently denser across all patches. When comparing the highest density patches for each species, Beech consistently outpaces Oak. While Oak is slightly less dense overall (\\(8.354499 \\times 10^{-3} \\frac{1}{m^2}\\)) than Beech (\\(8.727781 \\times 10^{-3} \\frac{1}{m^2}\\)), the distinction in density remains noticeable.\n\n\nCode\nlibrary(units)\nlfa::lfa_calculate_patch_density() |&gt;\n  lfa::lfa_create_grouped_bar_plot(grouping_var = \"species\", value_col = \"density\", label_col = \"name\")\n\n\n\n\n\nFigure 13: Barplot of the densitys of all patches (#detected trees/area of patch). Colorized by the dominant tree species of each patch.\n\n\n\n\nIn summary, our findings indicate that the density of each patch proves highly effective in distinguishing dominant species. Furthermore, the differentiation between conifers (Pine and Spruce) and deciduous trees (Beech and Oak) based on density aligns with patterns observed in the number of return points per detected tree. While distinguishing within conifers is straightforward, discerning between the deciduous tree species Beech and Oak, is possible but poses a moderate challenge.\n\n\n3.4.5 Canopy Height Model\n\n\nCode\nchms &lt;- lfa::lfa_visit_all_areas(lfa::lfa_chm)\n\n\n\n\nCode\npatches &lt;- lfa::lfa_get_all_areas()\npatches$chm_mean = NA\npatches$chm_var = NA\npatches$chm_median = NA\nfor (area_key in names(chms)) {\n  area &lt;- chms[area_key]\n  area[[area_key]] |&gt; as.vector() -&gt; vec\n  patches[patches$area == area_key, \"chm_mean\"] &lt;-\n    mean(vec, na.rm = T)\n  patches[patches$area == area_key, \"chm_var\"] &lt;-\n    var(vec, na.rm = T)\n  patches[patches$area == area_key, \"chm_median\"] &lt;-\n    median(vec, na.rm = T)\n  \n}\n\n\n\n\nCode\nlfa::lfa_create_grouped_bar_plot(patches,\"specie\",\"chm_mean\",\"area\",ylab = \"Mean\", title = \"Mean Canopy Height\")\n\n\n\n\n\nFigure 14: Mean Canopy Height across all patches colored by the dominant specie of each patch.\n\n\n\n\n\n\nCode\nlfa::lfa_create_grouped_bar_plot(patches,\"specie\",\"chm_var\",\"area\",ylab = \"Variance\", title = \"Variance of Canopy Height\")\n\n\n\n\n\nFigure 15: Variance Canopy Height across all patches colored by the dominant specie of each patch.\n\n\n\n\n\n\nCode\nlfa::lfa_create_grouped_bar_plot(patches,\"specie\",\"chm_median\",\"area\",ylab = \"Median\", title = \"Median Canopy Height\")\n\n\n\n\n\nFigure 16: Median Canopy Height across all patches colored by the dominant specie of each patch."
  },
  {
    "objectID": "report.html#random-forest",
    "href": "report.html#random-forest",
    "title": "Forest Data Analysis Report",
    "section": "3.3 Random forest",
    "text": "3.3 Random forest\n\nresults &lt;- lfa::lfa_random_forest(tree_data = neighbors,excluded_input_columns = c(\"geom\",\"species\",\"area\", \"treeID\"))\n\n[1] \"bielefeld_brackwede\"\npredictions\n beech    oak   pine spruce \n   146    744    532     21 \n[1] \"billerbeck\"\npredictions\n beech    oak   pine spruce \n   533    679     80    440 \n[1] \"wuelfenrath\"\npredictions\n beech    oak   pine spruce \n   383   2000    255    141 \n[1] \"hamm\"\npredictions\n beech    oak   pine spruce \n  1073    465    848     55 \n[1] \"muenster\"\npredictions\n beech    oak   pine spruce \n   866    345     21     38 \n[1] \"rinkerode\"\npredictions\n beech    oak   pine spruce \n   879    561    198      5 \n[1] \"greffen\"\npredictions\n beech    oak   pine spruce \n    66    111    327      9 \n[1] \"mesum\"\npredictions\n beech    oak   pine spruce \n   324    393   3260   1054 \n[1] \"telgte\"\npredictions\n beech    oak   pine spruce \n   176    214   2484    494 \n[1] \"brilon\"\npredictions\n beech    oak   pine spruce \n   252     58    265   2767 \n[1] \"oberhundem\"\npredictions\n beech    oak   pine spruce \n   154    128    249   1940 \n[1] \"osterwald\"\npredictions\n beech    oak   pine spruce \n   148    180   1344   1134 \n\nknitr::kable(results$predicted_species_absolute)\n\n\n\n\n\n\n\n\n\n\n\n\n\nknitr::kable(results$predicted_species_relative)\n\n\n\n\narea\nbeech\noak\npine\nspruce\nexpected_specie\nn\n\n\n\n\nbielefeld_brackwede\n0.1011781\n0.5155925\n0.3686764\n0.0145530\nbeech\n1443\n\n\nbillerbeck\n0.3077367\n0.3920323\n0.0461894\n0.2540416\nbeech\n1732\n\n\nbrilon\n0.0754039\n0.0173549\n0.0792938\n0.8279473\nspruce\n3342\n\n\ngreffen\n0.1286550\n0.2163743\n0.6374269\n0.0175439\npine\n513\n\n\nhamm\n0.4395739\n0.1904957\n0.3473986\n0.0225317\noak\n2441\n\n\nmesum\n0.0644007\n0.0781157\n0.6479825\n0.2095011\npine\n5031\n\n\nmuenster\n0.6818898\n0.2716535\n0.0165354\n0.0299213\noak\n1270\n\n\noberhundem\n0.0623229\n0.0518009\n0.1007689\n0.7851072\nspruce\n2471\n\n\nosterwald\n0.0527441\n0.0641483\n0.4789736\n0.4041340\nspruce\n2806\n\n\nrinkerode\n0.5349970\n0.3414486\n0.1205113\n0.0030432\noak\n1643\n\n\ntelgte\n0.0522565\n0.0635392\n0.7375297\n0.1466746\npine\n3368\n\n\nwuelfenrath\n0.1378194\n0.7196833\n0.0917596\n0.0507377\nbeech\n2779\n\n\n\n\n\n\n\n\nknitr::kable(results$confusion_matrix)\n\n\n\n\n\nbeech\noak\npine\nspruce\n\n\n\n\nbeech\n1062\n2818\n566\n554\n\n\noak\n3423\n1371\n718\n366\n\n\npine\n867\n1067\n6071\n1858\n\n\nspruce\n602\n98\n1557\n5841\n\n\n\n\n\n\n\n\nresults$accuracy\n\n[1] 0.4974167\n\n\n\n\n\nspecie\narea\ndensity (1/m²)\n\n\n\n\nbeech\nbielefeld_brackwede\n0.0089399\n\n\nbeech\nbillerbeck\n0.0093175\n\n\nbeech\nwuelfenrath\n0.0079259\n\n\noak\nhamm\n0.0090610\n\n\noak\nmuenster\n0.0077384\n\n\noak\nrinkerode\n0.0082641\n\n\npine\ngreffen\n0.0103807\n\n\npine\nmesum\n0.0124200\n\n\npine\ntelgte\n0.0122860\n\n\nspruce\nbrilon\n0.0158030\n\n\nspruce\noberhundem\n0.0162678\n\n\nspruce\nosterwald\n0.0129892"
  },
  {
    "objectID": "report.html#distribution-of-the-tree-heights",
    "href": "report.html#distribution-of-the-tree-heights",
    "title": "Forest Data Analysis Report",
    "section": "4.2 Distribution of the tree heights",
    "text": "4.2 Distribution of the tree heights\n\n\nCode\ndetections &lt;- lfa::lfa_get_detections()\n\n\nIn this study, we scrutinize the distribution of tree heights, focusing initially on the density distribution to unravel the nuances across various tree species. Notably, our examination reveals distinctive patterns, with Oak and Pine exhibiting significantly steeper peaks in their density curves compared to Beech and Spruce. While all species present unique density curves, a commonality emerges—each curve is characterized by a single peak, except for the intriguing exception observed in Telgte. Taking Beech as an illustrative example, our findings indicate a notable shift in the peak to a considerably higher extent. The varinace in the density curves indicating that an differencation between species only with the help oof tree height values could be difficult.\n\n\nCode\nlfa::lfa_create_density_plots(detections, value_column = \"Z\", category_column1 = \"area\", category_column2 = \"specie\", title = \"Density of the height distributions\", xlims = c(0,50))\n\n\n\n\n\nFigure 2: Density of the height distribitions of the detectected trees. Splitted by the different researched areas and grouped by the dominant specie in this area.\n\n\n\n\nTo have a deeper look into the distributions of those Z-values we will now also have a look into the boxplots of the height distrubutions in the different areas. Noteworthy observations include the presence of outliers beyond the extended range of the Whisker Antennas (\\(1.5*\\text{IQR}\\)) in all datasets. Of particular interest is the Rinkerode dataset, which exhibits a higher prevalence of outliers in the upper domain. Anomalies in this dataset are attributed to potential inaccuracies, urging a critical examination of data integrity. A pairwise examination of Oak and Pine species indicates higher mean heights for Oak compared to Pine. This insight underscores the significance of species-specific attributes in shaping overall height distributions. Further exploration into the factors contributing to these mean differences enhances our understanding of the unique characteristics inherent to each species. Contrary to expectations, the spread within a particular species does not exhibit significant divergence from the spread observed between different species. This finding suggests that while species-specific traits play a crucial role in shaping height distributions, certain overarching factors may contribute to shared patterns across diverse tree populations.\n\n\nCode\nlfa::lfa_create_boxplot(detections, value_column = \"Z\", category_column1 = \"area\", category_column2 = \"specie\", title = \"Boxplots of the height distributions\")\n\n\n\n\n\nFigure 3: Boxplots of the height distribitions of the detectected trees. Splitted by the different researched areas and grouped by the dominant specie in this area.\n\n\n\n\nOur examination of Kullback-Leibler Divergence (KLD) and Jensen-Shannon Divergence (JSD) metrics reveals low mean values (KLD: 5.252696, JSD: 2.246663) across different species, indicating overall similarity in tree species height distributions. However, within specific species, particularly Pine, higher divergence values (see Table 5 and Table 10) suggest significant intraspecific differences.\nNotably, the Spruce species consistently demonstrates low divergence values across all tested areas, implying a high level of explainability. This finding highlights tree height as a reliable indicator for detecting Spruce trees, indicating its potential for accurate species identification in diverse forest ecosystems."
  },
  {
    "objectID": "report.html#quantitative-results",
    "href": "report.html#quantitative-results",
    "title": "Evaluating Tree Species Diversity in Forest Ecosystems Using LiDAR Data: A Exploration in NRW",
    "section": "6.4 Quantitative Results",
    "text": "6.4 Quantitative Results\n\n6.4.1 Distribution of Z-Values\n\n\nCode\ndata &lt;- lfa::lfa_get_detections()\nvalue_column &lt;- \"Z\"\n\n\n\nKullback-Leibler-Divergence\n\n\nCode\nkld_results_specie &lt;- lfa::lfa_run_test_asymmetric(data,value_column,\"specie\",lfa::lfa_kld_from_vec)\nlfa::lfa_generate_result_table_tests(kld_results_specie,\"Kullback-Leibler-Divergence between species\")\n\n\n\n\nTable 2: Kullback-Leibler-Divergence between the researched species Beech, Oak, Pine and Spruce for the atrribute z-values\n\n\n\nBeech\nOak\nPine\nSpruce\n\n\n\n\nBeech\n0.0\n13.2\n12.5\n0.76\n\n\nOak\n4.2\n0.0\n3.4\n5.02\n\n\nPine\n2.3\n5.6\n0.0\n3.95\n\n\nSpruce\n2.4\n14.7\n16.1\n0.00\n\n\n\n\n\n\n\n\n\ncolMeans(kld_results_specie, na.rm = TRUE) |&gt; mean()\n\n[1] 5.252696\n\n\n\n\nCode\nspecie &lt;- data[data$specie==\"beech\",]\nkld_results_beech &lt;- lfa::lfa_run_test_asymmetric(specie,value_column,\"area\",lfa::lfa_kld_from_vec)\nlfa::lfa_generate_result_table_tests(kld_results_beech,\"Kullback-Leibler-Divergence between areas with beech\")\n\n\n\n\nTable 3: Kullback-Leibler-Divergence between the researched areas which have the dominante specie beech for the atrribute z-values\n\n\n\nBielefeld_brackwede\nBillerbeck\nWuelfenrath\n\n\n\n\nBielefeld_brackwede\n0.00\n0.4\n3.1\n\n\nBillerbeck\n0.27\n0.0\n6.0\n\n\nWuelfenrath\n1.13\n2.4\n0.0\n\n\n\n\n\n\n\n\n\ncolMeans(kld_results_beech, na.rm = TRUE) |&gt; mean()\n\n[1] 1.473353\n\n\n\n\nCode\nspecie &lt;- data[data$specie==\"oak\",]\nkld_results_oak &lt;- lfa::lfa_run_test_asymmetric(specie,value_column,\"area\",lfa::lfa_kld_from_vec)\nlfa::lfa_generate_result_table_tests(kld_results_oak,\"Kullback-Leibler-Divergence between areas with oak\")\n\n\n\n\nTable 4: Kullback-Leibler-Divergence between the researched areas which have the dominante specie oak for the atrribute z-values\n\n\n\nHamm\nMuenster\nRinkerode\n\n\n\n\nHamm\n0.0\n2.1\n16\n\n\nMuenster\n0.4\n0.0\n17\n\n\nRinkerode\n7.6\n17.8\n0\n\n\n\n\n\n\n\n\n\ncolMeans(kld_results_oak, na.rm = TRUE) |&gt; mean()\n\n[1] 6.779863\n\n\n\n\nCode\nspecie &lt;- data[data$specie==\"pine\",]\nkld_results_pine &lt;- lfa::lfa_run_test_asymmetric(specie,value_column,\"area\",lfa::lfa_kld_from_vec)\nlfa::lfa_generate_result_table_tests(kld_results_pine,\"Kullback-Leibler-Divergence between areas with pine\")\n\n\n\n\nTable 5: Kullback-Leibler-Divergence between the researched areas which have the dominante specie pine for the atrribute z-values\n\n\n\nGreffen\nMesum\nTelgte\n\n\n\n\nGreffen\n0.00\n0.74\n16\n\n\nMesum\n0.43\n0.00\n18\n\n\nTelgte\n3.87\n6.82\n0\n\n\n\n\n\n\n\n\n\ncolMeans(kld_results_pine, na.rm = TRUE) |&gt; mean()\n\n[1] 5.129383\n\n\n\n\nCode\nspecie &lt;- data[data$specie==\"spruce\",]\nkld_results_spruce &lt;- lfa::lfa_run_test_asymmetric(specie,value_column,\"area\",lfa::lfa_kld_from_vec)\nlfa::lfa_generate_result_table_tests(kld_results_spruce,\"Kullback-Leibler-Divergence between areas with spruce\")\n\n\n\n\nTable 6: Kullback-Leibler-Divergence between the researched areas which have the dominante specie spruce for the atrribute z-values\n\n\n\nBrilon\nOberhundem\nOsterwald\n\n\n\n\nBrilon\n0.000\n0.092\n1.7\n\n\nOberhundem\n0.081\n0.000\n2.1\n\n\nOsterwald\n1.521\n2.178\n0.0\n\n\n\n\n\n\n\n\n\ncolMeans(kld_results_spruce, na.rm = TRUE) |&gt; mean()\n\n[1] 0.8509258\n\n\n\n\nJensen-Shannon Divergence\n\n\nCode\njsd_results_specie &lt;- lfa::lfa_run_test_symmetric(data,value_column,\"specie\",lfa::lfa_jsd_from_vec)\nlfa::lfa_generate_result_table_tests(jsd_results_specie,\"Jensen-Shannon Divergence between species\")\n\n\n\n\nTable 7: Jensen-Shannon Divergence between the researched species Beech, Oak, Pine and Spruce for the atrribute z-values\n\n\n\nBeech\nOak\nPine\nSpruce\n\n\n\n\nBeech\n0\n4.5\n4.6\n2.4\n\n\nOak\nNA\n0.0\n3.9\n6.1\n\n\nPine\nNA\nNA\n0.0\n7.1\n\n\nSpruce\nNA\nNA\nNA\n0.0\n\n\n\n\n\n\n\n\n\ncolMeans(jsd_results_specie, na.rm = TRUE) |&gt; mean()\n\n[1] 2.246663\n\n\n\n\nCode\nspecie &lt;- data[data$specie==\"beech\",]\njsd_results_beech &lt;- lfa::lfa_run_test_symmetric(specie,value_column,\"area\",lfa::lfa_jsd_from_vec)\nlfa::lfa_generate_result_table_tests(jsd_results_beech,\"Jensen-Shannon Divergence between areas with beech\")\n\n\n\n\nTable 8: Jensen-Shannon Divergence between the researched areas which have the dominante specie beech for the atrribute z-values\n\n\n\nBielefeld_brackwede\nBillerbeck\nWuelfenrath\n\n\n\n\nBielefeld_brackwede\n0\n1.1\n3.3\n\n\nBillerbeck\nNA\n0.0\n4.9\n\n\nWuelfenrath\nNA\nNA\n0.0\n\n\n\n\n\n\n\n\n\ncolMeans(jsd_results_beech, na.rm = TRUE) |&gt; mean()\n\n[1] 1.10555\n\n\n\n\nCode\nspecie &lt;- data[data$specie==\"oak\",]\njsd_results_oak &lt;- lfa::lfa_run_test_symmetric(specie,value_column,\"area\",lfa::lfa_jsd_from_vec)\nlfa::lfa_generate_result_table_tests(jsd_results_oak,\"Jensen-Shannon Divergence between areas with oak\")\n\n\n\n\nTable 9: Jensen-Shannon Divergence between the researched areas which have the dominante specie oak for the atrribute z-values\n\n\n\nHamm\nMuenster\nRinkerode\n\n\n\n\nHamm\n0\n1.6\n6.5\n\n\nMuenster\nNA\n0.0\n6.4\n\n\nRinkerode\nNA\nNA\n0.0\n\n\n\n\n\n\n\n\n\ncolMeans(jsd_results_oak, na.rm = TRUE) |&gt; mean()\n\n[1] 1.692942\n\n\n\n\nCode\nspecie &lt;- data[data$specie==\"pine\",]\njsd_results_pine &lt;- lfa::lfa_run_test_symmetric(specie,value_column,\"area\",lfa::lfa_jsd_from_vec)\nlfa::lfa_generate_result_table_tests(jsd_results_pine,\"Jensen-Shannon Divergence between areas with pine\")\n\n\n\n\nTable 10: Jensen-Shannon Divergence between the researched areas which have the dominante specie pine for the atrribute z-values\n\n\n\nGreffen\nMesum\nTelgte\n\n\n\n\nGreffen\n0\n3.1\n12\n\n\nMesum\nNA\n0.0\n10\n\n\nTelgte\nNA\nNA\n0\n\n\n\n\n\n\n\n\n\ncolMeans(jsd_results_pine, na.rm = TRUE) |&gt; mean()\n\n[1] 2.956354\n\n\n\n\nCode\nspecie &lt;- data[data$specie==\"spruce\",]\njsd_results_spruce &lt;- lfa::lfa_run_test_symmetric(specie,value_column,\"area\",lfa::lfa_jsd_from_vec)\nlfa::lfa_generate_result_table_tests(jsd_results_spruce,\"Jensen-Shannon Divergence between areas with spruce\")\n\n\n\n\nTable 11: Jensen-Shannon Divergence between the researched areas which have the dominante specie spruce for the atrribute z-values\n\n\n\nBrilon\nOberhundem\nOsterwald\n\n\n\n\nBrilon\n0\n0.31\n4.0\n\n\nOberhundem\nNA\n0.00\n5.5\n\n\nOsterwald\nNA\nNA\n0.0\n\n\n\n\n\n\n\n\n\ncolMeans(jsd_results_spruce, na.rm = TRUE) |&gt; mean()\n\n[1] 1.100383\n\n\n\n\n\n6.4.2 Nearest Neighbours\n\nDistribution of nearest neighbor distances\n\n\nCode\ndata &lt;- lfa::lfa_combine_sf_obj(lfa::lfa_get_neighbor_paths(),lfa::lfa_get_all_areas())\n\n\nReading layer `neighbours' from data source \n  `/home/jakob/gi-master/project-courses/lidar-forest-analysis/src/data/beech/bielefeld_brackwede/neighbours.gpkg' \n  using driver `GPKG'\nSimple feature collection with 1443 features and 102 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 466999.8 ymin: 5759839 xmax: 467617.1 ymax: 5760261\nProjected CRS: ETRS89 / UTM zone 32N\nReading layer `neighbours' from data source \n  `/home/jakob/gi-master/project-courses/lidar-forest-analysis/src/data/beech/billerbeck/neighbours.gpkg' \n  using driver `GPKG'\nSimple feature collection with 1732 features and 102 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 384890.8 ymin: 5761918 xmax: 385590.9 ymax: 5762478\nProjected CRS: ETRS89 / UTM zone 32N\nReading layer `neighbours' from data source \n  `/home/jakob/gi-master/project-courses/lidar-forest-analysis/src/data/beech/wuelfenrath/neighbours.gpkg' \n  using driver `GPKG'\nSimple feature collection with 2779 features and 102 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 365546.3 ymin: 5683711 xmax: 366356.1 ymax: 5684321\nProjected CRS: ETRS89 / UTM zone 32N\nReading layer `neighbours' from data source \n  `/home/jakob/gi-master/project-courses/lidar-forest-analysis/src/data/oak/hamm/neighbours.gpkg' \n  using driver `GPKG'\nSimple feature collection with 2441 features and 102 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 420953.3 ymin: 5723884 xmax: 421596 ymax: 5724609\nProjected CRS: ETRS89 / UTM zone 32N\nReading layer `neighbours' from data source \n  `/home/jakob/gi-master/project-courses/lidar-forest-analysis/src/data/oak/muenster/neighbours.gpkg' \n  using driver `GPKG'\nSimple feature collection with 1270 features and 102 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 404615.6 ymin: 5752535 xmax: 405396.8 ymax: 5752971\nProjected CRS: ETRS89 / UTM zone 32N\nReading layer `neighbours' from data source \n  `/home/jakob/gi-master/project-courses/lidar-forest-analysis/src/data/oak/rinkerode/neighbours.gpkg' \n  using driver `GPKG'\nSimple feature collection with 1643 features and 102 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 408428.2 ymin: 5746021 xmax: 409014.8 ymax: 5746511\nProjected CRS: ETRS89 / UTM zone 32N\nReading layer `neighbours' from data source \n  `/home/jakob/gi-master/project-courses/lidar-forest-analysis/src/data/pine/greffen/neighbours.gpkg' \n  using driver `GPKG'\nSimple feature collection with 513 features and 102 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 442816.1 ymin: 5760217 xmax: 443148.9 ymax: 5760567\nProjected CRS: ETRS89 / UTM zone 32N\nReading layer `neighbours' from data source \n  `/home/jakob/gi-master/project-courses/lidar-forest-analysis/src/data/pine/mesum/neighbours.gpkg' \n  using driver `GPKG'\nSimple feature collection with 5031 features and 102 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 399930.6 ymin: 5790412 xmax: 400969.7 ymax: 5790950\nProjected CRS: ETRS89 / UTM zone 32N\nReading layer `neighbours' from data source \n  `/home/jakob/gi-master/project-courses/lidar-forest-analysis/src/data/pine/telgte/neighbours.gpkg' \n  using driver `GPKG'\nSimple feature collection with 3368 features and 102 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 416135.1 ymin: 5761663 xmax: 416697.1 ymax: 5762477\nProjected CRS: ETRS89 / UTM zone 32N\nReading layer `neighbours' from data source \n  `/home/jakob/gi-master/project-courses/lidar-forest-analysis/src/data/spruce/brilon/neighbours.gpkg' \n  using driver `GPKG'\nSimple feature collection with 3342 features and 102 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 467305.7 ymin: 5695055 xmax: 467996.9 ymax: 5695593\nProjected CRS: ETRS89 / UTM zone 32N\nReading layer `neighbours' from data source \n  `/home/jakob/gi-master/project-courses/lidar-forest-analysis/src/data/spruce/oberhundem/neighbours.gpkg' \n  using driver `GPKG'\nSimple feature collection with 2471 features and 102 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 442631.7 ymin: 5660096 xmax: 443309.5 ymax: 5660502\nProjected CRS: ETRS89 / UTM zone 32N\nReading layer `neighbours' from data source \n  `/home/jakob/gi-master/project-courses/lidar-forest-analysis/src/data/spruce/osterwald/neighbours.gpkg' \n  using driver `GPKG'\nSimple feature collection with 2806 features and 102 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 455822 ymin: 5673761 xmax: 456483.2 ymax: 5674162\nProjected CRS: ETRS89 / UTM zone 32N\n\n\nCode\nvalue_column &lt;- \"Neighbor_1\"\n\n\n\nKullback-Leibler-Divergence\n\n\nCode\nkld_results_specie &lt;- lfa::lfa_run_test_asymmetric(data,value_column,\"specie\",lfa::lfa_kld_from_vec)\nlfa::lfa_generate_result_table_tests(kld_results_specie,\"Kullback-Leibler-Divergence between species\")\n\n\n\n\nTable 12: Kullback-Leibler-Divergence between the researched species Beech, Oak, Pine and Spruce for the atrribute nearest-neighbor-1\n\n\n\nBeech\nOak\nPine\nSpruce\n\n\n\n\nBeech\n0.000\n0.029\n0.40\n3.3\n\n\nOak\n0.031\n0.000\n0.25\n3.9\n\n\nPine\n0.213\n0.128\n0.00\n4.9\n\n\nSpruce\n2.735\n3.199\n4.52\n0.0\n\n\n\n\n\n\n\n\n\ncolMeans(kld_results_specie, na.rm = TRUE) |&gt; mean()\n\n[1] 1.477983\n\n\n\n\nCode\nspecie &lt;- data[data$specie==\"beech\",]\nkld_results_beech &lt;- lfa::lfa_run_test_asymmetric(specie,value_column,\"area\",lfa::lfa_kld_from_vec)\nlfa::lfa_generate_result_table_tests(kld_results_beech,\"Kullback-Leibler-Divergence between areas with beech\")\n\n\n\n\nTable 13: Kullback-Leibler-Divergence between the researched areas which have the dominante specie beech for the atrribute nearest-neighbor-1\n\n\n\nBielefeld_brackwede\nBillerbeck\nWuelfenrath\n\n\n\n\nBielefeld_brackwede\n0.000\n0.35\n0.051\n\n\nBillerbeck\n0.380\n0.00\n0.138\n\n\nWuelfenrath\n0.059\n0.15\n0.000\n\n\n\n\n\n\n\n\n\ncolMeans(kld_results_beech, na.rm = TRUE) |&gt; mean()\n\n[1] 0.1249588\n\n\n\n\nCode\nspecie &lt;- data[data$specie==\"oak\",]\nkld_results_oak &lt;- lfa::lfa_run_test_asymmetric(specie,value_column,\"area\",lfa::lfa_kld_from_vec)\nlfa::lfa_generate_result_table_tests(kld_results_oak,\"Kullback-Leibler-Divergence between areas with oak\")\n\n\n\n\nTable 14: Kullback-Leibler-Divergence between the researched areas which have the dominante specie oak for the atrribute nearest-neighbor-1\n\n\n\nHamm\nMuenster\nRinkerode\n\n\n\n\nHamm\n0.000\n0.079\n0.078\n\n\nMuenster\n0.092\n0.000\n0.019\n\n\nRinkerode\n0.086\n0.020\n0.000\n\n\n\n\n\n\n\n\n\ncolMeans(kld_results_oak, na.rm = TRUE) |&gt; mean()\n\n[1] 0.04167636\n\n\n\n\nCode\nspecie &lt;- data[data$specie==\"pine\",]\nkld_results_pine &lt;- lfa::lfa_run_test_asymmetric(specie,value_column,\"area\",lfa::lfa_kld_from_vec)\nlfa::lfa_generate_result_table_tests(kld_results_pine,\"Kullback-Leibler-Divergence between areas with pine\")\n\n\n\n\nTable 15: Kullback-Leibler-Divergence between the researched areas which have the dominante specie pine for the atrribute nearest-neighbor-1\n\n\n\nGreffen\nMesum\nTelgte\n\n\n\n\nGreffen\n0.00\n0.495\n0.258\n\n\nMesum\n0.48\n0.000\n0.098\n\n\nTelgte\n0.22\n0.076\n0.000\n\n\n\n\n\n\n\n\n\ncolMeans(kld_results_pine, na.rm = TRUE) |&gt; mean()\n\n[1] 0.1812239\n\n\n\n\nCode\nspecie &lt;- data[data$specie==\"spruce\",]\nkld_results_spruce &lt;- lfa::lfa_run_test_asymmetric(specie,value_column,\"area\",lfa::lfa_kld_from_vec)\nlfa::lfa_generate_result_table_tests(kld_results_spruce,\"Kullback-Leibler-Divergence between areas with spruce\")\n\n\n\n\nTable 16: Kullback-Leibler-Divergence between the researched areas which have the dominante specie spruce for the atrribute nearest-neighbor-1\n\n\n\nBrilon\nOberhundem\nOsterwald\n\n\n\n\nBrilon\n0.00\n0.67\n5.1\n\n\nOberhundem\n0.41\n0.00\n7.2\n\n\nOsterwald\n6.09\n6.23\n0.0\n\n\n\n\n\n\n\n\n\ncolMeans(kld_results_spruce, na.rm = TRUE) |&gt; mean()\n\n[1] 2.863587\n\n\n\n\nJensen-Shannon Divergence\n\n\nCode\njsd_results_specie &lt;- lfa::lfa_run_test_symmetric(data,value_column,\"specie\",lfa::lfa_jsd_from_vec)\nlfa::lfa_generate_result_table_tests(jsd_results_specie,\"Jensen-Shannon Divergence between species\")\n\n\n\n\nTable 17: Jensen-Shannon Divergence between the researched species Beech, Oak, Pine and Spruce for the atrribute nearest-neighbor-1\n\n\n\nBeech\nOak\nPine\nSpruce\n\n\n\n\nBeech\n0\n0.22\n2.1\n9.3\n\n\nOak\nNA\n0.00\n1.3\n10.6\n\n\nPine\nNA\nNA\n0.0\n14.7\n\n\nSpruce\nNA\nNA\nNA\n0.0\n\n\n\n\n\n\n\n\n\ncolMeans(jsd_results_specie, na.rm = TRUE) |&gt; mean()\n\n[1] 2.470051\n\n\n\n\nCode\nspecie &lt;- data[data$specie==\"beech\",]\njsd_results_beech &lt;- lfa::lfa_run_test_symmetric(specie,value_column,\"area\",lfa::lfa_jsd_from_vec)\nlfa::lfa_generate_result_table_tests(jsd_results_beech,\"Jensen-Shannon Divergence between areas with beech\")\n\n\n\n\nTable 18: Jensen-Shannon Divergence between the researched areas which have the dominante specie beech for the atrribute nearest-neighbor-1\n\n\n\nBielefeld_brackwede\nBillerbeck\nWuelfenrath\n\n\n\n\nBielefeld_brackwede\n0\n2.2\n0.39\n\n\nBillerbeck\nNA\n0.0\n0.85\n\n\nWuelfenrath\nNA\nNA\n0.00\n\n\n\n\n\n\n\n\n\ncolMeans(jsd_results_beech, na.rm = TRUE) |&gt; mean()\n\n[1] 0.5042359\n\n\n\n\nCode\nspecie &lt;- data[data$specie==\"oak\",]\njsd_results_oak &lt;- lfa::lfa_run_test_symmetric(specie,value_column,\"area\",lfa::lfa_jsd_from_vec)\nlfa::lfa_generate_result_table_tests(jsd_results_oak,\"Jensen-Shannon Divergence between areas with oak\")\n\n\n\n\nTable 19: Jensen-Shannon Divergence between the researched areas which have the dominante specie oak for the atrribute nearest-neighbor-1\n\n\n\nHamm\nMuenster\nRinkerode\n\n\n\n\nHamm\n0\n0.57\n0.61\n\n\nMuenster\nNA\n0.00\n0.17\n\n\nRinkerode\nNA\nNA\n0.00\n\n\n\n\n\n\n\n\n\ncolMeans(jsd_results_oak, na.rm = TRUE) |&gt; mean()\n\n[1] 0.1803836\n\n\n\n\nCode\nspecie &lt;- data[data$specie==\"pine\",]\njsd_results_pine &lt;- lfa::lfa_run_test_symmetric(specie,value_column,\"area\",lfa::lfa_jsd_from_vec)\nlfa::lfa_generate_result_table_tests(jsd_results_pine,\"Jensen-Shannon Divergence between areas with pine\")\n\n\n\n\nTable 20: Jensen-Shannon Divergence between the researched areas which have the dominante specie pine for the atrribute nearest-neighbor-1\n\n\n\nGreffen\nMesum\nTelgte\n\n\n\n\nGreffen\n0\n3.6\n1.89\n\n\nMesum\nNA\n0.0\n0.68\n\n\nTelgte\nNA\nNA\n0.00\n\n\n\n\n\n\n\n\n\ncolMeans(jsd_results_pine, na.rm = TRUE) |&gt; mean()\n\n[1] 0.891592\n\n\n\n\nCode\nspecie &lt;- data[data$specie==\"spruce\",]\njsd_results_spruce &lt;- lfa::lfa_run_test_symmetric(specie,value_column,\"area\",lfa::lfa_jsd_from_vec)\nlfa::lfa_generate_result_table_tests(jsd_results_spruce,\"Jensen-Shannon Divergence between areas with spruce\")\n\n\n\n\nTable 21: Jensen-Shannon Divergence between the researched areas which have the dominante specie spruce for the atrribute nearest-neighbor-1\n\n\n\nBrilon\nOberhundem\nOsterwald\n\n\n\n\nBrilon\n0\n4.1\n16\n\n\nOberhundem\nNA\n0.0\n18\n\n\nOsterwald\nNA\nNA\n0\n\n\n\n\n\n\n\n\n\ncolMeans(jsd_results_spruce, na.rm = TRUE) |&gt; mean()\n\n[1] 4.471632\n\n\n\n\n\nDistribution of distances to 100th nearest neighbor\n\n\nCode\ndata &lt;- lfa::lfa_combine_sf_obj(lfa::lfa_get_neighbor_paths(),lfa::lfa_get_all_areas())\n\n\nReading layer `neighbours' from data source \n  `/home/jakob/gi-master/project-courses/lidar-forest-analysis/src/data/beech/bielefeld_brackwede/neighbours.gpkg' \n  using driver `GPKG'\nSimple feature collection with 1443 features and 102 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 466999.8 ymin: 5759839 xmax: 467617.1 ymax: 5760261\nProjected CRS: ETRS89 / UTM zone 32N\nReading layer `neighbours' from data source \n  `/home/jakob/gi-master/project-courses/lidar-forest-analysis/src/data/beech/billerbeck/neighbours.gpkg' \n  using driver `GPKG'\nSimple feature collection with 1732 features and 102 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 384890.8 ymin: 5761918 xmax: 385590.9 ymax: 5762478\nProjected CRS: ETRS89 / UTM zone 32N\nReading layer `neighbours' from data source \n  `/home/jakob/gi-master/project-courses/lidar-forest-analysis/src/data/beech/wuelfenrath/neighbours.gpkg' \n  using driver `GPKG'\nSimple feature collection with 2779 features and 102 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 365546.3 ymin: 5683711 xmax: 366356.1 ymax: 5684321\nProjected CRS: ETRS89 / UTM zone 32N\nReading layer `neighbours' from data source \n  `/home/jakob/gi-master/project-courses/lidar-forest-analysis/src/data/oak/hamm/neighbours.gpkg' \n  using driver `GPKG'\nSimple feature collection with 2441 features and 102 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 420953.3 ymin: 5723884 xmax: 421596 ymax: 5724609\nProjected CRS: ETRS89 / UTM zone 32N\nReading layer `neighbours' from data source \n  `/home/jakob/gi-master/project-courses/lidar-forest-analysis/src/data/oak/muenster/neighbours.gpkg' \n  using driver `GPKG'\nSimple feature collection with 1270 features and 102 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 404615.6 ymin: 5752535 xmax: 405396.8 ymax: 5752971\nProjected CRS: ETRS89 / UTM zone 32N\nReading layer `neighbours' from data source \n  `/home/jakob/gi-master/project-courses/lidar-forest-analysis/src/data/oak/rinkerode/neighbours.gpkg' \n  using driver `GPKG'\nSimple feature collection with 1643 features and 102 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 408428.2 ymin: 5746021 xmax: 409014.8 ymax: 5746511\nProjected CRS: ETRS89 / UTM zone 32N\nReading layer `neighbours' from data source \n  `/home/jakob/gi-master/project-courses/lidar-forest-analysis/src/data/pine/greffen/neighbours.gpkg' \n  using driver `GPKG'\nSimple feature collection with 513 features and 102 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 442816.1 ymin: 5760217 xmax: 443148.9 ymax: 5760567\nProjected CRS: ETRS89 / UTM zone 32N\nReading layer `neighbours' from data source \n  `/home/jakob/gi-master/project-courses/lidar-forest-analysis/src/data/pine/mesum/neighbours.gpkg' \n  using driver `GPKG'\nSimple feature collection with 5031 features and 102 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 399930.6 ymin: 5790412 xmax: 400969.7 ymax: 5790950\nProjected CRS: ETRS89 / UTM zone 32N\nReading layer `neighbours' from data source \n  `/home/jakob/gi-master/project-courses/lidar-forest-analysis/src/data/pine/telgte/neighbours.gpkg' \n  using driver `GPKG'\nSimple feature collection with 3368 features and 102 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 416135.1 ymin: 5761663 xmax: 416697.1 ymax: 5762477\nProjected CRS: ETRS89 / UTM zone 32N\nReading layer `neighbours' from data source \n  `/home/jakob/gi-master/project-courses/lidar-forest-analysis/src/data/spruce/brilon/neighbours.gpkg' \n  using driver `GPKG'\nSimple feature collection with 3342 features and 102 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 467305.7 ymin: 5695055 xmax: 467996.9 ymax: 5695593\nProjected CRS: ETRS89 / UTM zone 32N\nReading layer `neighbours' from data source \n  `/home/jakob/gi-master/project-courses/lidar-forest-analysis/src/data/spruce/oberhundem/neighbours.gpkg' \n  using driver `GPKG'\nSimple feature collection with 2471 features and 102 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 442631.7 ymin: 5660096 xmax: 443309.5 ymax: 5660502\nProjected CRS: ETRS89 / UTM zone 32N\nReading layer `neighbours' from data source \n  `/home/jakob/gi-master/project-courses/lidar-forest-analysis/src/data/spruce/osterwald/neighbours.gpkg' \n  using driver `GPKG'\nSimple feature collection with 2806 features and 102 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 455822 ymin: 5673761 xmax: 456483.2 ymax: 5674162\nProjected CRS: ETRS89 / UTM zone 32N\n\n\nCode\nvalue_column &lt;- \"Neighbor_100\"\n\n\n\nKullback-Leibler-Divergence\n\n\nCode\nkld_results_specie &lt;- lfa::lfa_run_test_asymmetric(data,value_column,\"specie\",lfa::lfa_kld_from_vec)\nlfa::lfa_generate_result_table_tests(kld_results_specie,\"Kullback-Leibler-Divergence between species\")\n\n\n\n\nTable 22: Kullback-Leibler-Divergence between the researched species Beech, Oak, Pine and Spruce for the atrribute nearest-neighbor-100\n\n\n\nBeech\nOak\nPine\nSpruce\n\n\n\n\nBeech\n0.000\n0.194\n0.082\n0.89\n\n\nOak\n0.183\n0.000\n0.063\n0.67\n\n\nPine\n0.084\n0.069\n0.000\n0.86\n\n\nSpruce\n1.083\n0.809\n1.200\n0.00\n\n\n\n\n\n\n\n\n\ncolMeans(kld_results_specie, na.rm = TRUE) |&gt; mean()\n\n[1] 0.3862841\n\n\n\n\nCode\nspecie &lt;- data[data$specie==\"beech\",]\nkld_results_beech &lt;- lfa::lfa_run_test_asymmetric(specie,value_column,\"area\",lfa::lfa_kld_from_vec)\nlfa::lfa_generate_result_table_tests(kld_results_beech,\"Kullback-Leibler-Divergence between areas with beech\")\n\n\n\n\nTable 23: Kullback-Leibler-Divergence between the researched areas which have the dominante specie beech for the atrribute nearest-neighbor-100\n\n\n\nBielefeld_brackwede\nBillerbeck\nWuelfenrath\n\n\n\n\nBielefeld_brackwede\n0.00\n0.12\n0.12\n\n\nBillerbeck\n0.14\n0.00\n0.40\n\n\nWuelfenrath\n0.12\n0.31\n0.00\n\n\n\n\n\n\n\n\n\ncolMeans(kld_results_beech, na.rm = TRUE) |&gt; mean()\n\n[1] 0.1338066\n\n\n\n\nCode\nspecie &lt;- data[data$specie==\"oak\",]\nkld_results_oak &lt;- lfa::lfa_run_test_asymmetric(specie,value_column,\"area\",lfa::lfa_kld_from_vec)\nlfa::lfa_generate_result_table_tests(kld_results_oak,\"Kullback-Leibler-Divergence between areas with oak\")\n\n\n\n\nTable 24: Kullback-Leibler-Divergence between the researched areas which have the dominante specie oak for the atrribute nearest-neighbor-100\n\n\n\nHamm\nMuenster\nRinkerode\n\n\n\n\nHamm\n0.00\n0.19\n0.11\n\n\nMuenster\n0.20\n0.00\n0.06\n\n\nRinkerode\n0.11\n0.07\n0.00\n\n\n\n\n\n\n\n\n\ncolMeans(kld_results_oak, na.rm = TRUE) |&gt; mean()\n\n[1] 0.08182597\n\n\n\n\nCode\nspecie &lt;- data[data$specie==\"pine\",]\nkld_results_pine &lt;- lfa::lfa_run_test_asymmetric(specie,value_column,\"area\",lfa::lfa_kld_from_vec)\nlfa::lfa_generate_result_table_tests(kld_results_pine,\"Kullback-Leibler-Divergence between areas with pine\")\n\n\n\n\nTable 25: Kullback-Leibler-Divergence between the researched areas which have the dominante specie pine for the atrribute nearest-neighbor-100\n\n\n\nGreffen\nMesum\nTelgte\n\n\n\n\nGreffen\n0.00\n0.25\n0.51\n\n\nMesum\n0.20\n0.00\n0.25\n\n\nTelgte\n0.54\n0.26\n0.00\n\n\n\n\n\n\n\n\n\ncolMeans(kld_results_pine, na.rm = TRUE) |&gt; mean()\n\n[1] 0.22229\n\n\n\n\nCode\nspecie &lt;- data[data$specie==\"spruce\",]\nkld_results_spruce &lt;- lfa::lfa_run_test_asymmetric(specie,value_column,\"area\",lfa::lfa_kld_from_vec)\nlfa::lfa_generate_result_table_tests(kld_results_spruce,\"Kullback-Leibler-Divergence between areas with spruce\")\n\n\n\n\nTable 26: Kullback-Leibler-Divergence between the researched areas which have the dominante specie spruce for the atrribute nearest-neighbor-100\n\n\n\nBrilon\nOberhundem\nOsterwald\n\n\n\n\nBrilon\n0.000\n0.05\n0.23\n\n\nOberhundem\n0.046\n0.00\n0.37\n\n\nOsterwald\n0.276\n0.46\n0.00\n\n\n\n\n\n\n\n\n\ncolMeans(kld_results_spruce, na.rm = TRUE) |&gt; mean()\n\n[1] 0.1591879\n\n\n\n\nJensen-Shannon Divergence\n\n\nCode\njsd_results_specie &lt;- lfa::lfa_run_test_symmetric(data,value_column,\"specie\",lfa::lfa_jsd_from_vec)\nlfa::lfa_generate_result_table_tests(jsd_results_specie,\"Jensen-Shannon Divergence between species\")\n\n\n\n\nTable 27: Jensen-Shannon Divergence between the researched species Beech, Oak, Pine and Spruce for the atrribute nearest-neighbor-100\n\n\n\nBeech\nOak\nPine\nSpruce\n\n\n\n\nBeech\n0\n0.38\n0.14\n1.27\n\n\nOak\nNA\n0.00\n0.30\n0.78\n\n\nPine\nNA\nNA\n0.00\n1.39\n\n\nSpruce\nNA\nNA\nNA\n0.00\n\n\n\n\n\n\n\n\n\ncolMeans(jsd_results_specie, na.rm = TRUE) |&gt; mean()\n\n[1] 0.2997233\n\n\n\n\nCode\nspecie &lt;- data[data$specie==\"beech\",]\njsd_results_beech &lt;- lfa::lfa_run_test_symmetric(specie,value_column,\"area\",lfa::lfa_jsd_from_vec)\nlfa::lfa_generate_result_table_tests(jsd_results_beech,\"Jensen-Shannon Divergence between areas with beech\")\n\n\n\n\nTable 28: Jensen-Shannon Divergence between the researched areas which have the dominante specie beech for the atrribute nearest-neighbor-100\n\n\n\nBielefeld_brackwede\nBillerbeck\nWuelfenrath\n\n\n\n\nBielefeld_brackwede\n0\n0.22\n0.21\n\n\nBillerbeck\nNA\n0.00\n0.57\n\n\nWuelfenrath\nNA\nNA\n0.00\n\n\n\n\n\n\n\n\n\ncolMeans(jsd_results_beech, na.rm = TRUE) |&gt; mean()\n\n[1] 0.124106\n\n\n\n\nCode\nspecie &lt;- data[data$specie==\"oak\",]\njsd_results_oak &lt;- lfa::lfa_run_test_symmetric(specie,value_column,\"area\",lfa::lfa_jsd_from_vec)\nlfa::lfa_generate_result_table_tests(jsd_results_oak,\"Jensen-Shannon Divergence between areas with oak\")\n\n\n\n\nTable 29: Jensen-Shannon Divergence between the researched areas which have the dominante specie oak for the atrribute nearest-neighbor-100\n\n\n\nHamm\nMuenster\nRinkerode\n\n\n\n\nHamm\n0\n0.34\n0.17\n\n\nMuenster\nNA\n0.00\n0.23\n\n\nRinkerode\nNA\nNA\n0.00\n\n\n\n\n\n\n\n\n\ncolMeans(jsd_results_oak, na.rm = TRUE) |&gt; mean()\n\n[1] 0.1007612\n\n\n\n\nCode\nspecie &lt;- data[data$specie==\"pine\",]\njsd_results_pine &lt;- lfa::lfa_run_test_symmetric(specie,value_column,\"area\",lfa::lfa_jsd_from_vec)\nlfa::lfa_generate_result_table_tests(jsd_results_pine,\"Jensen-Shannon Divergence between areas with pine\")\n\n\n\n\nTable 30: Jensen-Shannon Divergence between the researched areas which have the dominante specie pine for the atrribute nearest-neighbor-100\n\n\n\nGreffen\nMesum\nTelgte\n\n\n\n\nGreffen\n0\n0.45\n0.86\n\n\nMesum\nNA\n0.00\n0.50\n\n\nTelgte\nNA\nNA\n0.00\n\n\n\n\n\n\n\n\n\ncolMeans(jsd_results_pine, na.rm = TRUE) |&gt; mean()\n\n[1] 0.2265055\n\n\n\n\nCode\nspecie &lt;- data[data$specie==\"spruce\",]\njsd_results_spruce &lt;- lfa::lfa_run_test_symmetric(specie,value_column,\"area\",lfa::lfa_jsd_from_vec)\nlfa::lfa_generate_result_table_tests(jsd_results_spruce,\"Jensen-Shannon Divergence between areas with spruce\")\n\n\n\n\nTable 31: Jensen-Shannon Divergence between the researched areas which have the dominante specie spruce for the atrribute nearest-neighbor-100\n\n\n\nBrilon\nOberhundem\nOsterwald\n\n\n\n\nBrilon\n0\n0.1\n0.57\n\n\nOberhundem\nNA\n0.0\n0.73\n\n\nOsterwald\nNA\nNA\n0.00\n\n\n\n\n\n\n\n\n\ncolMeans(jsd_results_spruce, na.rm = TRUE) |&gt; mean()\n\n[1] 0.1613747\n\n\n\n\n\nDistribution of average nearest neighbor distances\n\n\nCode\ndata &lt;- lfa::lfa_combine_sf_obj(lfa::lfa_get_neighbor_paths(),lfa::lfa_get_all_areas())\n\n\nReading layer `neighbours' from data source \n  `/home/jakob/gi-master/project-courses/lidar-forest-analysis/src/data/beech/bielefeld_brackwede/neighbours.gpkg' \n  using driver `GPKG'\nSimple feature collection with 1443 features and 102 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 466999.8 ymin: 5759839 xmax: 467617.1 ymax: 5760261\nProjected CRS: ETRS89 / UTM zone 32N\nReading layer `neighbours' from data source \n  `/home/jakob/gi-master/project-courses/lidar-forest-analysis/src/data/beech/billerbeck/neighbours.gpkg' \n  using driver `GPKG'\nSimple feature collection with 1732 features and 102 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 384890.8 ymin: 5761918 xmax: 385590.9 ymax: 5762478\nProjected CRS: ETRS89 / UTM zone 32N\nReading layer `neighbours' from data source \n  `/home/jakob/gi-master/project-courses/lidar-forest-analysis/src/data/beech/wuelfenrath/neighbours.gpkg' \n  using driver `GPKG'\nSimple feature collection with 2779 features and 102 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 365546.3 ymin: 5683711 xmax: 366356.1 ymax: 5684321\nProjected CRS: ETRS89 / UTM zone 32N\nReading layer `neighbours' from data source \n  `/home/jakob/gi-master/project-courses/lidar-forest-analysis/src/data/oak/hamm/neighbours.gpkg' \n  using driver `GPKG'\nSimple feature collection with 2441 features and 102 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 420953.3 ymin: 5723884 xmax: 421596 ymax: 5724609\nProjected CRS: ETRS89 / UTM zone 32N\nReading layer `neighbours' from data source \n  `/home/jakob/gi-master/project-courses/lidar-forest-analysis/src/data/oak/muenster/neighbours.gpkg' \n  using driver `GPKG'\nSimple feature collection with 1270 features and 102 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 404615.6 ymin: 5752535 xmax: 405396.8 ymax: 5752971\nProjected CRS: ETRS89 / UTM zone 32N\nReading layer `neighbours' from data source \n  `/home/jakob/gi-master/project-courses/lidar-forest-analysis/src/data/oak/rinkerode/neighbours.gpkg' \n  using driver `GPKG'\nSimple feature collection with 1643 features and 102 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 408428.2 ymin: 5746021 xmax: 409014.8 ymax: 5746511\nProjected CRS: ETRS89 / UTM zone 32N\nReading layer `neighbours' from data source \n  `/home/jakob/gi-master/project-courses/lidar-forest-analysis/src/data/pine/greffen/neighbours.gpkg' \n  using driver `GPKG'\nSimple feature collection with 513 features and 102 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 442816.1 ymin: 5760217 xmax: 443148.9 ymax: 5760567\nProjected CRS: ETRS89 / UTM zone 32N\nReading layer `neighbours' from data source \n  `/home/jakob/gi-master/project-courses/lidar-forest-analysis/src/data/pine/mesum/neighbours.gpkg' \n  using driver `GPKG'\nSimple feature collection with 5031 features and 102 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 399930.6 ymin: 5790412 xmax: 400969.7 ymax: 5790950\nProjected CRS: ETRS89 / UTM zone 32N\nReading layer `neighbours' from data source \n  `/home/jakob/gi-master/project-courses/lidar-forest-analysis/src/data/pine/telgte/neighbours.gpkg' \n  using driver `GPKG'\nSimple feature collection with 3368 features and 102 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 416135.1 ymin: 5761663 xmax: 416697.1 ymax: 5762477\nProjected CRS: ETRS89 / UTM zone 32N\nReading layer `neighbours' from data source \n  `/home/jakob/gi-master/project-courses/lidar-forest-analysis/src/data/spruce/brilon/neighbours.gpkg' \n  using driver `GPKG'\nSimple feature collection with 3342 features and 102 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 467305.7 ymin: 5695055 xmax: 467996.9 ymax: 5695593\nProjected CRS: ETRS89 / UTM zone 32N\nReading layer `neighbours' from data source \n  `/home/jakob/gi-master/project-courses/lidar-forest-analysis/src/data/spruce/oberhundem/neighbours.gpkg' \n  using driver `GPKG'\nSimple feature collection with 2471 features and 102 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 442631.7 ymin: 5660096 xmax: 443309.5 ymax: 5660502\nProjected CRS: ETRS89 / UTM zone 32N\nReading layer `neighbours' from data source \n  `/home/jakob/gi-master/project-courses/lidar-forest-analysis/src/data/spruce/osterwald/neighbours.gpkg' \n  using driver `GPKG'\nSimple feature collection with 2806 features and 102 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 455822 ymin: 5673761 xmax: 456483.2 ymax: 5674162\nProjected CRS: ETRS89 / UTM zone 32N\n\n\nCode\nnames &lt;- paste0(\"Neighbor_\",1:100)\ndata$avg = rowMeans(dplyr::select(as.data.frame(data),names))\nvalue_column &lt;- \"avg\"\n\n\n\nKullback-Leibler-Divergence\n\n\nCode\nkld_results_specie &lt;- lfa::lfa_run_test_asymmetric(data,value_column,\"specie\",lfa::lfa_kld_from_vec)\nlfa::lfa_generate_result_table_tests(kld_results_specie,\"Kullback-Leibler-Divergence between species\")\n\n\n\n\nTable 32: Kullback-Leibler-Divergence between the researched species Beech, Oak, Pine and Spruce for the atrribute nearest-neighbor-avg\n\n\n\nBeech\nOak\nPine\nSpruce\n\n\n\n\nBeech\n0.000\n0.31\n0.065\n1.28\n\n\nOak\n0.302\n0.00\n0.178\n0.83\n\n\nPine\n0.067\n0.17\n0.000\n1.23\n\n\nSpruce\n1.660\n0.92\n1.869\n0.00\n\n\n\n\n\n\n\n\n\ncolMeans(kld_results_specie, na.rm = TRUE) |&gt; mean()\n\n[1] 0.5552882\n\n\n\n\nCode\nspecie &lt;- data[data$specie==\"beech\",]\nkld_results_beech &lt;- lfa::lfa_run_test_asymmetric(specie,value_column,\"area\",lfa::lfa_kld_from_vec)\nlfa::lfa_generate_result_table_tests(kld_results_beech,\"Kullback-Leibler-Divergence between areas with beech\")\n\n\n\n\nTable 33: Kullback-Leibler-Divergence between the researched areas which have the dominante specie beech for the atrribute nearest-neighbor-avg\n\n\n\nBielefeld_brackwede\nBillerbeck\nWuelfenrath\n\n\n\n\nBielefeld_brackwede\n0.000\n0.052\n0.50\n\n\nBillerbeck\n0.052\n0.000\n0.91\n\n\nWuelfenrath\n0.348\n0.612\n0.00\n\n\n\n\n\n\n\n\n\ncolMeans(kld_results_beech, na.rm = TRUE) |&gt; mean()\n\n[1] 0.27574\n\n\n\n\nCode\nspecie &lt;- data[data$specie==\"oak\",]\nkld_results_oak &lt;- lfa::lfa_run_test_asymmetric(specie,value_column,\"area\",lfa::lfa_kld_from_vec)\nlfa::lfa_generate_result_table_tests(kld_results_oak,\"Kullback-Leibler-Divergence between areas with oak\")\n\n\n\n\nTable 34: Kullback-Leibler-Divergence between the researched areas which have the dominante specie oak for the atrribute nearest-neighbor-avg\n\n\n\nHamm\nMuenster\nRinkerode\n\n\n\n\nHamm\n0.00\n0.166\n0.217\n\n\nMuenster\n0.16\n0.000\n0.031\n\n\nRinkerode\n0.21\n0.037\n0.000\n\n\n\n\n\n\n\n\n\ncolMeans(kld_results_oak, na.rm = TRUE) |&gt; mean()\n\n[1] 0.09154318\n\n\n\n\nCode\nspecie &lt;- data[data$specie==\"pine\",]\nkld_results_pine &lt;- lfa::lfa_run_test_asymmetric(specie,value_column,\"area\",lfa::lfa_kld_from_vec)\nlfa::lfa_generate_result_table_tests(kld_results_pine,\"Kullback-Leibler-Divergence between areas with pine\")\n\n\n\n\nTable 35: Kullback-Leibler-Divergence between the researched areas which have the dominante specie pine for the atrribute nearest-neighbor-avg\n\n\n\nGreffen\nMesum\nTelgte\n\n\n\n\nGreffen\n0.00\n0.17\n0.29\n\n\nMesum\n0.14\n0.00\n0.30\n\n\nTelgte\n0.26\n0.32\n0.00\n\n\n\n\n\n\n\n\n\ncolMeans(kld_results_pine, na.rm = TRUE) |&gt; mean()\n\n[1] 0.1637513\n\n\n\n\nCode\nspecie &lt;- data[data$specie==\"spruce\",]\nkld_results_spruce &lt;- lfa::lfa_run_test_asymmetric(specie,value_column,\"area\",lfa::lfa_kld_from_vec)\nlfa::lfa_generate_result_table_tests(kld_results_spruce,\"Kullback-Leibler-Divergence between areas with spruce\")\n\n\n\n\nTable 36: Kullback-Leibler-Divergence between the researched areas which have the dominante specie spruce for the atrribute nearest-neighbor-avg\n\n\n\nBrilon\nOberhundem\nOsterwald\n\n\n\n\nBrilon\n0.000\n0.11\n0.29\n\n\nOberhundem\n0.097\n0.00\n0.59\n\n\nOsterwald\n0.341\n0.75\n0.00\n\n\n\n\n\n\n\n\n\ncolMeans(kld_results_spruce, na.rm = TRUE) |&gt; mean()\n\n[1] 0.2404004\n\n\n\n\nJensen-Shannon Divergence\n\n\nCode\njsd_results_specie &lt;- lfa::lfa_run_test_symmetric(data,value_column,\"specie\",lfa::lfa_jsd_from_vec)\nlfa::lfa_generate_result_table_tests(jsd_results_specie,\"Jensen-Shannon Divergence between species\")\n\n\n\n\nTable 37: Jensen-Shannon Divergence between the researched species Beech, Oak, Pine and Spruce for the atrribute nearest-neighbor-avg\n\n\n\nBeech\nOak\nPine\nSpruce\n\n\n\n\nBeech\n0\n0.73\n0.19\n2.6\n\n\nOak\nNA\n0.00\n0.64\n1.4\n\n\nPine\nNA\nNA\n0.00\n3.0\n\n\nSpruce\nNA\nNA\nNA\n0.0\n\n\n\n\n\n\n\n\n\ncolMeans(jsd_results_specie, na.rm = TRUE) |&gt; mean()\n\n[1] 0.5999417\n\n\n\n\nCode\nspecie &lt;- data[data$specie==\"beech\",]\njsd_results_beech &lt;- lfa::lfa_run_test_symmetric(specie,value_column,\"area\",lfa::lfa_jsd_from_vec)\nlfa::lfa_generate_result_table_tests(jsd_results_beech,\"Jensen-Shannon Divergence between areas with beech\")\n\n\n\n\nTable 38: Jensen-Shannon Divergence between the researched areas which have the dominante specie beech for the atrribute nearest-neighbor-avg\n\n\n\nBielefeld_brackwede\nBillerbeck\nWuelfenrath\n\n\n\n\nBielefeld_brackwede\n0\n0.14\n1.0\n\n\nBillerbeck\nNA\n0.00\n1.7\n\n\nWuelfenrath\nNA\nNA\n0.0\n\n\n\n\n\n\n\n\n\ncolMeans(jsd_results_beech, na.rm = TRUE) |&gt; mean()\n\n[1] 0.3215991\n\n\n\n\nCode\nspecie &lt;- data[data$specie==\"oak\",]\njsd_results_oak &lt;- lfa::lfa_run_test_symmetric(specie,value_column,\"area\",lfa::lfa_jsd_from_vec)\nlfa::lfa_generate_result_table_tests(jsd_results_oak,\"Jensen-Shannon Divergence between areas with oak\")\n\n\n\n\nTable 39: Jensen-Shannon Divergence between the researched areas which have the dominante specie oak for the atrribute nearest-neighbor-avg\n\n\n\nHamm\nMuenster\nRinkerode\n\n\n\n\nHamm\n0\n0.41\n0.53\n\n\nMuenster\nNA\n0.00\n0.26\n\n\nRinkerode\nNA\nNA\n0.00\n\n\n\n\n\n\n\n\n\ncolMeans(jsd_results_oak, na.rm = TRUE) |&gt; mean()\n\n[1] 0.1558436\n\n\n\n\nCode\nspecie &lt;- data[data$specie==\"pine\",]\njsd_results_pine &lt;- lfa::lfa_run_test_symmetric(specie,value_column,\"area\",lfa::lfa_jsd_from_vec)\nlfa::lfa_generate_result_table_tests(jsd_results_pine,\"Jensen-Shannon Divergence between areas with pine\")\n\n\n\n\nTable 40: Jensen-Shannon Divergence between the researched areas which have the dominante specie pine for the atrribute nearest-neighbor-avg\n\n\n\nGreffen\nMesum\nTelgte\n\n\n\n\nGreffen\n0\n0.44\n0.76\n\n\nMesum\nNA\n0.00\n0.89\n\n\nTelgte\nNA\nNA\n0.00\n\n\n\n\n\n\n\n\n\ncolMeans(jsd_results_pine, na.rm = TRUE) |&gt; mean()\n\n[1] 0.2560143\n\n\n\n\nCode\nspecie &lt;- data[data$specie==\"spruce\",]\njsd_results_spruce &lt;- lfa::lfa_run_test_symmetric(specie,value_column,\"area\",lfa::lfa_jsd_from_vec)\nlfa::lfa_generate_result_table_tests(jsd_results_spruce,\"Jensen-Shannon Divergence between areas with spruce\")\n\n\n\n\nTable 41: Jensen-Shannon Divergence between the researched areas which have the dominante specie spruce for the atrribute nearest-neighbor-avg\n\n\n\nBrilon\nOberhundem\nOsterwald\n\n\n\n\nBrilon\n0\n0.32\n1.1\n\n\nOberhundem\nNA\n0.00\n1.8\n\n\nOsterwald\nNA\nNA\n0.0\n\n\n\n\n\n\n\n\n\ncolMeans(jsd_results_spruce, na.rm = TRUE) |&gt; mean()\n\n[1] 0.3713411\n\n\n\n\n\n\n6.4.3 Distribution of the number of returns\n\n\nCode\ndata &lt;- sf::st_read(\"data/tree_properties.gpkg\")\nneighbors &lt;- lfa::lfa_get_neighbor_paths() |&gt; lfa::lfa_combine_sf_obj(lfa::lfa_get_all_areas())\ndata = sf::st_join(data,neighbors, join = sf::st_within)\nvalue_column &lt;- \"number_of_returns\"\n\n\n\nKullback-Leibler-Divergence\n\n\nCode\nkld_results_specie &lt;- lfa::lfa_run_test_asymmetric(data,value_column,\"specie\",lfa::lfa_kld_from_vec)\nlfa::lfa_generate_result_table_tests(kld_results_specie,\"Kullback-Leibler-Divergence between species\")\n\n\n\n\nTable 42: Kullback-Leibler-Divergence between the researched species Beech, Oak, Pine and Spruce for the atrribute number-of-returns\n\n\n\nBeech\nOak\nPine\nSpruce\n\n\n\n\nBeech\n0.000\n0.083\n0.57\n0.049\n\n\nOak\n0.051\n0.000\n0.84\n0.059\n\n\nPine\n0.432\n0.833\n0.00\n0.526\n\n\nSpruce\n0.036\n0.059\n0.54\n0.000\n\n\n\n\n\n\n\n\n\ncolMeans(kld_results_specie, na.rm = TRUE) |&gt; mean()\n\n[1] 0.2550987\n\n\n\n\nCode\nspecie &lt;- data[data$specie==\"beech\",]\nkld_results_beech &lt;- lfa::lfa_run_test_asymmetric(specie,value_column,\"area\",lfa::lfa_kld_from_vec)\nlfa::lfa_generate_result_table_tests(kld_results_beech,\"Kullback-Leibler-Divergence between areas with beech\")\n\n\n\n\nTable 43: Kullback-Leibler-Divergence between the researched areas which have the dominante specie beech for the atrribute number-of-returns\n\n\n\nBielefeld_brackwede\nBillerbeck\nWuelfenrath\n\n\n\n\nBielefeld_brackwede\n0.00\n0.15\n0.082\n\n\nBillerbeck\n0.21\n0.00\n0.136\n\n\nWuelfenrath\n0.13\n0.19\n0.000\n\n\n\n\n\n\n\n\n\ncolMeans(kld_results_beech, na.rm = TRUE) |&gt; mean()\n\n[1] 0.09985223\n\n\n\n\nCode\nspecie &lt;- data[data$specie==\"oak\",]\nkld_results_oak &lt;- lfa::lfa_run_test_asymmetric(specie,value_column,\"area\",lfa::lfa_kld_from_vec)\nlfa::lfa_generate_result_table_tests(kld_results_oak,\"Kullback-Leibler-Divergence between areas with oak\")\n\n\n\n\nTable 44: Kullback-Leibler-Divergence between the researched areas which have the dominante specie oak for the atrribute number-of-returns\n\n\n\nHamm\nMuenster\nRinkerode\n\n\n\n\nHamm\n0.00\n0.46\n0.846\n\n\nMuenster\n0.41\n0.00\n0.077\n\n\nRinkerode\n0.81\n0.09\n0.000\n\n\n\n\n\n\n\n\n\ncolMeans(kld_results_oak, na.rm = TRUE) |&gt; mean()\n\n[1] 0.2994815\n\n\n\n\nCode\nspecie &lt;- data[data$specie==\"pine\",]\nkld_results_pine &lt;- lfa::lfa_run_test_asymmetric(specie,value_column,\"area\",lfa::lfa_kld_from_vec)\nlfa::lfa_generate_result_table_tests(kld_results_pine,\"Kullback-Leibler-Divergence between areas with pine\")\n\n\n\n\nTable 45: Kullback-Leibler-Divergence between the researched areas which have the dominante specie pine for the atrribute number-of-returns\n\n\n\nGreffen\nMesum\nTelgte\n\n\n\n\nGreffen\n0.00\n0.1444\n0.1773\n\n\nMesum\n0.14\n0.0000\n0.0047\n\n\nTelgte\n0.16\n0.0045\n0.0000\n\n\n\n\n\n\n\n\n\ncolMeans(kld_results_pine, na.rm = TRUE) |&gt; mean()\n\n[1] 0.07005788\n\n\n\n\nCode\nspecie &lt;- data[data$specie==\"spruce\",]\nkld_results_spruce &lt;- lfa::lfa_run_test_asymmetric(specie,value_column,\"area\",lfa::lfa_kld_from_vec)\nlfa::lfa_generate_result_table_tests(kld_results_spruce,\"Kullback-Leibler-Divergence between areas with spruce\")\n\n\n\n\nTable 46: Kullback-Leibler-Divergence between the researched areas which have the dominante specie spruce for the atrribute number-of-returns\n\n\n\nBrilon\nOberhundem\nOsterwald\n\n\n\n\nBrilon\n0.000\n0.04\n0.034\n\n\nOberhundem\n0.041\n0.00\n0.079\n\n\nOsterwald\n0.045\n0.10\n0.000\n\n\n\n\n\n\n\n\n\ncolMeans(kld_results_spruce, na.rm = TRUE) |&gt; mean()\n\n[1] 0.03779495\n\n\n\n\nJensen-Shannon Divergence\n\n\nCode\njsd_results_specie &lt;- lfa::lfa_run_test_symmetric(data,value_column,\"specie\",lfa::lfa_jsd_from_vec)\nlfa::lfa_generate_result_table_tests(jsd_results_specie,\"Jensen-Shannon Divergence between species\")\n\n\n\n\nTable 47: Jensen-Shannon Divergence between the researched species Beech, Oak, Pine and Spruce for the atrribute number-of-returns\n\n\n\nBeech\nOak\nPine\nSpruce\n\n\n\n\nBeech\n0\n3e-04\n0.019\n0.0014\n\n\nOak\nNA\n0e+00\n0.021\n0.0016\n\n\nPine\nNA\nNA\n0.000\n0.0143\n\n\nSpruce\nNA\nNA\nNA\n0.0000\n\n\n\n\n\n\n\n\n\ncolMeans(jsd_results_specie, na.rm = TRUE) |&gt; mean()\n\n[1] 0.004419638\n\n\n\n\nCode\nspecie &lt;- data[data$specie==\"beech\",]\njsd_results_beech &lt;- lfa::lfa_run_test_symmetric(specie,value_column,\"area\",lfa::lfa_jsd_from_vec)\nlfa::lfa_generate_result_table_tests(jsd_results_beech,\"Jensen-Shannon Divergence between areas with beech\")\n\n\n\n\nTable 48: Jensen-Shannon Divergence between the researched areas which have the dominante specie beech for the atrribute number-of-returns\n\n\n\nBielefeld_brackwede\nBillerbeck\nWuelfenrath\n\n\n\n\nBielefeld_brackwede\n0\n0.0035\n0.00099\n\n\nBillerbeck\nNA\n0.0000\n0.00554\n\n\nWuelfenrath\nNA\nNA\n0.00000\n\n\n\n\n\n\n\n\n\ncolMeans(jsd_results_beech, na.rm = TRUE) |&gt; mean()\n\n[1] 0.001314268\n\n\n\n\nCode\nspecie &lt;- data[data$specie==\"oak\",]\njsd_results_oak &lt;- lfa::lfa_run_test_symmetric(specie,value_column,\"area\",lfa::lfa_jsd_from_vec)\nlfa::lfa_generate_result_table_tests(jsd_results_oak,\"Jensen-Shannon Divergence between areas with oak\")\n\n\n\n\nTable 49: Jensen-Shannon Divergence between the researched areas which have the dominante specie oak for the atrribute number-of-returns\n\n\n\nHamm\nMuenster\nRinkerode\n\n\n\n\nHamm\n0\n0.0068\n0.0128\n\n\nMuenster\nNA\n0.0000\n0.0017\n\n\nRinkerode\nNA\nNA\n0.0000\n\n\n\n\n\n\n\n\n\ncolMeans(jsd_results_oak, na.rm = TRUE) |&gt; mean()\n\n[1] 0.002747351\n\n\n\n\nCode\nspecie &lt;- data[data$specie==\"pine\",]\njsd_results_pine &lt;- lfa::lfa_run_test_symmetric(specie,value_column,\"area\",lfa::lfa_jsd_from_vec)\nlfa::lfa_generate_result_table_tests(jsd_results_pine,\"Jensen-Shannon Divergence between areas with pine\")\n\n\n\n\nTable 50: Jensen-Shannon Divergence between the researched areas which have the dominante specie pine for the atrribute number-of-returns\n\n\n\nGreffen\nMesum\nTelgte\n\n\n\n\nGreffen\n0\n0.0035\n0.00458\n\n\nMesum\nNA\n0.0000\n0.00037\n\n\nTelgte\nNA\nNA\n0.00000\n\n\n\n\n\n\n\n\n\ncolMeans(jsd_results_pine, na.rm = TRUE) |&gt; mean()\n\n[1] 0.001130537\n\n\n\n\nCode\nspecie &lt;- data[data$specie==\"spruce\",]\njsd_results_spruce &lt;- lfa::lfa_run_test_symmetric(specie,value_column,\"area\",lfa::lfa_jsd_from_vec)\nlfa::lfa_generate_result_table_tests(jsd_results_spruce,\"Jensen-Shannon Divergence between areas with spruce\")\n\n\n\n\nTable 51: Jensen-Shannon Divergence between the researched areas which have the dominante specie spruce for the atrribute number-of-returns\n\n\n\nBrilon\nOberhundem\nOsterwald\n\n\n\n\nBrilon\n0\n0.0069\n0.005\n\n\nOberhundem\nNA\n0.0000\n0.002\n\n\nOsterwald\nNA\nNA\n0.000\n\n\n\n\n\n\n\n\n\ncolMeans(jsd_results_spruce, na.rm = TRUE) |&gt; mean()\n\n[1] 0.001939104"
  },
  {
    "objectID": "report.html#distribution-of-the-tree-heights-1",
    "href": "report.html#distribution-of-the-tree-heights-1",
    "title": "Forest Data Analysis Report",
    "section": "3.3 Distribution of the tree heights",
    "text": "3.3 Distribution of the tree heights\n\n\nCode\ndata &lt;- sf::st_read(\"data/tree_properties.gpkg\")\nneighbors &lt;- lfa::lfa_get_neighbor_paths() |&gt; lfa::lfa_combine_sf_obj(lfa::lfa_get_all_areas())\ndata = sf::st_join(data,neighbors, join = sf::st_within)\n\n\n\n\nCode\nlfa::lfa_create_density_plots(data, value_column = \"number_of_returns\", category_column1 = \"area\", category_column2 = \"specie\", title = \"Density of the distribution of LiDAR returns per individual tree\", xlims = c(0,10000))\n\n\n\n\n\nFigure 4: Density of the amount of LiDAR returns per detectected tree. Splitted by the different researched areas and grouped by the dominant specie in this area.\n\n\n\n\n\n\nCode\nlfa::lfa_create_boxplot(data, value_column = \"number_of_returns\", category_column1 = \"area\", category_column2 = \"specie\", title = \"Boxplots of the distribution of LiDAR returns per individual tree\")\n\n\n\n\n\nFigure 5: Boxplots of the the amount of LiDAR returns per detectected tree. Splitted by the different researched areas and grouped by the dominant specie in this area.\n\n\n\n\n\n\n\nspecie\narea\ndensity (1/m²)\n\n\n\n\nbeech\nbielefeld_brackwede\n0.0089399\n\n\nbeech\nbillerbeck\n0.0093175\n\n\nbeech\nwuelfenrath\n0.0079259\n\n\noak\nhamm\n0.0090610\n\n\noak\nmuenster\n0.0077384\n\n\noak\nrinkerode\n0.0082641\n\n\npine\ngreffen\n0.0103807\n\n\npine\nmesum\n0.0124200\n\n\npine\ntelgte\n0.0122860\n\n\nspruce\nbrilon\n0.0158030\n\n\nspruce\noberhundem\n0.0162678\n\n\nspruce\nosterwald\n0.0129892"
  },
  {
    "objectID": "report.html#distribution-of-number-of-returns-per-detected-tree.",
    "href": "report.html#distribution-of-number-of-returns-per-detected-tree.",
    "title": "Forest Data Analysis Report",
    "section": "3.3 Distribution of number of returns per detected tree.",
    "text": "3.3 Distribution of number of returns per detected tree.\n\n\nCode\ndata &lt;- sf::st_read(\"data/tree_properties.gpkg\")\nneighbors &lt;- lfa::lfa_get_neighbor_paths() |&gt; lfa::lfa_combine_sf_obj(lfa::lfa_get_all_areas())\ndata = sf::st_join(data,neighbors, join = sf::st_within)\n\n\nExamining the distribution of LiDAR returns per tree is the focus of our current investigation. Initial analysis involves the study of density graphs representing the distribution of LiDAR returns. The density curves for each species exhibit distinct peaks corresponding to their respective species, providing a clear differentiation in LiDAR return patterns. Notably, there is an exception observed in the Brilon patch (Spruce), where the curve deviates, possibly indicative of variations in forest age. A noteworthy trend is the divergent shape of density curves between coniferous and deciduous trees. Conifers exhibit steeper curves, indicating lower density for higher return values compared to deciduous trees. This disparity underscores the potential of LiDAR data to distinguish between tree types based on return density characteristics. In the case of Beech trees, the peaks’ heights vary among different curves, suggesting nuanced variations within the species. Despite these differences, all species consistently peak in similar regions, emphasizing the overarching similarities in LiDAR return patterns across diverse tree species.\n\n\nCode\nlfa::lfa_create_density_plots(data, value_column = \"number_of_returns\", category_column1 = \"area\", category_column2 = \"specie\", title = \"Density of the distribution of LiDAR returns per individual tree\", xlims = c(0,10000))\n\n\n\n\n\nFigure 4: Density of the amount of LiDAR returns per detectected tree. Splitted by the different researched areas and grouped by the dominant specie in this area.\n\n\n\n\nCurrently, our investigation focuses on boxplots representing each patch. We observe significant size variations among plots within the same species. Notably, numerous outliers are present above the box in each patch. For Pines, the boxes exhibit a notable similarity. However, the box for Brilon is entirely shifted from other boxes associated with patches featuring Spruce forest.\n\n\nCode\nlfa::lfa_create_boxplot(data, value_column = \"number_of_returns\", category_column1 = \"area\", category_column2 = \"specie\", title = \"Boxplots of the distribution of LiDAR returns per individual tree\")\n\n\n\n\n\nFigure 5: Boxplots of the the amount of LiDAR returns per detectected tree. Splitted by the different researched areas and grouped by the dominant specie in this area.\n\n\n\n\nOverall, our analysis reveals very low results for both Kullback-Leibler Divergence (KLD) and Jensen-Shannon Divergence (JSD) metrics across different species. Within species, there is high explainability observed for the different LiDAR return curves between patches.\nThis suggests that the number of returns alone may not be a robust predictor for identifying the dominant species in a forest. However, the curves indicate a clear potential for distinguishing between conifers (Pine and Spruce) and deciduous trees (Beech and Oak) based on the number of returns. This observation is further supported by the JSD scores, as detailed in Table 47."
  },
  {
    "objectID": "report.html#density-of-forest-patches",
    "href": "report.html#density-of-forest-patches",
    "title": "Forest Data Analysis Report",
    "section": "4.5 Density of forest patches",
    "text": "4.5 Density of forest patches\nExamining densities provides valuable insights into identifying the dominant species within patches. Spruce stands out as the densest species, surpassing all other patches. Following closely in density is Pine, as depicted in Figure 1 (Figure 13).\nBeech and Oak exhibit similar density levels, with Beech consistently denser across all patches. When comparing the highest density patches for each species, Beech consistently outpaces Oak. While Oak is slightly less dense overall (\\(8.354499 \\times 10^{-3} \\frac{1}{m^2}\\)) than Beech (\\(8.727781 \\times 10^{-3} \\frac{1}{m^2}\\)), the distinction in density remains noticeable.\n\n\nCode\nlibrary(units)\nlfa::lfa_calculate_patch_density() |&gt;\n  lfa::lfa_create_grouped_bar_plot(grouping_var = \"species\", value_col = \"density\", label_col = \"name\")\n\n\n\n\n\nFigure 13: Barplot of the densitys of all patches (#detected trees/area of patch). Colorized by the dominant tree species of each patch.\n\n\n\n\nIn summary, our findings indicate that the density of each patch proves highly effective in distinguishing dominant species. Furthermore, the differentiation between conifers (Pine and Spruce) and deciduous trees (Beech and Oak) based on density aligns with patterns observed in the number of return points per detected tree. While distinguishing within conifers is straightforward, discerning between the deciduous tree species Beech and Oak, is possible but poses a moderate challenge."
  },
  {
    "objectID": "report.html#predicting-species-with-random-forest",
    "href": "report.html#predicting-species-with-random-forest",
    "title": "Forest Data Analysis Report",
    "section": "3.7 Predicting species with random forest",
    "text": "3.7 Predicting species with random forest\n\n3.7.1 Use height\n\ndetections &lt;- lfa::lfa_get_detections()\ndensity &lt;- lfa::lfa_calculate_patch_density(detections = detections)\n\nReading layer `research_areas' from data source \n  `/home/jakob/gi-master/project-courses/lidar-forest-analysis/src/research_areas.shp' \n  using driver `ESRI Shapefile'\nSimple feature collection with 12 features and 3 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 7.071625 ymin: 51.0895 xmax: 8.539877 ymax: 52.25983\nGeodetic CRS:  WGS 84\n\n\nWarning in `[&lt;-.data.frame`(`*tmp*`, i, \"detections\", value = structure(list(:\nprovided 2 variables to replace 1 variables\n\nWarning in `[&lt;-.data.frame`(`*tmp*`, i, \"detections\", value = structure(list(:\nprovided 2 variables to replace 1 variables\n\nWarning in `[&lt;-.data.frame`(`*tmp*`, i, \"detections\", value = structure(list(:\nprovided 2 variables to replace 1 variables\n\nWarning in `[&lt;-.data.frame`(`*tmp*`, i, \"detections\", value = structure(list(:\nprovided 2 variables to replace 1 variables\n\nWarning in `[&lt;-.data.frame`(`*tmp*`, i, \"detections\", value = structure(list(:\nprovided 2 variables to replace 1 variables\n\nWarning in `[&lt;-.data.frame`(`*tmp*`, i, \"detections\", value = structure(list(:\nprovided 2 variables to replace 1 variables\n\nWarning in `[&lt;-.data.frame`(`*tmp*`, i, \"detections\", value = structure(list(:\nprovided 2 variables to replace 1 variables\n\nWarning in `[&lt;-.data.frame`(`*tmp*`, i, \"detections\", value = structure(list(:\nprovided 2 variables to replace 1 variables\n\nWarning in `[&lt;-.data.frame`(`*tmp*`, i, \"detections\", value = structure(list(:\nprovided 2 variables to replace 1 variables\n\nWarning in `[&lt;-.data.frame`(`*tmp*`, i, \"detections\", value = structure(list(:\nprovided 2 variables to replace 1 variables\n\nWarning in `[&lt;-.data.frame`(`*tmp*`, i, \"detections\", value = structure(list(:\nprovided 2 variables to replace 1 variables\n\nWarning in `[&lt;-.data.frame`(`*tmp*`, i, \"detections\", value = structure(list(:\nprovided 2 variables to replace 1 variables\n\ncolnames(density) &lt;- c(\"id\",\"specie\",\"area\",\"geometry\",\"area_size\",\"detections\",\"density\") \ndetections &lt;- dplyr::left_join(detections,density |&gt; as.data.frame(), by= c(\"area\",\"specie\"))\nexcluded_cols &lt;- c(\"treeID\",\"geom\",\"area\",\"specie\",\"id\",\"geometry\",\"area_size\",\"detections\", \"density\")\n\n\ndata &lt;- lfa::lfa_random_forest(tree_data = detections, excluded_input_columns = excluded_cols)\n\n[1] \"bielefeld_brackwede\"\npredictions\n beech    oak   pine spruce \n    68    190    858    327 \n[1] \"billerbeck\"\npredictions\n beech    oak   pine spruce \n   500    317     54    861 \n[1] \"wuelfenrath\"\npredictions\n beech    oak   pine spruce \n   412    421    119   1827 \n[1] \"hamm\"\npredictions\n beech    oak   pine spruce \n   374    129    986    952 \n[1] \"muenster\"\npredictions\n beech    oak   pine spruce \n   278     94    162    736 \n[1] \"rinkerode\"\npredictions\n beech    oak   pine spruce \n    79    128    611    825 \n[1] \"greffen\"\npredictions\n beech    oak   pine spruce \n     9     14    439     51 \n[1] \"mesum\"\npredictions\n beech    oak   pine spruce \n   139    406   2754   1732 \n[1] \"telgte\"\npredictions\n beech    oak   pine spruce \n    52    448   1899    969 \n[1] \"brilon\"\npredictions\n beech    oak   pine spruce \n  1455   1053    576    258 \n[1] \"oberhundem\"\npredictions\n beech    oak   pine spruce \n   662    834    602    373 \n[1] \"osterwald\"\npredictions\n beech    oak   pine spruce \n   271    347   1972    216 \n[1] \"result_df\"\n                  area species count\n1  bielefeld_brackwede   beech    68\n2  bielefeld_brackwede     oak   190\n3  bielefeld_brackwede    pine   858\n4  bielefeld_brackwede  spruce   327\n5           billerbeck   beech   500\n6           billerbeck     oak   317\n7           billerbeck    pine    54\n8           billerbeck  spruce   861\n9          wuelfenrath   beech   412\n10         wuelfenrath     oak   421\n11         wuelfenrath    pine   119\n12         wuelfenrath  spruce  1827\n13                hamm   beech   374\n14                hamm     oak   129\n15                hamm    pine   986\n16                hamm  spruce   952\n17            muenster   beech   278\n18            muenster     oak    94\n19            muenster    pine   162\n20            muenster  spruce   736\n21           rinkerode   beech    79\n22           rinkerode     oak   128\n23           rinkerode    pine   611\n24           rinkerode  spruce   825\n25             greffen   beech     9\n26             greffen     oak    14\n27             greffen    pine   439\n28             greffen  spruce    51\n29               mesum   beech   139\n30               mesum     oak   406\n31               mesum    pine  2754\n32               mesum  spruce  1732\n33              telgte   beech    52\n34              telgte     oak   448\n35              telgte    pine  1899\n36              telgte  spruce   969\n37              brilon   beech  1455\n38              brilon     oak  1053\n39              brilon    pine   576\n40              brilon  spruce   258\n41          oberhundem   beech   662\n42          oberhundem     oak   834\n43          oberhundem    pine   602\n44          oberhundem  spruce   373\n45           osterwald   beech   271\n46           osterwald     oak   347\n47           osterwald    pine  1972\n48           osterwald  spruce   216\n[1] \"transformed_df:\"\n                  area beech  oak pine spruce expected_specie\n1  bielefeld_brackwede    68  190  858    327         Default\n2           billerbeck   500  317   54    861         Default\n3               brilon  1455 1053  576    258         Default\n4              greffen     9   14  439     51         Default\n5                 hamm   374  129  986    952         Default\n6                mesum   139  406 2754   1732         Default\n7             muenster   278   94  162    736         Default\n8           oberhundem   662  834  602    373         Default\n9            osterwald   271  347 1972    216         Default\n10           rinkerode    79  128  611    825         Default\n11              telgte    52  448 1899    969         Default\n12         wuelfenrath   412  421  119   1827         Default\n[1] \"area\"\n[1] \"bielefeld_brackwede\"\n[1] \"species\"\n[1] \"beech\"\n[1] \"area\"\n[1] \"billerbeck\"\n[1] \"species\"\n[1] \"beech\"\n[1] \"area\"\n[1] \"brilon\"\n[1] \"species\"\n[1] \"spruce\"\n[1] \"area\"\n[1] \"greffen\"\n[1] \"species\"\n[1] \"pine\"\n[1] \"area\"\n[1] \"hamm\"\n[1] \"species\"\n[1] \"oak\"\n[1] \"area\"\n[1] \"mesum\"\n[1] \"species\"\n[1] \"pine\"\n[1] \"area\"\n[1] \"muenster\"\n[1] \"species\"\n[1] \"oak\"\n[1] \"area\"\n[1] \"oberhundem\"\n[1] \"species\"\n[1] \"spruce\"\n[1] \"area\"\n[1] \"osterwald\"\n[1] \"species\"\n[1] \"spruce\"\n[1] \"area\"\n[1] \"rinkerode\"\n[1] \"species\"\n[1] \"oak\"\n[1] \"area\"\n[1] \"telgte\"\n[1] \"species\"\n[1] \"pine\"\n[1] \"area\"\n[1] \"wuelfenrath\"\n[1] \"species\"\n[1] \"beech\"\n\n\n\ncm &lt;- data$confusion_matrix\nlfa::lfa_plot_confusion_matrix(cm)\n\n\n\n\n\ndata$confusion_matrix |&gt; lfa::lfa_calculate_rf_metrics() |&gt; lfa::lfa_visualize_rf_metrics()\n\n\n\n\n\n\n3.7.2 Use neighbors and height\n\n\nCode\ndetections &lt;- lfa::lfa_get_detections()\nneighbors &lt;- lfa::lfa_get_neighbor_paths() |&gt; lfa::lfa_combine_sf_obj(lfa::lfa_get_all_areas())\nneighbors &lt;- sf::st_join(neighbors,detections, join = sf::st_within)\nnames(neighbors)[names(neighbors) == 'specie.x'] &lt;- 'specie'\nnames(neighbors)[names(neighbors) == 'area.x'] &lt;- 'area'\nexcluded_cols &lt;- c(\"area.x\",\"specie.x\",\"treeID.y\",\"Z.y\",\"area.y\",\"specie.y\",\"geom\",\"treeID.x\",\"Z.x\")\n\n\n\n\nCode\ndata &lt;- lfa::lfa_random_forest(tree_data = neighbors, excluded_input_columns = excluded_cols,response_variable = \"specie\")\n\n\n\n\nCode\ncm &lt;- data$confusion_matrix\nlfa::lfa_plot_confusion_matrix(cm)\n\n\n\n\n\nFigure 17: Confusion Matrix of randomForest on the distance to 100 nearest neighbors.\n\n\n\n\n\n\nCode\ndata$confusion_matrix |&gt; lfa::lfa_calculate_rf_metrics() |&gt; lfa::lfa_visualize_rf_metrics()\n\n\n\n\n\nFigure 18: Class wise precision and recall for randomForest-Classification with distance to the 100 nearest neighbors.\n\n\n\n\n\n\n3.7.3 LiDAR point cloud returns per Tree\n\n\nCode\nreturns &lt;- lfa::lfa_count_returns_all_areas()\nexcluded_cols = c(\"Var1\",\"specie\",\"area\")\n\n\n\n\nCode\ndata &lt;- lfa::lfa_random_forest(tree_data = returns, excluded_input_columns = excluded_cols,response_variable = \"specie\")\n\n\n\n\nCode\ncm &lt;- data$confusion_matrix\nlfa::lfa_plot_confusion_matrix(cm)\n\n\n\n\n\nFigure 19: Confusion Matrix of randomForest on returns per Tree.\n\n\n\n\n\n\nCode\ndata$confusion_matrix |&gt; lfa::lfa_calculate_rf_metrics() |&gt; lfa::lfa_visualize_rf_metrics()\n\n\n\n\n\nFigure 20: Class wise precision and recall for randomForest-Classification with LiDAR returns per tree.\n\n\n\n\n\n\n3.7.4 Segmentation\n\n\nCode\ndata &lt;- sf::st_read(\"./data/tree_properties.gpkg\")\ndetections &lt;- lfa::lfa_get_detections()\nneighbors &lt;- lfa::lfa_get_neighbor_paths() |&gt; lfa::lfa_combine_sf_obj(lfa::lfa_get_all_areas())\n\n\n\n\nCode\ncombined &lt;- sf::st_join(data,detections,join = sf::st_within)\n\ncombined$Z.x = NULL\nnames(combined)[names(combined) == 'Z.y'] &lt;- 'Z'\n\ncombined$treeID.segmentation &lt;- NULL\n\ncombined[[\"density\"]][is.na(combined[[\"density\"]])] &lt;- -1\ncombined[[\"Z.mean\"]][is.na(combined[[\"Z.mean\"]])] &lt;- -1\ncombined[[\"Z.var\"]][is.na(combined[[\"Z.var\"]])] &lt;- -1\ncombined[[\"Intensity.mean\"]][is.na(combined[[\"Intensity.mean\"]])] &lt;- -1\ncombined[[\"Intensity.var\"]][is.na(combined[[\"Intensity.var\"]])] &lt;- -1\ncombined[[\"number_of_returns\"]][is.na(combined[[\"number_of_returns\"]])] &lt;- -1\ncombined[[\"tree_area\"]][is.na(combined[[\"tree_area\"]])] &lt;- -1\n\nneighbors$treeID = NULL\nneighbors$Z = NULL\nneighbors$area = NULL\nneighbors$specie = NULL\n\ncombined = sf::st_join(combined, neighbors, sf::st_within)\nexcluded_cols &lt;- c(\"Z.x\", \"treeID.detection\",\"treeID.segmentation\",\"name_las_file\",\"treeID\",\"area\",\"specie\",\"geom\")\n\n\n\n\nCode\ndata &lt;- lfa::lfa_random_forest(tree_data = combined, excluded_input_columns = excluded_cols,response_variable = \"specie\")\n\n\n\n\nCode\ncm &lt;- data$confusion_matrix\nlfa::lfa_plot_confusion_matrix(cm)\n\n\n\n\n\nFigure 21: Confusion Matrix of randomForest with all parameters derived from tree level.\n\n\n\n\n\n\nCode\ndata$confusion_matrix |&gt; lfa::lfa_calculate_rf_metrics() |&gt; lfa::lfa_visualize_rf_metrics()\n\n\n\n\n\nFigure 22: Precsion and Recall of randomForest with all parameters derived from tree level.\n\n\n\n\n\n\n3.7.5 Train with patch level information\n\n\nCode\nchms &lt;- lfa::lfa_visit_all_areas(lfa::lfa_chm)\npatches &lt;- lfa::lfa_get_all_areas()\npatches$chm_mean = NA\npatches$chm_var = NA\npatches$chm_median = NA\nfor (area_key in names(chms)) {\n  area &lt;- chms[area_key]\n  area[[area_key]] |&gt; as.vector() -&gt; vec\n  patches[patches$area == area_key, \"chm_mean\"] &lt;-\n    mean(vec, na.rm = T)\n  patches[patches$area == area_key, \"chm_var\"] &lt;-\n    var(vec, na.rm = T)\n  patches[patches$area == area_key, \"chm_median\"] &lt;-\n    median(vec, na.rm = T)\n  \n}\n\n\n\n\nCode\nneighbors &lt;- lfa::lfa_get_neighbor_paths() |&gt; lfa::lfa_combine_sf_obj(lfa::lfa_get_all_areas())\n\n\n\n\nCode\ndetections &lt;- lfa::lfa_get_detections()\ndensity &lt;- lfa::lfa_calculate_patch_density(detections = detections)\ncolnames(density) &lt;- c(\"id\",\"specie\",\"area\",\"geometry\",\"area_size\",\"detections\",\"density\")\ndetections &lt;- dplyr::left_join(detections,density |&gt; as.data.frame(),by=c(\"area\",\"specie\"))\ndetections &lt;- dplyr::left_join(detections,patches, by = c(\"area\",\"specie\"))\n\ndetections &lt;- sf::st_join(detections, neighbors, join = sf::st_within)\n\ndetections$treeID.x = NULL\nnames(detections)[names(detections) == 'treeID.y'] &lt;- 'treeID'\n\ndetections$Z.x = NULL\nnames(detections)[names(detections) == 'Z.y'] &lt;- 'Z'\n\ndetections$area.x = NULL\nnames(detections)[names(detections) == 'area.y'] &lt;- 'area'\n\ndetections$specie.x = NULL\nnames(detections)[names(detections) == 'specie.y'] &lt;- 'specie'\n\nexcluded_cols = c(\"treeID\",\"geom\",\"area\",\"specie\",\"id\",\"geometry\",\"area_size\",\"detections\",\"geometry\")\n\n\n\n\nCode\ndata &lt;- lfa::lfa_random_forest(tree_data = detections, excluded_input_columns = excluded_cols,response_variable = \"specie\")\n\n\n\n\nCode\ncm &lt;- data$confusion_matrix\nlfa::lfa_plot_confusion_matrix(cm)\n\n\n\n\n\nFigure 23: Confusion Matrix of randomForest on returns per Tree.\n\n\n\n\n\n\nCode\ndata$confusion_matrix |&gt; lfa::lfa_calculate_rf_metrics() |&gt; lfa::lfa_visualize_rf_metrics()\n\n\n\n\n\nFigure 24: Class wise precision and recall for randomForest-Classification with LiDAR returns per tree."
  },
  {
    "objectID": "report.html#canopy-height-model",
    "href": "report.html#canopy-height-model",
    "title": "Forest Data Analysis Report",
    "section": "4.6 Canopy Height Model",
    "text": "4.6 Canopy Height Model\n\n\nCode\nchms &lt;- lfa::lfa_visit_all_areas(lfa::lfa_chm)\n\n\n\n\nCode\npatches &lt;- lfa::lfa_get_all_areas()\npatches$chm_mean = NA\npatches$chm_var = NA\npatches$chm_median = NA\nfor (area_key in names(chms)) {\n  area &lt;- chms[area_key]\n  area[[area_key]] |&gt; as.vector() -&gt; vec\n  patches[patches$area == area_key, \"chm_mean\"] &lt;-\n    mean(vec, na.rm = T)\n  patches[patches$area == area_key, \"chm_var\"] &lt;-\n    var(vec, na.rm = T)\n  patches[patches$area == area_key, \"chm_median\"] &lt;-\n    median(vec, na.rm = T)\n  \n}\n\n\n\n\nCode\nlfa::lfa_create_grouped_bar_plot(patches,\"specie\",\"chm_mean\",\"area\",ylab = \"Mean\", title = \"Mean Canopy Height\")\n\n\n\n\n\nFigure 14: Mean Canopy Height across all patches colored by the dominant specie of each patch.\n\n\n\n\n\n\nCode\nlfa::lfa_create_grouped_bar_plot(patches,\"specie\",\"chm_var\",\"area\",ylab = \"Variance\", title = \"Variance of Canopy Height\")\n\n\n\n\n\nFigure 15: Variance Canopy Height across all patches colored by the dominant specie of each patch.\n\n\n\n\n\n\nCode\nlfa::lfa_create_grouped_bar_plot(patches,\"specie\",\"chm_median\",\"area\",ylab = \"Median\", title = \"Median Canopy Height\")\n\n\n\n\n\nFigure 16: Median Canopy Height across all patches colored by the dominant specie of each patch.\n\n\n\n\nThis section outlines the presentation of Random Forest results, encompassing three models, each trained on different parameters. Each chapter provides an explanation for the selection of a particular model, offering insights into the reasoning behind our choices.\n\n4.6.1 Use neighbors and height\nA Random Forest model was trained on tree heights (z-values) and the distance to the nearest 100 neighbors. Despite achieving only medium results, this straightforward model clearly demonstrates the feasibility of distinguishing between tree species.\n\n\nCode\ndetections &lt;- lfa::lfa_get_detections()\nneighbors &lt;- lfa::lfa_get_neighbor_paths() |&gt; lfa::lfa_combine_sf_obj(lfa::lfa_get_all_areas())\nneighbors &lt;- sf::st_join(neighbors,detections, join = sf::st_within)\nnames(neighbors)[names(neighbors) == 'specie.x'] &lt;- 'specie'\nnames(neighbors)[names(neighbors) == 'area.x'] &lt;- 'area'\nexcluded_cols &lt;- c(\"area.x\",\"specie.x\",\"treeID.y\",\"Z.y\",\"area.y\",\"specie.y\",\"geom\",\"treeID.x\",\"Z.x\")\n\n\n\n\nCode\ndata &lt;- lfa::lfa_random_forest(tree_data = neighbors, excluded_input_columns = excluded_cols,response_variable = \"specie\")\n\n\n\n\nCode\nmodel.rf_neighbors &lt;- data\nsave(model.rf_neighbors, file = \"./models/neighbors.rData\")\n\n\nThe classifier exhibits notable performance variations across different classes. Precision for the “Beech” class is high, indicating accurate positive predictions, but the lower recall suggests the possibility of missing some instances of “Beech.” In contrast, both precision and recall for the “Oak” and “Pine” classes are extremely low, highlighting challenges in accurately classifying instances. The “Spruce” class shows moderate precision and high recall, indicating comparatively better performance.\n\n\nCode\ncm &lt;- data$confusion_matrix\nlfa::lfa_plot_confusion_matrix(cm)\n\n\n\n\n\nFigure 17: Confusion Matrix of randomForest on the distance to 100 nearest neighbors.\n\n\n\n\nThe model’s predictions for “Beech” are frequent but vary significantly, leading to substantial differences between Precision and Recall (see Figure 18). The model tends to make predictions that are either mostly correct or mostly incorrect, resulting in a homogenous prediction pattern, as illustrated in the confusion matrix (see Figure 17).\n\n\nCode\ndata$confusion_matrix |&gt; lfa::lfa_calculate_rf_metrics() |&gt; lfa::lfa_visualize_rf_metrics()\n\n\n\n\n\nFigure 18: Class wise precision and recall for randomForest-Classification with distance to the 100 nearest neighbors.\n\n\n\n\n\n\n4.6.2 Enrich Neighbors with segmentation data\nThis model employs the same parameters as the preceding one, while incorporating additional features derived from the segmentation of each tree in the point cloud. The expanded feature set includes density of returns per tree, mean and variance of Z values of return points, mean and variance of intensity of LiDAR returns, number of LiDAR returns per tree, and the area in square meters of each tree. The aim is to compare the results obtained with this augmented feature set against those based solely on tree detection characteristics.\n\n\nCode\ndata &lt;- sf::st_read(\"./data/tree_properties.gpkg\")\ndetections &lt;- lfa::lfa_get_detections()\nneighbors &lt;- lfa::lfa_get_neighbor_paths() |&gt; lfa::lfa_combine_sf_obj(lfa::lfa_get_all_areas())\n\n\n\n\nCode\ncombined &lt;- sf::st_join(data,detections,join = sf::st_within)\n\ncombined$Z.x = NULL\nnames(combined)[names(combined) == 'Z.y'] &lt;- 'Z'\n\ncombined$treeID.segmentation &lt;- NULL\n\ncombined[[\"density\"]][is.na(combined[[\"density\"]])] &lt;- -1\ncombined[[\"Z.mean\"]][is.na(combined[[\"Z.mean\"]])] &lt;- -1\ncombined[[\"Z.var\"]][is.na(combined[[\"Z.var\"]])] &lt;- -1\ncombined[[\"Intensity.mean\"]][is.na(combined[[\"Intensity.mean\"]])] &lt;- -1\ncombined[[\"Intensity.var\"]][is.na(combined[[\"Intensity.var\"]])] &lt;- -1\ncombined[[\"number_of_returns\"]][is.na(combined[[\"number_of_returns\"]])] &lt;- -1\ncombined[[\"tree_area\"]][is.na(combined[[\"tree_area\"]])] &lt;- -1\n\nneighbors$treeID = NULL\nneighbors$Z = NULL\nneighbors$area = NULL\nneighbors$specie = NULL\n\ncombined = sf::st_join(combined, neighbors, sf::st_within)\nexcluded_cols &lt;- c(\"Z.x\", \"treeID.detection\",\"treeID.segmentation\",\"name_las_file\",\"treeID\",\"area\",\"specie\",\"geom\")\n\n\n\n\nCode\ndata &lt;- lfa::lfa_random_forest(tree_data = combined, excluded_input_columns = excluded_cols,response_variable = \"specie\")\n\n\n\n\nCode\nmodel.rf_segmentation_detection_params &lt;- data\nsave(model.rf_segmentation_detection_params, file = \"./models/segmentation_detection_params.rData\")\n\n\n\n\nCode\ncm &lt;- data$confusion_matrix\nlfa::lfa_plot_confusion_matrix(cm)\n\n\n\n\n\nFigure 19: Confusion Matrix of randomForest with all parameters derived from tree level.\n\n\n\n\nThe classifier exhibits suboptimal performance for the “Beech” and “Oak” classes, with low precision and recall values, indicative of challenges in accurately classifying instances for these categories. In contrast, the “Pine” class demonstrates higher precision and recall, suggesting improved performance in capturing true instances while minimizing false positives. The “Spruce” class displays moderate precision and high recall, indicating relatively better performance in capturing true instances with fewer false positives.\nNotably, the overall accuracy (0.44) and Kappa (0.23) have significantly improved compared to the previous model (Accuracy = 0.35, Kappa = 0.14). The model demonstrates effectiveness for conifers but shows limitations for deciduous trees, as depicted in the confusion matrix at the tree-level (Figure 19). Specifically, “Oak” and “Beech” ground truth predictions are distributed among all classes, while “Pine” exhibits false negatives, especially for the “Spruce” class.\nAdditionally, this model achieves a more balanced distribution between Precision and Recall differences across classes, as illustrated in the Precision-Recall curve at the tree-level (Figure 20).\n\n\nCode\ndata$confusion_matrix |&gt; lfa::lfa_calculate_rf_metrics() |&gt; lfa::lfa_visualize_rf_metrics()\n\n\n\n\n\nFigure 20: Precsion and Recall of randomForest with all parameters derived from tree level.\n\n\n\n\n\n\n4.6.3 Train with patch level information\nIn this phase of our study, we examined the impact of patch-level information on the model. The model training incorporated Z-Values, distance to the 100 nearest neighbors, density of trees within a patch, as well as statistics related to the canopy height, including mean, variance, and median.\n\n\nCode\nchms &lt;- lfa::lfa_visit_all_areas(lfa::lfa_chm)\npatches &lt;- lfa::lfa_get_all_areas()\npatches$chm_mean = NA\npatches$chm_var = NA\npatches$chm_median = NA\nfor (area_key in names(chms)) {\n  area &lt;- chms[area_key]\n  area[[area_key]] |&gt; as.vector() -&gt; vec\n  patches[patches$area == area_key, \"chm_mean\"] &lt;-\n    mean(vec, na.rm = T)\n  patches[patches$area == area_key, \"chm_var\"] &lt;-\n    var(vec, na.rm = T)\n  patches[patches$area == area_key, \"chm_median\"] &lt;-\n    median(vec, na.rm = T)\n  \n}\n\n\n\n\nCode\nneighbors &lt;- lfa::lfa_get_neighbor_paths() |&gt; lfa::lfa_combine_sf_obj(lfa::lfa_get_all_areas())\n\n\n\n\nCode\ndetections &lt;- lfa::lfa_get_detections()\ndensity &lt;- lfa::lfa_calculate_patch_density(detections = detections)\ncolnames(density) &lt;- c(\"id\",\"specie\",\"area\",\"geometry\",\"area_size\",\"detections\",\"density\")\ndetections &lt;- dplyr::left_join(detections,density |&gt; as.data.frame(),by=c(\"area\",\"specie\"))\ndetections &lt;- dplyr::left_join(detections,patches, by = c(\"area\",\"specie\"))\n\ndetections &lt;- sf::st_join(detections, neighbors, join = sf::st_within)\n\ndetections$treeID.x = NULL\nnames(detections)[names(detections) == 'treeID.y'] &lt;- 'treeID'\n\ndetections$Z.x = NULL\nnames(detections)[names(detections) == 'Z.y'] &lt;- 'Z'\n\ndetections$area.x = NULL\nnames(detections)[names(detections) == 'area.y'] &lt;- 'area'\n\ndetections$specie.x = NULL\nnames(detections)[names(detections) == 'specie.y'] &lt;- 'specie'\n\nexcluded_cols = c(\"treeID\",\"geom\",\"area\",\"specie\",\"id\",\"geometry\",\"area_size\",\"detections\",\"geometry\")\n\n\n\n\nCode\ndata &lt;- lfa::lfa_random_forest(tree_data = detections, excluded_input_columns = excluded_cols,response_variable = \"specie\")\n\n\n\n\nCode\nmodel.rf_patch &lt;- data\nsave(model.rf_patch, file = \"./models/patch.rData\")\n\n\n\n\nCode\ncm &lt;- data$confusion_matrix\nlfa::lfa_plot_confusion_matrix(cm)\n\n\n\n\n\nFigure 21: Confusion Matrix of randomForest on returns per Tree.\n\n\n\n\nThe model yields favorable overall results, with an accuracy of 0.63 and a Kappa value of 0.49. Notably, predictions appear to be predominantly influenced by patch-level information, resulting in largely homogeneous predictions within most patches.\nFor the “Beech” and “Oak” classes, the classifier performs moderately well, exhibiting moderate precision and recall values. These values are within the same domain, with an equal balance between recall and precision for both classes.\nIn the case of the “Pine” class, high precision is accompanied by lower recall, indicating a conservative prediction approach. However, the classifier successfully captures a substantial portion of actual “Pine” instances. Noteworthy is the presence of outliers where “Pine” is falsely predicted as “Oak” (see Figure 21). These false predictions are concentrated in the Greffen patch, which contains a total of 513 detections. Notably, all significant Pine patches yield accurate predictions.\nThe “Spruce” class exhibits a good balance between precision and recall, with slightly better recall values. The deciduous vs. conifers comparison is notably successful, with conifers predicted mostly as true positives and false predictions for deciduous tree species predominantly leaning towards predicting deciduous trees.\n\n\nCode\ndata$confusion_matrix |&gt; lfa::lfa_calculate_rf_metrics() |&gt; lfa::lfa_visualize_rf_metrics()\n\n\n\n\n\nFigure 22: Class wise precision and recall for randomForest-Classification with LiDAR returns per tree."
  },
  {
    "objectID": "report.html#random-forest-for-predicting-species",
    "href": "report.html#random-forest-for-predicting-species",
    "title": "Evaluating Tree Species Diversity in Forest Ecosystems Using LiDAR Data: A Exploration in NRW",
    "section": "2.4 Random Forest for predicting species",
    "text": "2.4 Random Forest for predicting species\nThe aim of our research is to investigate the feasibility of developing a predictive model for tree species classification based on derived parameters. To accomplish this objective, we employed the Random Forest algorithm, as introduced by (Breiman 2001), which leverages multiple decision trees to predict the species of a given tree based on its characteristics.\nThe dataset utilized in our study consists of identified trees, and our primary goal is to predict the species of each tree. To establish ground truth for training and validation of the model, we assigned the dominant species to each distinct patch.\nFor validation purposes, we adopted a spatial cross-validation methodology, specifically implementing the leave-one-out principle. This technique systematically excludes a particular portion of the dataset in each iteration (Brovelli et al. 2008). In our spatial cross-validation, the group left out is determined based on their spatial characteristics (Valavi et al. 2018).\nOur combined approach entails designating the patches with tree detections as the left-out group. The model is trained on the training split and validated using the left-out (validation) split of the data. Ground truth and predictions from each iteration are stored, and the results from all iterations are aggregated into a confusion matrix for a comprehensive analysis.\nIn our evaluation of results, we utilized various statistical measurements. The accuracy, defined as the ratio of correct predictions to all predictions (Alvarez 2002), is calculated using the formula \\[\\text{Accuracy} = \\frac{\\text{Correct Predictions}}{\\text{All Predictions}}\\] This metric provides insight into the percentage of correct predictions.\nTo normalize accuracy in the context of a small number of classes (\\(n = 4\\)), Kohen’s Kappa Index was employed (Fleiss, Cohen, and Everitt 1969). The formula is given by \\[\\kappa = \\frac{P_o - P_e}{1 - P_e}\\] where \\(P_o\\) represents the observed agreement between raters, and \\(P_e\\) is the expected agreement, accounting for the probability of chance agreement.\nAnother crucial metric, precision, commonly used in binary classification, measures the accuracy of positive predictions (Cleverdon 1967). It is calculated as \\[\\text{Precision} = \\frac{\\text{True Positives}}{\\text{True Positives + False Positives}}\\]\nSimilarly, recall, also known as sensitivity or true positive rate, is essential in binary classification to assess the model’s ability to identify all relevant instances (Sparck Jones 1972). The formula for recall is \\[\\text{Recall} = \\frac{\\text{True Positives}}{\\text{True Positives + False Negatives}}\\]\nThese statistical measures collectively provide a comprehensive evaluation of the model’s performance, taking into account both overall accuracy and class-specific performance metrics."
  },
  {
    "objectID": "report.html#goals",
    "href": "report.html#goals",
    "title": "Forest Data Analysis Report",
    "section": "2.1 Goals",
    "text": "2.1 Goals"
  },
  {
    "objectID": "report.html#research-questions",
    "href": "report.html#research-questions",
    "title": "Forest Data Analysis Report",
    "section": "2.2 Research Questions",
    "text": "2.2 Research Questions"
  },
  {
    "objectID": "report.html#hypothesis",
    "href": "report.html#hypothesis",
    "title": "Forest Data Analysis Report",
    "section": "2.1 Hypothesis",
    "text": "2.1 Hypothesis"
  },
  {
    "objectID": "report.html#findings",
    "href": "report.html#findings",
    "title": "Evaluating Tree Species Diversity in Forest Ecosystems Using LiDAR Data: A Exploration in NRW",
    "section": "4.1 Findings",
    "text": "4.1 Findings\nNow, we will delve into the findings derived from the previously presented results, discussing them in the context of the hypotheses outlined in the Introduction. As we move forward, the discussion will delve into the alignment of our findings with the initial hypotheses, shedding light on the effectiveness of the employed methodology and the insights gained from the analysis.\nLiDAR data can effectively differentiate between tree species in monocultural forests in NRW, and there are statistically significant differences in the LiDAR-derived metrics among the various tree species.\nThe statement provided offers a nuanced perspective on the effectiveness of tree species differentiation based on the analysis conducted. It is acknowledged that the effectiveness of differentiation is intricately tied to the chosen criteria and the specific species under consideration. Notably, certain patch-level statistics, such as tree density, emerge as robust indicators for distinguishing between tree species. However, when scrutinizing the distribution of characteristics at the individual tree level, the variance between the distributions of patches from the same species is often not significantly smaller than the variance between distributions of different species. This observation suggests that relying solely on characteristics at the tree level might not yield distinct species differentiation. An interesting finding is the effectiveness of distinguishing between conifers and deciduous trees, with notable differences, particularly concerning Spruce trees. The identified dissimilarities, especially when comparing Spruce trees to other species, underscore the potential for effective differentiation in certain instances. The conclusion drawn emphasizes the importance of generating a comprehensive set of statistics for a defined area of interest and comparing the results to sample patches. This approach provides a robust indicator of the species distribution within the specified area. Importantly, the recommendation is against solely relying on one selected parameter, given the relatively high variance observed within the same species. Instead, a multifaceted analysis involving various parameters proves more effective in characterizing and distinguishing tree species in a given region.\nRandom Forest classification can be used to predict the tree species of trees in monoculteral forests.\nThe presented statement accurately captures the key findings and insights derived from the analysis of the tree models. It is affirmed that all tree models can be partially utilized to distinguish between tree species. However, not all models demonstrated consistently good results across all classes, with oak scoring moderately to low on the tree models. The observation that utilizing patch-level information for training the model enhances performance aligns with the understanding that aggregating information at a higher level of abstraction can provide more robust insights. Furthermore, the notable success in distinguishing between conifers and deciduous trees, especially with the last model, highlights the efficacy of the approach, showcasing high accuracy in this particular differentiation. The conclusion drawn, emphasizing the effectiveness of looking into all tree parameters for distinguishing between inspected tree species using the random forest method, underscores the comprehensive nature of the analysis. It suggests that a holistic consideration of multiple parameters enhances the model’s ability to accurately classify and distinguish between different tree species.\nRandom Forest classification performance varies significantly depending on the set of LiDAR parameters used, indicating that certain combinations of parameters contribute more effectively to accurate tree species classification.\nThe provided statement accurately characterizes the findings regarding the quality of results obtained from the three models and highlights important nuances in the analysis. Indeed, the quality of results exhibits high variance across all three models, considering overall statistics such as accuracy and Kohen’s Kappa, as well as class-specific measures like precision and recall. The mention of presenting only some highlights of the researched parameter combinations emphasizes that the models’ performance is influenced by a multitude of factors. The observation that incorporating segmentation parameters into the last model leads to a decrease in performance underscores the sensitivity of the model to specific parameter combinations. The statement further notes the high dependency of model performance on the utilized tree characteristics, with significant variations across different classes. For instance, the predictability of beech is highlighted, showcasing that certain parameters, such as tree heights and distance to neighbors, play a more crucial role in accurate predictions compared to others. The insight that another machine learning approach that can recognize the importance of specific parameters for the prediction of a certain class might be beneficial suggests avenues for further exploration and model refinement. Additionally, the variation in the power of differentiation between conifers and deciduous trees among the three models, with the last model outperforming others, reinforces the significance of the approach that incorporates patch-level information. This observation hints at the importance of considering a holistic view of the forest rather than relying solely on individual tree characteristics for certain tasks. In conclusion, the statement provides a comprehensive overview of the complexities and considerations involved in interpreting and optimizing the machine learning models for tree species prediction based on the dataset and analysis conducted."
  },
  {
    "objectID": "report.html#limitations",
    "href": "report.html#limitations",
    "title": "Evaluating Tree Species Diversity in Forest Ecosystems Using LiDAR Data: A Exploration in NRW",
    "section": "4.2 Limitations",
    "text": "4.2 Limitations\nOur approach, while yielding valuable insights, is not without its set of assumptions and limitations, each deserving careful consideration to grasp the nuances of our findings.\nFirstly, the assumption that all trees within the chosen areas of interest share the same species is integral to our methodology. While this assumption facilitates the development of predictive models, we acknowledge that 100% monocultural forests are rare in reality. Our validation process, primarily relying on Sentinel images, raises potential concerns regarding the inadvertent selection of mixed forests. Such a scenario could significantly impact the distribution of tree characteristics and introduce inaccuracies in the ground truth used for training the random forest algorithm. The temporal aspect of LiDAR data collection is a crucial factor that can significantly impact various LiDAR characteristics. LiDAR data may be captured at different seasons of the year, and these seasonal variations can introduce substantial differences in the derived information. For instance, the number of returns and intensities in LiDAR data can be highly influenced by the season during which the data is collected. Seasonal changes in vegetation, such as leaf growth or shedding, can impact the LiDAR returns. Another key assumption revolves around the representation of naturally grown forests in our areas of interest. Given the absence of true natural forests in Germany and North Rhine-Westphalia (NRW) due to forestry practices, our study areas may consist of newly planted or managed forests with differing characteristics. While this could potentially influence our analysis, we consider the impact relatively minor given the prevalent managed nature of forests in the region.\nWe assumed the independence of each forest in our study from its spatial environment. However, forests are inherently influenced by various factors such as neighborhood type, altitude, climate, and the presence of fauna. Despite our efforts to draw samples from diverse locations in NRW, these environmental variations persist, introducing a layer of complexity to our analysis. The relatively small sample size, with only three areas of interest per species, is another limitation. Increasing the sample size would undoubtedly enhance the robustness of our analysis and mitigate potential drawbacks associated with the limited number of samples. The correctness of our detection process, reliant on the accuracy of the LiDAR point cloud, is a crucial aspect. While the algorithm employed is established and widely used, the precision of our results hinges on the accuracy of the LiDAR detection process. Lastly, we acknowledge technical limitations, notably the tile-based segmentation approach used for processing efficiency. The choice of \\(50\\times50\\)m tiles, while suitable for practical hardware constraints, introduces potential challenges near tile borders. Trees located at these borders may be counted as two separate trees during the segmentation process, impacting our results.\nIn conclusion, understanding these assumptions and limitations is paramount for a nuanced interpretation of our results. Each aspect informs the intricacies of our methodology and underscores potential areas for refinement in future studies."
  },
  {
    "objectID": "report.html#further-work",
    "href": "report.html#further-work",
    "title": "Evaluating Tree Species Diversity in Forest Ecosystems Using LiDAR Data: A Exploration in NRW",
    "section": "4.3 Further Work",
    "text": "4.3 Further Work\nOur work has laid the foundation for further exploration and refinement in the field of tree species prediction and analysis. As we reflect on our findings, several avenues for future research and optimization strategies emerge.\nOne promising direction involves delving into the predictability of other tree species. While our study focused on Beech, Oak, Pine, and Spruce, primarily due to their regional relevance, investigating the performance of our methods on a broader spectrum of species could provide valuable insights into the generalizability of our models.\nExpanding the geographical scope of our approach is another intriguing prospect. Our study was confined to a localized area in North Rhine-Westphalia (NRW). Testing the project’s performance in diverse regions with similar species could unravel variations influenced by different environmental conditions. Additionally, exploring potential spatial trends in derived parameters and model performance could enhance our understanding of broader patterns.\nIf tree-level datasets are available, future research could test the derived parameters without the assumption that all trees within a patch share the same species. This would offer a more nuanced representation of individual tree characteristics and potentially enhance the accuracy of the random forest models.\nQuantitative parameter selection methods present an opportunity for optimization. Moving beyond a trial-and-error approach, incorporating metrics like Kullback-Leibler Divergence (KLD) and Jensen-Shannon Divergence (JSD) into the selection process could provide a systematic and data-driven way to identify relevant parameters. Advanced techniques, such as reinforced learning methods, may also hold promise in this context.\nDataset quality optimization, particularly the removal of outliers, is another avenue for exploration. Many character distributions in our dataset exhibited outliers, and assessing the impact of outlier removal on random forest accuracy could be a valuable optimization strategy.\nFinally, exploring additional tree statistics beyond those considered in our current study could enrich our understanding. This might involve investigating intensity distribution, the number of returns distribution on the z-axis per tree, and more sophisticated spatial point pattern analyses (Pebesma and Bivand 2023). Techniques like Ripley’s reduced second moment function (Ripley 1977) could offer deeper insights into spatial patterns.\nIncorporating these avenues into future research endeavors has the potential to advance the field, refining methodologies and expanding the applicability of tree species prediction and analysis. Our work, while a significant step forward, lays the groundwork for a more comprehensive exploration of the intricacies within this domain."
  },
  {
    "objectID": "report.html#conclusion",
    "href": "report.html#conclusion",
    "title": "Evaluating Tree Species Diversity in Forest Ecosystems Using LiDAR Data: A Exploration in NRW",
    "section": "4.4 Conclusion",
    "text": "4.4 Conclusion\nOur research aimed to investigate the usability of LiDAR data in distinguishing between tree species in monocultural forests, contributing to the field of forest monitoring. The overall success of our approach suggests promising outcomes. However, it’s important to acknowledge and further address certain limitations identified in our work. Future endeavors in this line of research could delve deeper into these limitations to enhance the robustness and applicability of the methodology. The potential utility of our approach in forest monitoring applications is a significant finding. The ability to distinguish between tree species in monocultural forests using LiDAR data offers valuable insights for forest management and ecological studies. The success of our methodology lays a foundation for continued research and application in real-world scenarios, potentially influencing forest monitoring practices.\nIn summary, our research has demonstrated the viability of using LiDAR data for distinguishing tree species in monocultural forests, contributing to the broader field of forest monitoring. By addressing and expanding upon the identified limitations, our approach has the potential to become a valuable tool in practical forest management and environmental research."
  },
  {
    "objectID": "report.html#distribution-of-tree-characteristics",
    "href": "report.html#distribution-of-tree-characteristics",
    "title": "Evaluating Tree Species Diversity in Forest Ecosystems Using LiDAR Data: A Exploration in NRW",
    "section": "3.2 Distribution of tree characteristics",
    "text": "3.2 Distribution of tree characteristics\nThe following subsections describe the distributions of different tree characterestics across the different species and patches.\n\n3.2.1 Tree Heights\n\n\nCode\ndetections &lt;- lfa::lfa_get_detections()\n\n\nIn this study, we scrutinize the distribution of tree heights, focusing initially on the density distribution to unravel the nuances across various tree species. Notably, our examination reveals distinctive patterns, with Oak and Pine exhibiting significantly steeper peaks in their density curves compared to Beech and Spruce. While all species present unique density curves, a commonality emerges—each curve is characterized by a single peak, except for the intriguing exception observed in Telgte. Taking Beech as an illustrative example, our findings indicate a notable shift in the peak to a considerably higher extent. The varinace in the density curves indicating that an differentiation between species only with the help of tree height values could be difficult.\n\n\nCode\nlfa::lfa_create_density_plots(detections, value_column = \"Z\", category_column1 = \"area\", category_column2 = \"specie\", title = \"Density of the height distributions\", xlims = c(0,50))\n\n\n\n\n\nFigure 2: Density of the height distribitions of the detectected trees. Splitted by the different researched areas and grouped by the dominant specie in this area.\n\n\n\n\nTo have a deeper look into the distributions of those Z-values we will now also have a look into the boxplots of the height distrubutions in the different areas. Noteworthy observations include the presence of outliers beyond the extended range of the Whisker Antennas (\\(1.5*\\text{IQR}\\)) in all datasets. Of particular interest is the Rinkerode dataset, which exhibits a higher prevalence of outliers in the upper domain. Anomalies in this dataset are attributed to potential inaccuracies, urging a critical examination of data integrity. A pairwise examination of Oak and Pine species indicates higher mean heights for Oak compared to Pine. This insight underscores the significance of species-specific attributes in shaping overall height distributions. Further exploration into the factors contributing to these mean differences enhances our understanding of the unique characteristics inherent to each species. Contrary to expectations, the spread within a particular species does not exhibit significant divergence from the spread observed between different species. This finding suggests that while species-specific traits play a crucial role in shaping height distributions, certain overarching factors may contribute to shared patterns across diverse tree populations.\n\n\nCode\nlfa::lfa_create_boxplot(detections, value_column = \"Z\", category_column1 = \"area\", category_column2 = \"specie\", title = \"Boxplots of the height distributions\")\n\n\n\n\n\nFigure 3: Boxplots of the height distribitions of the detectected trees. Splitted by the different researched areas and grouped by the dominant specie in this area.\n\n\n\n\nOur examination of Kullback-Leibler Divergence (KLD) and Jensen-Shannon Divergence (JSD) metrics reveals low mean values (KLD: 5.252696, JSD: 2.246663) across different species, indicating overall similarity in tree species height distributions. However, within specific species, particularly Pine, higher divergence values (see Table 5 and Table 10) suggest significant intraspecific differences.\nNotably, the Spruce species consistently demonstrates low divergence values across all tested areas, implying a high level of explainability. This finding highlights tree height as a reliable indicator for detecting Spruce trees, indicating its potential for accurate species identification in diverse forest ecosystems.\n\n\n3.2.2 Number of returns\n\n\nCode\ndata &lt;- sf::st_read(\"data/tree_properties.gpkg\")\nneighbors &lt;- lfa::lfa_get_neighbor_paths() |&gt; lfa::lfa_combine_sf_obj(lfa::lfa_get_all_areas())\ndata = sf::st_join(data,neighbors, join = sf::st_within)\n\n\nExamining the distribution of LiDAR returns per tree is the focus of our current investigation. Initial analysis involves the study of density graphs representing the distribution of LiDAR returns. The density curves for each species exhibit distinct peaks corresponding to their respective species, providing a clear differentiation in LiDAR return patterns. Notably, there is an exception observed in the Brilon patch (Spruce), where the curve deviates, possibly indicative of variations in forest age. A noteworthy trend is the divergent shape of density curves between coniferous and deciduous trees. Conifers exhibit steeper curves, indicating lower density for higher return values compared to deciduous trees. This disparity underscores the potential of LiDAR data to distinguish between tree types based on return density characteristics. In the case of Beech trees, the peaks’ heights vary among different curves, suggesting nuanced variations within the species. Despite these differences, all species consistently peak in similar regions, emphasizing the overarching similarities in LiDAR return patterns across diverse tree species.\n\n\nCode\nlfa::lfa_create_density_plots(data, value_column = \"number_of_returns\", category_column1 = \"area\", category_column2 = \"specie\", title = \"Density of the distribution of LiDAR returns per individual tree\", xlims = c(0,10000))\n\n\n\n\n\nFigure 4: Density of the amount of LiDAR returns per detectected tree. Splitted by the different researched areas and grouped by the dominant specie in this area.\n\n\n\n\nCurrently, our investigation focuses on boxplots representing each patch. We observe significant size variations among plots within the same species. Notably, numerous outliers are present above the box in each patch. For Pines, the boxes exhibit a notable similarity. However, the box for Brilon is entirely shifted from other boxes associated with patches featuring Spruce forest.\n\n\nCode\nlfa::lfa_create_boxplot(data, value_column = \"number_of_returns\", category_column1 = \"area\", category_column2 = \"specie\", title = \"Boxplots of the distribution of LiDAR returns per individual tree\")\n\n\n\n\n\nFigure 5: Boxplots of the the amount of LiDAR returns per detectected tree. Splitted by the different researched areas and grouped by the dominant specie in this area.\n\n\n\n\nOverall, our analysis reveals very low results for both Kullback-Leibler Divergence (KLD) and Jensen-Shannon Divergence (JSD) metrics across different species. Within species, there is high explainability observed for the different LiDAR return curves between patches.\nThis suggests that the number of returns alone may not be a robust predictor for identifying the dominant species in a forest. However, the curves indicate a clear potential for distinguishing between conifers (Pine and Spruce) and deciduous trees (Beech and Oak) based on the number of returns. This observation is further supported by the JSD scores, as detailed in Table 47.\n\n\n3.2.3 n-nearest Neighbours\n\n\nCode\nneighbors &lt;- lfa::lfa_combine_sf_obj(lfa::lfa_get_neighbor_paths(),lfa::lfa_get_all_areas())\n\n\n\nOverview\nTo initiate our analysis, we first establish a framework for selecting neighbors by examining the distance development with different \\(n\\), as illustrated in Figure 6. The curves share a similar design, but the actual values vary. Notably, as \\(n\\) increases, the distance between all patches also increases, indicating a broader spatial context.\nConsidering this trend, we extend our investigation beyond the nearest neighbor to include the 100th nearest neighbor. The \\(\\Delta\\)distance shows a consistent decrease with each increment in \\(n\\), reinforcing our decision to limit exploration beyond \\(n\\) of a hundred. Additionally, the constraint is driven by practical considerations, as our sample size occasionally lacks the capacity to explore larger \\(n\\) values, resulting in inaccurate values due to the absence of the true nearest neighbor within the sample area.\n\n\nCode\nlfa::lfa_create_neighbor_mean_curves(neighbors) |&gt; lfa::lfa_create_plot_per_area()\n\n\n\n\n\nFigure 6: Average Distance to n-nearest neighbor from each patch. For simplicity colored by the dominant specie of each tree.\n\n\n\n\n\n\nThe Nearest Neighbour\nOur initial focus centers on examining the distance to the nearest neighbor for each tree. Notably, the curve representing Spruce exhibits distinct characteristics compared to the three other curves—displaying a steeper profile with less variance, as depicted in Figure 7.\nFurther analysis of all patches reveals similar distributions, as evident in the boxplot shown in Figure 2 (Figure 8), where mean and variance demonstrate consistency across patches. However, these graphical statistics present challenges in effectively distinguishing between different tree species based on the distance to the nearest neighbor.\n\n\nCode\nlfa::lfa_create_density_plots(neighbors,value_column = \"Neighbor_1\",category_column1 = \"area\",category_column2 = \"specie\", title = \"Density plots for the nearest neighbor among species and areas\", xlims = c(0,15))\n\n\n\n\n\nFigure 7: Density plot of the distance to the nearest neighbor distribution across all patches grouped by the dominant species.\n\n\n\n\n\n\nCode\nlfa::lfa_create_boxplot(neighbors,value_column = \"Neighbor_1\",category_column1 = \"area\",category_column2 = \"specie\", title = \"Box plots for the nearest neighbor among species and areas\")\n\n\n\n\n\nFigure 8: Density plot of the distance to the nearest neighbor distribution across all patches grouped by the dominant species.\n\n\n\n\n\n\nThe 100th nearest Neighbor\nMoving on to the analysis of the 100th nearest neighbor, intriguing patterns emerge. Peaks in the curves display varying heights and positions, with a notable example being the complete shift between Oak and Spruce, as illustrated in Figure 9.\nHowever, it is essential to acknowledge the high variance observed between curves within a species, such as Pine or Beech. While this variance could serve as a potential indicator, it comes with the caveat that the sample size must be substantial for reliable conclusions.\nExamining boxplots reveals numerous outliers above the boxes, hinting at potential edge effects on the sides of patches. This observation raises concerns about the adequacy of trees in these areas for a more in-depth analysis, posing challenges in deriving accurate insights.\n\n\nCode\nlfa::lfa_create_density_plots(neighbors,value_column = \"Neighbor_100\",category_column1 = \"area\",category_column2 = \"specie\", title = \"Density plots for the nearest neighbor along species and areas\", xlims = c(35,100))\n\n\n\n\n\nFigure 9: Density plot of the distance to the nearest neighbor distribution across all patches grouped by the dominant species.\n\n\n\n\n\n\nCode\nlfa::lfa_create_boxplot(neighbors,value_column = \"Neighbor_100\",category_column1 = \"area\",category_column2 = \"specie\", title = \"Box plots for the nearest neighbor along species and areas\")\n\n\n\n\n\nFigure 10: Density plot of the distance to the nearest neighbor distribution across all patches grouped by the dominant species.\n\n\n\n\n\n\nAverage distance to 100 nearest neighbors\n\n\nCode\nnames &lt;- paste0(\"Neighbor_\",1:100)\nneighbors$avg = rowMeans(dplyr::select(as.data.frame(neighbors),names))\n\n\nTurning our attention to the averages of the first 100 neighbors, our analysis indicates strikingly similar results. There is considerable variance observed between different species, as well as within individual species, as depicted in Figure 11.\nDespite the uniformity in average results, the issue of outliers persists, as evident in the boxplot representation shown in Figure 12. These outliers pose challenges and may be indicative of specific environmental conditions affecting tree distributions. Further exploration is required to better understand and mitigate the impact of outliers on our analysis.\n\n\nCode\nlfa::lfa_create_density_plots(neighbors,value_column = \"avg\",category_column1 = \"area\",category_column2 = \"specie\", title = \"Density plots for the average of 100 nearest neighbors\", xlims = c(25,60))\n\n\n\n\n\nFigure 11: Density plot of the average distance to the nearest neighbor (n=100) distribution across all patches grouped by the dominant species.\n\n\n\n\nThe neighbor analysis proves potentially useful for distinguishing between tree species, yet the observed variances within each species suggest that relying solely on distance to neighbors may not suffice.\nA critical consideration is the sample size problem, wherein more distinguishable patterns emerge with higher neighbor levels, but this necessitates a sufficiently large sample size. Unfortunately, deriving a clear relationship between sample size and the number of tree neighbors remains elusive in our current findings. This gap in understanding could be a pertinent subject for further research, delving into the intricate interplay between sample size and the effectiveness of neighbor analysis in species differentiation.\n\n\nCode\nlfa::lfa_create_boxplot(neighbors,value_column = \"avg\",category_column1 = \"area\",category_column2 = \"specie\", title = \"Box plots for the average to the nearest neighbor across all species and areas\")\n\n\n\n\n\nFigure 12: Density plot of the average distance to the nearest neighbor (n = 100) distribution across all patches grouped by the dominant species.\n\n\n\n\n\n\n\n3.2.4 Density of forest patches\nExamining densities provides valuable insights into identifying the dominant species within patches. Spruce stands out as the densest species, surpassing all other patches. Following closely in density is Pine, as depicted in Figure 13.\nBeech and Oak exhibit similar density levels, with Beech consistently denser across all patches. When comparing the highest density patches for each species, Beech consistently outpaces Oak. While Oak is slightly less dense overall (\\(8.354499 \\times 10^{-3} \\frac{1}{m^2}\\)) than Beech (\\(8.727781 \\times 10^{-3} \\frac{1}{m^2}\\)), the distinction in density remains noticeable.\n\n\nCode\nlibrary(units)\nlfa::lfa_calculate_patch_density() |&gt;\n  lfa::lfa_create_grouped_bar_plot(grouping_var = \"species\", value_col = \"density\", label_col = \"name\")\n\n\n\n\n\nFigure 13: Barplot of the densitys of all patches (#detected trees/area of patch). Colorized by the dominant tree species of each patch.\n\n\n\n\nIn summary, our findings indicate that the density of each patch proves highly effective in distinguishing dominant species. Furthermore, the differentiation between conifers (Pine and Spruce) and deciduous trees (Beech and Oak) based on density aligns with patterns observed in the number of return points per detected tree. While distinguishing within conifers is straightforward, discerning between the deciduous tree species Beech and Oak, is possible but poses a moderate challenge.\n\n\n3.2.5 Canopy Height Model\n\n\nCode\nchms &lt;- lfa::lfa_visit_all_areas(lfa::lfa_chm)\n\n\n\n\nCode\npatches &lt;- lfa::lfa_get_all_areas()\npatches$chm_mean = NA\npatches$chm_var = NA\npatches$chm_median = NA\nfor (area_key in names(chms)) {\n  area &lt;- chms[area_key]\n  area[[area_key]] |&gt; as.vector() -&gt; vec\n  patches[patches$area == area_key, \"chm_mean\"] &lt;-\n    mean(vec, na.rm = T)\n  patches[patches$area == area_key, \"chm_var\"] &lt;-\n    var(vec, na.rm = T)\n  patches[patches$area == area_key, \"chm_median\"] &lt;-\n    median(vec, na.rm = T)\n  \n}\n\n\n\n\nCode\nlfa::lfa_create_grouped_bar_plot(patches,\"specie\",\"chm_mean\",\"area\",ylab = \"Mean\", title = \"Mean Canopy Height\")\n\n\n\n\n\nFigure 14: Mean Canopy Height across all patches colored by the dominant specie of each patch.\n\n\n\n\n\n\nCode\nlfa::lfa_create_grouped_bar_plot(patches,\"specie\",\"chm_var\",\"area\",ylab = \"Variance\", title = \"Variance of Canopy Height\")\n\n\n\n\n\nFigure 15: Variance Canopy Height across all patches colored by the dominant specie of each patch.\n\n\n\n\n\n\nCode\nlfa::lfa_create_grouped_bar_plot(patches,\"specie\",\"chm_median\",\"area\",ylab = \"Median\", title = \"Median Canopy Height\")\n\n\n\n\n\nFigure 16: Median Canopy Height across all patches colored by the dominant specie of each patch."
  },
  {
    "objectID": "report.html#random-forest-predictions",
    "href": "report.html#random-forest-predictions",
    "title": "Evaluating Tree Species Diversity in Forest Ecosystems Using LiDAR Data: A Exploration in NRW",
    "section": "3.3 Random Forest Predictions",
    "text": "3.3 Random Forest Predictions\nThis section outlines the presentation of Random Forest results, encompassing three models, each trained on different parameters. Each chapter provides an explanation for the selection of a particular model, offering insights into the reasoning behind our choices.\n\n3.3.1 Use neighbors and height\nA Random Forest model was trained on tree heights (z-values) and the distance to the nearest 100 neighbors. Despite achieving only medium results, this straightforward model clearly demonstrates the feasibility of distinguishing between tree species.\n\n\nCode\ndetections &lt;- lfa::lfa_get_detections()\nneighbors &lt;- lfa::lfa_get_neighbor_paths() |&gt; lfa::lfa_combine_sf_obj(lfa::lfa_get_all_areas())\nneighbors &lt;- sf::st_join(neighbors,detections, join = sf::st_within)\nnames(neighbors)[names(neighbors) == 'specie.x'] &lt;- 'specie'\nnames(neighbors)[names(neighbors) == 'area.x'] &lt;- 'area'\nexcluded_cols &lt;- c(\"area.x\",\"specie.x\",\"treeID.y\",\"Z.y\",\"area.y\",\"specie.y\",\"geom\",\"treeID.x\",\"Z.x\")\n\n\n\n\nCode\ndata &lt;- lfa::lfa_random_forest(tree_data = neighbors, excluded_input_columns = excluded_cols,response_variable = \"specie\")\n\n\n\n\nCode\nmodel.rf_neighbors &lt;- data\nsave(model.rf_neighbors, file = \"./models/neighbors.rData\")\n\n\nThe classifier exhibits notable performance variations across different classes. Precision for the “Beech” class is high, indicating accurate positive predictions, but the lower recall suggests the possibility of missing some instances of “Beech.” In contrast, both precision and recall for the “Oak” and “Pine” classes are extremely low, highlighting challenges in accurately classifying instances. The “Spruce” class shows moderate precision and high recall, indicating comparatively better performance.\n\n\nCode\ncm &lt;- data$confusion_matrix\nlfa::lfa_plot_confusion_matrix(cm)\n\n\n\n\n\nFigure 17: Confusion Matrix of randomForest on the distance to 100 nearest neighbors.\n\n\n\n\nThe model’s predictions for “Beech” are frequent but vary significantly, leading to substantial differences between Precision and Recall (see Figure 18). The model tends to make predictions that are either mostly correct or mostly incorrect, resulting in a homogenous prediction pattern, as illustrated in the confusion matrix (see Figure 17).\n\n\nCode\ndata$confusion_matrix |&gt; lfa::lfa_calculate_rf_metrics() |&gt; lfa::lfa_visualize_rf_metrics()\n\n\n\n\n\nFigure 18: Class wise precision and recall for randomForest-Classification with distance to the 100 nearest neighbors.\n\n\n\n\n\n\n3.3.2 Enrich Neighbors with segmentation data\nThis model employs the same parameters as the preceding one, while incorporating additional features derived from the segmentation of each tree in the point cloud. The expanded feature set includes density of returns per tree, mean and variance of Z values of return points, mean and variance of intensity of LiDAR returns, number of LiDAR returns per tree, and the area in square meters of each tree. The aim is to compare the results obtained with this augmented feature set against those based solely on tree detection characteristics.\n\n\nCode\ndata &lt;- sf::st_read(\"./data/tree_properties.gpkg\")\ndetections &lt;- lfa::lfa_get_detections()\nneighbors &lt;- lfa::lfa_get_neighbor_paths() |&gt; lfa::lfa_combine_sf_obj(lfa::lfa_get_all_areas())\n\n\n\n\nCode\ncombined &lt;- sf::st_join(data,detections,join = sf::st_within)\n\ncombined$Z.x = NULL\nnames(combined)[names(combined) == 'Z.y'] &lt;- 'Z'\n\ncombined$treeID.segmentation &lt;- NULL\n\ncombined[[\"density\"]][is.na(combined[[\"density\"]])] &lt;- -1\ncombined[[\"Z.mean\"]][is.na(combined[[\"Z.mean\"]])] &lt;- -1\ncombined[[\"Z.var\"]][is.na(combined[[\"Z.var\"]])] &lt;- -1\ncombined[[\"Intensity.mean\"]][is.na(combined[[\"Intensity.mean\"]])] &lt;- -1\ncombined[[\"Intensity.var\"]][is.na(combined[[\"Intensity.var\"]])] &lt;- -1\ncombined[[\"number_of_returns\"]][is.na(combined[[\"number_of_returns\"]])] &lt;- -1\ncombined[[\"tree_area\"]][is.na(combined[[\"tree_area\"]])] &lt;- -1\n\nneighbors$treeID = NULL\nneighbors$Z = NULL\nneighbors$area = NULL\nneighbors$specie = NULL\n\ncombined = sf::st_join(combined, neighbors, sf::st_within)\nexcluded_cols &lt;- c(\"Z.x\", \"treeID.detection\",\"treeID.segmentation\",\"name_las_file\",\"treeID\",\"area\",\"specie\",\"geom\")\n\n\n\n\nCode\ndata &lt;- lfa::lfa_random_forest(tree_data = combined, excluded_input_columns = excluded_cols,response_variable = \"specie\")\n\n\n\n\nCode\nmodel.rf_segmentation_detection_params &lt;- data\nsave(model.rf_segmentation_detection_params, file = \"./models/segmentation_detection_params.rData\")\n\n\n\n\nCode\ncm &lt;- data$confusion_matrix\nlfa::lfa_plot_confusion_matrix(cm)\n\n\n\n\n\nFigure 19: Confusion Matrix of randomForest with all parameters derived from tree level.\n\n\n\n\nThe classifier exhibits suboptimal performance for the “Beech” and “Oak” classes, with low precision and recall values, indicative of challenges in accurately classifying instances for these categories. In contrast, the “Pine” class demonstrates higher precision and recall, suggesting improved performance in capturing true instances while minimizing false positives. The “Spruce” class displays moderate precision and high recall, indicating relatively better performance in capturing true instances with fewer false positives.\nNotably, the overall accuracy (0.44) and Kappa (0.23) have significantly improved compared to the previous model (Accuracy = 0.35, Kappa = 0.14). The model demonstrates effectiveness for conifers but shows limitations for deciduous trees, as depicted in the confusion matrix at the tree-level (Figure 19). Specifically, “Oak” and “Beech” ground truth predictions are distributed among all classes, while “Pine” exhibits false negatives, especially for the “Spruce” class.\nAdditionally, this model achieves a more balanced distribution between Precision and Recall differences across classes, as illustrated in the Precision-Recall curve at the tree-level (Figure 20).\n\n\nCode\ndata$confusion_matrix |&gt; lfa::lfa_calculate_rf_metrics() |&gt; lfa::lfa_visualize_rf_metrics()\n\n\n\n\n\nFigure 20: Precsion and Recall of randomForest with all parameters derived from tree level.\n\n\n\n\n\n\n3.3.3 Train with patch level information\nIn this phase of our study, we examined the impact of patch-level information on the model. The model training incorporated Z-Values, distance to the 100 nearest neighbors, density of trees within a patch, as well as statistics related to the canopy height, including mean, variance, and median.\n\n\nCode\nchms &lt;- lfa::lfa_visit_all_areas(lfa::lfa_chm)\npatches &lt;- lfa::lfa_get_all_areas()\npatches$chm_mean = NA\npatches$chm_var = NA\npatches$chm_median = NA\nfor (area_key in names(chms)) {\n  area &lt;- chms[area_key]\n  area[[area_key]] |&gt; as.vector() -&gt; vec\n  patches[patches$area == area_key, \"chm_mean\"] &lt;-\n    mean(vec, na.rm = T)\n  patches[patches$area == area_key, \"chm_var\"] &lt;-\n    var(vec, na.rm = T)\n  patches[patches$area == area_key, \"chm_median\"] &lt;-\n    median(vec, na.rm = T)\n  \n}\n\n\n\n\nCode\nneighbors &lt;- lfa::lfa_get_neighbor_paths() |&gt; lfa::lfa_combine_sf_obj(lfa::lfa_get_all_areas())\n\n\n\n\nCode\ndetections &lt;- lfa::lfa_get_detections()\ndensity &lt;- lfa::lfa_calculate_patch_density(detections = detections)\ncolnames(density) &lt;- c(\"id\",\"specie\",\"area\",\"geometry\",\"area_size\",\"detections\",\"density\")\ndetections &lt;- dplyr::left_join(detections,density |&gt; as.data.frame(),by=c(\"area\",\"specie\"))\ndetections &lt;- dplyr::left_join(detections,patches, by = c(\"area\",\"specie\"))\n\ndetections &lt;- sf::st_join(detections, neighbors, join = sf::st_within)\n\ndetections$treeID.x = NULL\nnames(detections)[names(detections) == 'treeID.y'] &lt;- 'treeID'\n\ndetections$Z.x = NULL\nnames(detections)[names(detections) == 'Z.y'] &lt;- 'Z'\n\ndetections$area.x = NULL\nnames(detections)[names(detections) == 'area.y'] &lt;- 'area'\n\ndetections$specie.x = NULL\nnames(detections)[names(detections) == 'specie.y'] &lt;- 'specie'\n\nexcluded_cols = c(\"treeID\",\"geom\",\"area\",\"specie\",\"id\",\"geometry\",\"area_size\",\"detections\",\"geometry\")\n\n\n\n\nCode\ndata &lt;- lfa::lfa_random_forest(tree_data = detections, excluded_input_columns = excluded_cols,response_variable = \"specie\")\n\n\n\n\nCode\nmodel.rf_patch &lt;- data\nsave(model.rf_patch, file = \"./models/patch.rData\")\n\n\n\n\nCode\ncm &lt;- data$confusion_matrix\nlfa::lfa_plot_confusion_matrix(cm)\n\n\n\n\n\nFigure 21: Confusion Matrix of randomForest on returns per Tree.\n\n\n\n\nThe model yields favorable overall results, with an accuracy of 0.63 and a Kappa value of 0.49. Notably, predictions appear to be predominantly influenced by patch-level information, resulting in largely homogeneous predictions within most patches.\nFor the “Beech” and “Oak” classes, the classifier performs moderately well, exhibiting moderate precision and recall values. These values are within the same domain, with an equal balance between recall and precision for both classes.\nIn the case of the “Pine” class, high precision is accompanied by lower recall, indicating a conservative prediction approach. However, the classifier successfully captures a substantial portion of actual “Pine” instances. Noteworthy is the presence of outliers where “Pine” is falsely predicted as “Oak” (see Figure 21). These false predictions are concentrated in the Greffen patch, which contains a total of 513 detections. Notably, all significant Pine patches yield accurate predictions.\nThe “Spruce” class exhibits a good balance between precision and recall, with slightly better recall values. The deciduous vs. conifers comparison is notably successful, with conifers predicted mostly as true positives and false predictions for deciduous tree species predominantly leaning towards predicting deciduous trees.\n\n\nCode\ndata$confusion_matrix |&gt; lfa::lfa_calculate_rf_metrics() |&gt; lfa::lfa_visualize_rf_metrics()\n\n\n\n\n\nFigure 22: Class wise precision and recall for randomForest-Classification with LiDAR returns per tree."
  },
  {
    "objectID": "report.html#implementation",
    "href": "report.html#implementation",
    "title": "Evaluating Tree Species Diversity in Forest Ecosystems Using LiDAR Data: A Exploration in NRW",
    "section": "2.5 Implementation",
    "text": "2.5 Implementation\nIn the implementation of our project aimed at utilizing LiDAR data for distinguishing tree species in monocultural forests, we chose R as our programming language. This decision was driven by the robust and well-maintained package infrastructure offered by R, providing a solid foundation for our work. Additionally, R’s inherent capability to handle large data structures efficiently proved advantageous for our project, where processing LiDAR point clouds required a scalable and effective solution.\nOur implementation relied on four key R packages, each serving a crucial role in the project’s success:\n\nlidR: This package played a fundamental role in handling and processing LiDAR point clouds. Its capabilities were essential for the core management of LiDAR data throughout our analysis (Roussel et al. 2020).\nsf: Used for managing spatial vector data and conducting spatial operations, the sf package enriched our analysis with essential spatial components, enhancing the geographical dimension of our research (Pebesma 2018).\ndplyr: As a package specialized in data manipulation, dplyr provided indispensable tools for shaping and organizing our data to meet the specific requirements of our analysis (Wickham et al. 2023).\nggplot2: Renowned for its proficiency in creating high-quality visualizations, ggplot2 was employed to present our results in a manner that is not only informative but also reproducible (Wickham 2016).\n\nTo streamline the implementation process and make our work accessible to others, we encapsulated these functionalities into a comprehensive R package. This package handles various aspects of the project seamlessly:\n\nAutomated Data Management: The R package takes care of organizing and saving data in a predefined directory structure, ensuring a systematic and orderly approach.\nMeta Information Generation: It automatically generates meta-information based on the structure of the data, providing vital context and documentation for our analyses.\nAnalytic Function Application: Analytic functions are applied automatically to specified data subsets, streamlining the analytical process and enhancing the reproducibility of our results.\n\nFor those interested in exploring or contributing to our work, the GitHub repository containing the implementations can be accessed here. This centralized repository serves as a collaborative hub, inviting further development and utilization of our LiDAR forest analysis package (Danel and Bruch 2024). For further investigation you can find the package Documentation here: Section 6.5"
  },
  {
    "objectID": "report.html#sec-documentation",
    "href": "report.html#sec-documentation",
    "title": "Evaluating Tree Species Diversity in Forest Ecosystems Using LiDAR Data: A Exploration in NRW",
    "section": "6.5 Documentation",
    "text": "6.5 Documentation\n\n6.5.1 lfa_calculate_patch_density\nCalculate patch density for specified areas based on detection data\n\nArguments\n\n\n\n\n\n\n\nArgument\nDescription\n\n\n\n\nareas_location\nThe file path to a shapefile containing spatial polygons representing the areas for which patch density needs to be calculated. Default is “research_areas.shp”.\n\n\ndetections\nA data frame containing detection information, where each row represents a detection and includes the ‘area’ column specifying the corresponding area. Default is obtained using lfa_get_detections().\n\n\n\n\n\nDescription\nThis function calculates patch density for specified areas using detection data. It reads the spatial polygons from a shapefile, computes the area size for each patch, counts the number of detections in each patch, and calculates the patch density.\n\n\nValue\nA data frame with patch density information for each specified area. Columns include ‘name’ (area name), ‘geometry’ (polygon geometry), ‘area_size’ (patch area size), ‘detections’ (number of detections in the patch), and ‘density’ (computed patch density).\n\n\nExamples\n\n# Assuming you have a shapefile 'your_research_areas.shp' and detection data\n# from lfa_get_detections()\ndensity_data &lt;- lfa_calculate_patch_density(areas_location = \"your_research_areas.shp\")\nprint(density_data)\n\n\n\nUsage\n\nlfa_calculate_patch_density(\n  areas_location = \"research_areas.shp\",\n  detections = lfa::lfa_get_detections()\n)\n\n\n\n\n6.5.2 lfa_calculate_rf_metrics\nCalculate Precision and Recall Metrics for Random Forest Classification\n\nArguments\n\n\n\n\n\n\n\nArgument\nDescription\n\n\n\n\nconf_matrix\nConfusion matrix obtained from a Random Forest classification.\n\n\n\n\n\nDescription\nThis function calculates precision and recall metrics for each class based on the provided confusion matrix from a Random Forest classification.\n\n\nDetails\nThe function calculates precision and recall metrics for each class based on the confusion matrix obtained from a Random Forest classification.\n\n\nSeealso\nlfa_precision_per_class , lfa_recall_per_class\n\n\nValue\nA data frame containing precision and recall metrics for each class.\n\n\nExamples\n\n# Example confusion matrix from a Random Forest classification\nrf_cm &lt;- table(predicted = c(\"A\", \"B\", \"A\", \"B\"), actual = c(\"A\", \"A\", \"B\", \"B\"))\n# Calculate precision and recall metrics\nrf_metrics_df &lt;- lfa_calculate_rf_metrics(rf_cm)\n\n\n\nUsage\n\nlfa_calculate_rf_metrics(conf_matrix)\n\n\n\n\n6.5.3 lfa_capitalize_first_char\nCapitalize First Character of a String\n\nArguments\n\n\n\nArgument\nDescription\n\n\n\n\ninput_string\nA single-character string to be processed.\n\n\n\n\n\nConcept\nString Manipulation\n\n\nDescription\nThis function takes a string as input and returns the same string with the first character capitalized. If the first character is already capitalized, the function does nothing. If the first character is not from the alphabet, an error is thrown.\n\n\nDetails\nThis function performs the following steps:\n\nChecks if the input is a single-character string.\nVerifies if the first character is from the alphabet (A-Z or a-z).\nIf the first character is not already capitalized, it capitalizes it.\nReturns the modified string.\n\n\n\nKeyword\nalphabet\n\n\nNote\nThis function is case-sensitive and assumes ASCII characters.\n\n\nReferences\nNone\n\n\nSeealso\nThis function is related to the basic string manipulation functions in base R.\n\n\nValue\nA modified string with the first character capitalized if it is not already. If the first character is already capitalized, the original string is returned.\n\n\nExamples\n\n# Capitalize the first character of a string\ncapitalize_first_char(\"hello\") # Returns \"Hello\"\ncapitalize_first_char(\"World\") # Returns \"World\"\n\n# Error example (non-alphabetic first character)\ncapitalize_first_char(\"123abc\") # Throws an error\n\n\n\nUsage\n\nlfa_capitalize_first_char(input_string)\n\n\n\n\n6.5.4 lfa_check_flag\nCheck if a flag is set, indicating the completion of a specific process.\n\nArguments\n\n\n\n\n\n\n\nArgument\nDescription\n\n\n\n\nflag_name\nA character string specifying the name of the flag file. It should be a descriptive and unique identifier for the process being checked.\n\n\n\n\n\nDescription\nThis function checks for the existence of a hidden flag file at a specified location within the working directory. If the flag file is found, a message is printed, and the function returns TRUE to indicate that the associated processing step has already been completed. If the flag file is not found, the function returns FALSE , indicating that further processing can proceed.\n\n\nValue\nA logical value indicating whether the flag is set ( TRUE ) or not ( FALSE ).\n\n\nExamples\n\n# Check if the flag for a process named \"data_processing\" is set\nlfa_check_flag(\"data_processing\")\n\n\n\nUsage\n\nlfa_check_flag(flag_name)\n\n\n\n\n6.5.5 lfa_chm\nCreate Canopy Height Model (CHM) from Lidar Data\n\nArguments\n\n\n\n\n\n\n\nArgument\nDescription\n\n\n\n\nspecie\nCharacter string indicating the species name.\n\n\narea\nCharacter string indicating the specific area or location.\n\n\nres\nNumeric value indicating the spatial resolution of the CHM. Default is 0.5.\n\n\nsave_to_file\nLogical. If TRUE, the generated CHM will be saved to a GeoTIFF file. Default is TRUE.\n\n\noverwrite\nLogical. If TRUE, existing CHM file will be overwritten. Default is FALSE.\n\n\n...\nAdditional arguments to be passed to the underlying functions, such as lidR::catalog_map.\n\n\n\n\n\nDescription\nThis function generates a Canopy Height Model (CHM) from Lidar data using the lidR package.\n\n\nDetails\nThe behavior of the function with different input parameters is as follows:\n\nWhen a CHM file already exists at the specified path and overwrite is FALSE, the function loads the existing CHM and returns it.\nIf the CHM file does not exist or overwrite is TRUE, the function processes Lidar data using lfa_rasterize_chunk and creates a CHM.\nThe spatial resolution of the CHM can be controlled with the res parameter.\nIf save_to_file is TRUE, the generated CHM will be saved to a GeoTIFF file.\n\n\n\nSeealso\nlfa_read_area_as_catalog , catalog_map , terra::rast , terra::writeRaster\n\n\nValue\nA raster layer representing the Canopy Height Model (CHM).\n\n\nExamples\n\n# Generate CHM for a specific species and area\nchm &lt;- lfa_chm(specie = \"ExampleSpecies\", area = \"ExampleArea\", res = 1.0)\n\n# Generate CHM and save it to a file\nchm &lt;- lfa_chm(specie = \"ExampleSpecies\", area = \"ExampleArea\", res = 1.0, save_to_file = TRUE)\n\n\n\nUsage\n\nlfa_chm(specie, area, res = 0.5, save_to_file = TRUE, overwrite = FALSE, ...)\n\n\n\n\n6.5.6 lfa_combine_sf_obj\nCombine Spatial Feature Objects from Multiple GeoPackage Files\n\nArguments\n\n\n\n\n\n\n\nArgument\nDescription\n\n\n\n\npaths\nA character vector containing file paths to GeoPackage files with neighbor information.\n\n\narea_infos\nA data frame or list containing information about the corresponding detection areas, including “area” and “specie” columns.\n\n\n\n\n\nDescription\nThis function reads spatial feature objects (sf) from multiple GeoPackage files and combines them into a single sf object. Each GeoPackage file is assumed to contain neighbor information for a specific detection area, and the resulting sf object includes additional columns indicating the corresponding area and species information.\n\n\nValue\nA combined sf object with additional columns for area and specie information.\n\n\nExamples\n\n# Assuming paths and area_infos are defined\ncombined_sf &lt;- lfa_combine_sf_obj(paths, area_infos)\n\n# Print the combined sf object\nprint(combined_sf)\n\n\n\nUsage\n\nlfa_combine_sf_obj(paths, area_infos)\n\n\n\n\n6.5.7 lfa_count_returns_all_areas\nCount tree returns for all species and areas, returning a consolidated data frame.\n\nDescription\nThis function iterates through all species and areas obtained from the function lfa_get_all_areas . For each combination of species and area, it reads the corresponding area as a catalog, counts the returns per tree using lfa_count_returns_per_tree , and consolidates the results into a data frame. The resulting data frame includes columns for the species, area, and return counts per tree.\n\n\nKeyword\ncounting\n\n\nSeealso\nlfa_get_all_areas , lfa_read_area_as_catalog , lfa_count_returns_per_tree\n\n\nValue\nA data frame with columns for species, area, and return counts per tree.\n\n\nExamples\n\n# Count tree returns for all species and areas\nreturns_counts &lt;- lfa_count_returns_all_areas()\n\n\n\nUsage\n\nlfa_count_returns_all_areas()\n\n\n\n\n6.5.8 lfa_count_returns_per_tree\nCount returns per tree for a given lidR catalog.\n\nArguments\n\n\n\n\n\n\n\nArgument\nDescription\n\n\n\n\nctg\nA lidR catalog object containing LAS files to be processed.\n\n\n\n\n\nDescription\nThis function takes a lidR catalog as input and counts the returns per tree. It uses the lidR package to read LAS files from the catalog and performs the counting operation on each tree. The result is a data frame containing the counts of returns for each unique tree ID within the lidR catalog.\n\n\nKeyword\ncounting\n\n\nSeealso\nlidR::readLAS , lidR::is.empty , base::table , dplyr::bind_rows\n\n\nValue\nA data frame with columns for tree ID and the corresponding count of returns.\n\n\nExamples\n\n# Count returns per tree for a lidR catalog\nctg &lt;- lfa_read_area_as_catalog(\"SpeciesA\", \"Area1\")\nreturns_counts_per_tree &lt;- lfa_count_returns_per_tree(ctg)\n\n\n\nUsage\n\nlfa_count_returns_per_tree(ctg)\n\n\n\n\n6.5.9 lfa_create_boxplot\nCreate a box plot from a data frame\n\nArguments\n\n\n\n\n\n\n\nArgument\nDescription\n\n\n\n\ndata\nA data frame containing the data.\n\n\nvalue_column\nThe name of the column containing the values for the box plot.\n\n\ncategory_column1\nThe name of the column containing the first categorical variable.\n\n\ncategory_column2\nThe name of the column containing the second categorical variable.\n\n\ntitle\nAn optional title for the plot. If not provided, a default title is generated based on the data frame name.\n\n\n\n\n\nDescription\nThis function generates a box plot using ggplot2 based on the specified data frame and columns.\n\n\nDetails\nThe function creates a box plot where the x-axis is based on the second categorical variable, the y-axis is based on the specified value column, and the box plots are colored based on the first categorical variable. The grouping of box plots is done based on the unique values in the second categorical variable.\n\n\nValue\nA ggplot object representing the box plot.\n\n\nExamples\n\n# Assuming you have a data frame 'your_data' with columns 'value', 'category1', and 'category2'\ncreate_boxplot(your_data, \"value\", \"category1\", \"category2\")\n\n\n\nUsage\n\nlfa_create_boxplot(\n  data,\n  value_column,\n  category_column1,\n  category_column2,\n  title = NULL\n)\n\n\n\n\n6.5.10 lfa_create_density_plots\nCreate density plots for groups in a data frame\n\nArguments\n\n\n\n\n\n\n\nArgument\nDescription\n\n\n\n\ndata\nA data frame containing the data.\n\n\nvalue_column\nThe name of the column containing the values for the density plot.\n\n\ncategory_column1\nThe name of the column containing the categorical variable for grouping.\n\n\ncategory_column2\nThe name of the column containing the categorical variable for arranging plots.\n\n\ntitle\nAn optional title for the plot. If not provided, a default title is generated based on the data frame name.\n\n\nxlims\nOptional limits for the x-axis. Should be a numeric vector with two elements (lower and upper bounds).\n\n\nylims\nOptional limits for the y-axis. Should be a numeric vector with two elements (lower and upper bounds).\n\n\n\n\n\nDescription\nThis function generates density plots using ggplot2 based on the specified data frame and columns.\n\n\nDetails\nThe function creates density plots where the x-axis is based on the specified value column, and the density plots are colored based on the first categorical variable. The arrangement of plots is done based on the unique values in the second categorical variable. The plots are arranged in a 2x2 grid.\n\n\nValue\nA ggplot object representing the density plots arranged in a 2x2 grid.\n\n\nExamples\n\n# Assuming you have a data frame 'your_data' with columns 'value', 'category1', and 'category2'\ncreate_density_plots(your_data, \"value\", \"category1\", \"category2\", title = \"Density Plots\", xlims = c(0, 10), ylims = c(0, 0.5))\n\n\n\nUsage\n\nlfa_create_density_plots(\n  data,\n  value_column,\n  category_column1 = \"area\",\n  category_column2 = \"specie\",\n  title = NULL,\n  xlims = NULL,\n  ylims = NULL\n)\n\n\n\n\n6.5.11 lfa_create_grouped_bar_plot\nCreate a barplot using ggplot2\n\nArguments\n\n\n\n\n\n\n\nArgument\nDescription\n\n\n\n\nxlab\nLabel for x-Axis.\n\n\nylab\nLabel for y-Axis.\n\n\ntitle\nTitle of the plot.\n\n\ndf\nA data frame containing the relevant columns for the barplot.\n\n\nvalue_column\nThe column containing the values to be plotted.\n\n\nlabel_column\nThe column used for labeling the bars on the x-axis. Default is “name”.\n\n\ngrouping_column\nThe column used for grouping the bars. Default is “species”.\n\n\n\n\n\nDescription\nThis function generates a barplot using ggplot2 based on the specified data frame columns. The barplot displays the values from the specified column, grouped by another column. The grouping can be further differentiated by color if desired.\n\n\nValue\nA ggplot2 barplot.\n\n\nExamples\n\n# Assuming you have a data frame 'your_data_frame' with columns \"name\", \"species\", and \"value\"\nlfa_create_barplot(your_data_frame, value_column = \"value\", label_column = \"name\", grouping_column = \"species\")\n\n\n\nUsage\n\nlfa_create_grouped_bar_plot(\n  data,\n  grouping_var,\n  value_col,\n  label_col,\n  xlab = \"Name of Patch\",\n  ylab = \"Density\",\n  title = \"Tree density across the different patches, grouped by specie\"\n)\n\n\n\n\n6.5.12 lfa_create_neighbor_mean_curves\nCreate neighbor mean curves for specified areas\n\nArguments\n\n\n\n\n\n\n\nArgument\nDescription\n\n\n\n\nneighbors\nA data frame containing information about neighbors, where each column represents a specific neighbor, and each row corresponds to an area.\n\n\nuse_avg\nLogical. If TRUE, the function computes average curves across all neighbors. If FALSE, it computes curves for individual neighbors.\n\n\n\n\n\nDescription\nThis function generates mean curves for a specified set of areas based on neighbor data. The user can choose to compute mean curves for individual neighbors or averages across neighbors.\n\n\nValue\nA data frame with mean curves for each specified area. Columns represent areas, and rows represent index values.\n\n\nExamples\n\n# Assuming you have a data frame 'your_neighbors_data' with neighbor information\nmean_curves &lt;- lfa_create_neighbor_mean_curves(your_neighbors_data, use_avg = TRUE)\nprint(mean_curves)\n\n\n\nUsage\n\nlfa_create_neighbor_mean_curves(neighbors, use_avg = FALSE)\n\n\n\n\n6.5.13 lfa_create_plot_per_area\nCreate a line plot per area with one color per specie\n\nArguments\n\n\n\n\n\n\n\nArgument\nDescription\n\n\n\n\ndata\nA data frame with numeric columns and a column named ‘specie’ for species information.\n\n\n\n\n\nDescription\nThis function takes a data frame containing numeric columns and creates a line plot using ggplot2. Each line in the plot represents a different area, with one color per specie.\n\n\nValue\nA ggplot2 line plot.\n\n\nExamples\n\ndata &lt;- data.frame(\nspecie = rep(c(\"Species1\", \"Species2\", \"Species3\"), each = 10),\ncolumn1 = rnorm(30),\ncolumn2 = rnorm(30),\ncolumn3 = rnorm(30)\n)\nlfa_create_plot_per_area(data)\n\n\n\nUsage\n\nlfa_create_plot_per_area(data)\n\n\n\n\n6.5.14 lfa_create_ppp_from_area\nCreate a point pattern from tree detections in a specified area for a given species.\n\nArguments\n\n\n\n\n\n\n\nArgument\nDescription\n\n\n\n\nspecies_identifier\nA character string specifying the target species for which the point pattern is to be generated.\n\n\narea_identifier\nA character string specifying the target area for which the point pattern is to be generated.\n\n\n\n\n\nDescription\nThis function generates a point pattern from tree detections for a specific species within a defined area. It filters the detections using the provided species_identifier and area_identifier parameters. The area is defined by a shapefile named “research_areas.shp,” and the resulting point pattern is created within the specified area.\n\n\nKeyword\ndata\n\n\nSeealso\nlfa_get_detections , sf::st_transform , sf::st_union , spatstat.geom::as.owin , spatstat.geom::as.ppp\n\n\nValue\nA point pattern representing tree detections for the specified species within the defined area.\n\n\nExamples\n\nlfa_create_ppp_from_area(species_identifier = \"SpeciesA\", area_identifier = \"Area1\")\n\n# Create a point pattern for a specific species in a given area\npp &lt;- lfa_create_ppp_from_area(species_identifier = \"SpeciesA\", area_identifier = \"Area1\")\n\n\n\nUsage\n\nlfa_create_ppp_from_area(species_identifier, area_identifier)\n\n\n\n\n6.5.15 lfa_create_stacked_distributions_plot\nCreate a stacked distribution plot for tree detections, visualizing the distribution of a specified variable on the x-axis, differentiated by another variable.\n\nArguments\n\n\n\n\n\n\n\nArgument\nDescription\n\n\n\n\ntrees\nA data frame containing tree detection data.\n\n\nx_value\nA character string specifying the column name used for finding the values on the x-axis of the histogram.\n\n\nfill_value\nA character string specifying the column name by which the data are differentiated in the plot.\n\n\nbin\nAn integer specifying the number of bins for the histogram. Default is 100.\n\n\nylab\nA character string specifying the y-axis label. Default is “Amount trees.”\n\n\nxlim\nA numeric vector of length 2 specifying the x-axis limits. Default is c(0, 100).\n\n\nylim\nA numeric vector of length 2 specifying the y-axis limits. Default is c(0, 1000).\n\n\ntitle\nThe title of the plot.\n\n\n\n\n\nDescription\nThis function generates a stacked distribution plot using the ggplot2 package, providing a visual representation of the distribution of a specified variable ( x_value ) on the x-axis, with differentiation based on another variable ( fill_value ). The data for the plot are derived from the provided trees data frame.\n\n\nKeyword\ndata\n\n\nSeealso\nggplot2::geom_histogram , ggplot2::facet_wrap , ggplot2::ylab , ggplot2::scale_fill_brewer , ggplot2::coord_cartesian\n\n\nValue\nA ggplot object representing the stacked distribution plot.\n\n\nExamples\n\n# Create a stacked distribution plot for variable \"Z,\" differentiated by \"area\"\ntrees &lt;- lfa_get_detections()\nlfa_create_stacked_distributions_plot(trees, \"Z\", \"area\")\n\n\n\nUsage\n\nlfa_create_stacked_distributions_plot(\n  trees,\n  x_value,\n  fill_value,\n  bin = 100,\n  ylab = \"Amount trees\",\n  xlim = c(0, 100),\n  ylim = c(0, 1000),\n  title =\n    \"Histograms of height distributions between species 'beech', 'oak', 'pine' and 'spruce' divided by the different areas of Interest\"\n)\n\n\n\n\n6.5.16 lfa_create_stacked_histogram\nCreate a stacked histogram for tree detections, summing up the values for each species.\n\nArguments\n\n\n\n\n\n\n\nArgument\nDescription\n\n\n\n\ntrees\nA data frame containing tree detection data.\n\n\nx_value\nA character string specifying the column name used for finding the values on the x-axis of the histogram.\n\n\nfill_value\nA character string specifying the column name by which the data are differentiated in the plot.\n\n\nbin\nAn integer specifying the number of bins for the histogram. Default is 30.\n\n\nylab\nA character string specifying the y-axis label. Default is “Frequency.”\n\n\nxlim\nA numeric vector of length 2 specifying the x-axis limits. Default is c(0, 100).\n\n\nylim\nA numeric vector of length 2 specifying the y-axis limits. Default is NULL.\n\n\n\n\n\nDescription\nThis function generates a stacked histogram using the ggplot2 package, summing up the values for each species and visualizing the distribution of a specified variable ( x_value ) on the x-axis, differentiated by another variable ( fill_value ). The data for the plot are derived from the provided trees data frame.\n\n\nKeyword\ndata\n\n\nSeealso\nggplot2::geom_histogram , ggplot2::ylab , ggplot2::scale_fill_brewer , ggplot2::coord_cartesian\n\n\nValue\nA ggplot object representing the stacked histogram.\n\n\nExamples\n\n# Create a stacked histogram for variable \"Z,\" differentiated by \"area\"\ntrees &lt;- lfa_get_detections()\nlfa_create_stacked_histogram(trees, \"Z\", \"area\")\n\n\n\nUsage\n\nlfa_create_stacked_histogram(\n  trees,\n  x_value,\n  fill_value,\n  bin = 30,\n  ylab = \"Frequency\",\n  xlim = c(0, 100),\n  ylim = NULL\n)\n\n\n\n\n6.5.17 lfa_create_tile_location_objects\nCreate tile location objects\n\nAuthor\nJakob Danel\n\n\nDescription\nThis function traverses a directory structure to find LAZ files and creates tile location objects for each file. The function looks into the the data directory of the repository/working directory. It then creates tile_location objects based on the folder structure. The folder structure should not be touched by hand, but created by lfa_init_data_structure() which builds the structure based on a shape file.\n\n\nSeealso\ntile_location\n\n\nValue\nA vector containing tile location objects.\n\n\nExamples\n\nlfa_create_tile_location_objects()\n\nlfa_create_tile_location_objects()\n\n\n\nUsage\n\nlfa_create_tile_location_objects()\n\n\n\n\n6.5.18 lfa_detection\nPerform tree detection on a lidar catalog and optionally save the results to a file.\n\nArguments\n\n\n\n\n\n\n\nArgument\nDescription\n\n\n\n\ncatalog\nA lidar catalog containing point cloud data. If set to NULL, the function attempts to read the catalog from the specified tile location.\n\n\ntile_location\nAn object specifying the location of the lidar tile. If catalog is NULL, the function attempts to read the catalog from this tile location.\n\n\nwrite_to_file\nA logical value indicating whether to save the detected tree information to a file. Default is TRUE.\n\n\n\n\n\nDescription\nThis function utilizes lidar data to detect trees within a specified catalog. The detected tree information can be optionally saved to a file in the GeoPackage format. The function uses parallel processing to enhance efficiency.\n\n\nValue\nA sf style data frame containing information about the detected trees.\n\n\nExamples\n\n# Perform tree detection on a catalog and save the results to a file\nlfa_detection(catalog = my_catalog, tile_location = my_tile_location, write_to_file = TRUE)\n\n\n\nUsage\n\nlfa_detection(catalog, tile_location, write_to_file = TRUE)\n\n\n\n\n6.5.19 lfa_download_areas\nDownload areas based on spatial features\n\nArguments\n\n\n\n\n\n\n\nArgument\nDescription\n\n\n\n\nsf_areas\nSpatial features representing areas to be downloaded. It must include columns like “species” “name” See details for more information.\n\n\n\n\n\nAuthor\nJakob Danel\n\n\nDescription\nThis function initiates the data structure and downloads areas based on spatial features.\n\n\nDetails\nThe input data frame, sf_areas , must have the following columns:\n\n“species”: The species associated with the area.\n“name”: The name of the area.\n\nThe function uses the lfa_init_data_structure function to set up the data structure and then iterates through the rows of sf_areas to download each specified area.\n\n\nValue\nNone\n\n\nExamples\n\nlfa_download_areas(sf_areas)\n\n\n# Example spatial features data frame\nsf_areas &lt;- data.frame(\nspecies = c(\"SpeciesA\", \"SpeciesB\"),\nname = c(\"Area1\", \"Area2\"),\n# Must include also other attributes specialized to sf objects\n# such as geometry, for processing of the download\n)\n\nlfa_download_areas(sf_areas)\n\n\n\nUsage\n\nlfa_download_areas(sf_areas)\n\n\n\n\n6.5.20 lfa_download\nDownload an las file from the state NRW from a specific location\n\nArguments\n\n\n\n\n\n\n\nArgument\nDescription\n\n\n\n\nspecies\nThe species of the tree which is observed at this location\n\n\nname\nThe name of the area that is observed\n\n\nlocation\nAn sf object, which holds the location information for the area where the tile should be downloaded from.\n\n\n\n\n\nDescription\nIt will download the file and save it to data/ list(list(“html”), list(list(“”))) / list(list(“html”), list(list(“”))) with the name of the tile\n\n\nValue\nThe LASCatalog object of the downloaded file\n\n\nUsage\n\nlfa_download(species, name, location)\n\n\n\n\n6.5.21 lfa_find_n_nearest_trees\nFind n Nearest Trees\n\nArguments\n\n\n\n\n\n\n\nArgument\nDescription\n\n\n\n\ntrees\nA sf object containing tree coordinates.\n\n\nn\nThe number of nearest trees to find for each tree (default is 100).\n\n\n\n\n\nDescription\nThis function calculates the distances to the n nearest trees for each tree in the input dataset.\n\n\nValue\nA data frame with additional columns representing the distances to the n nearest trees.\n\n\nExamples\n\n# Load tree data using lfa_get_detections() (not provided)\ntree_data &lt;- lfa_get_detections()\n\n# Filter tree data for a specific species and area\ntree_data = tree_data[tree_data$specie == \"pine\" & tree_data$area == \"greffen\", ]\n\n# Find the 100 nearest trees for each tree in the filtered dataset\ntree_data &lt;- lfa_find_n_nearest_trees(tree_data)\n\n\n\nUsage\n\nlfa_find_n_nearest_trees(trees, n = 100)\n\n\n\n\n6.5.22 lfa_generate_result_table_tests\nGenerate Result Table for Tests\n\nArguments\n\n\n\nArgument\nDescription\n\n\n\n\ntable\nA data frame representing the result table.\n\n\n\n\n\nDescription\nThis function generates a result table for tests using the knitr::kable function.\n\n\nDetails\nThis function uses the knitr::kable function to create a formatted table, making it suitable for HTML output. The input table is expected to be a data frame with test results, and the resulting table will have capitalized row and column names with lines between columns and rows.\n\n\nValue\nA formatted table suitable for HTML output with lines between columns and rows.\n\n\nExamples\n\n# Generate a result table for tests\nresult_table &lt;- data.frame(\nTest1 = c(0.05, 0.10, 0.03),\nTest2 = c(0.02, 0.08, 0.01),\nTest3 = c(0.08, 0.12, 0.05)\n)\nformatted_table &lt;- lfa_generate_result_table_tests(result_table)\nprint(formatted_table)\n\n\n\nUsage\n\nlfa_generate_result_table_tests(table, caption = \"Table Caption\")\n\n\n\n\n6.5.23 lfa_get_all_areas\nRetrieve a data frame containing all species and corresponding areas.\n\nDescription\nThis function scans the “data” directory within the current working directory to obtain a list of species. It then iterates through each species to retrieve the list of areas associated with that species. The resulting data frame contains two columns: “specie” representing the species and “area” representing the corresponding area.\n\n\nKeyword\ndata\n\n\nSeealso\nlist.dirs\n\n\nValue\nA data frame with columns “specie” and “area” containing information about all species and their associated areas.\n\n\nExamples\n\n# Retrieve a data frame with information about all species and areas\nall_areas_df &lt;- lfa_get_all_areas()\n\n\n\nUsage\n\nlfa_get_all_areas()\n\n\n\n\n6.5.24 lfa_get_detection_area\nGet Detection for an area\n\nArguments\n\n\n\nArgument\nDescription\n\n\n\n\nspecies\nA character string specifying the target species.\n\n\nname\nA character string specifying the name of the tile.\n\n\n\n\n\nDescription\nRetrieves the tree detection information for a specified species and tile.\n\n\nDetails\nThis function reads tree detection data from geopackage files within the specified tile location for a given species. It then combines the data into a single SF data frame and returns it. The function assumes that the tree detection files follow a naming convention with the pattern “_detection.gpkg”.\n\n\nKeyword\nspatial\n\n\nReferences\nThis function is part of the LiDAR Forest Analysis (LFA) package.\n\n\nSeealso\nget_tile_dir\n\n\nValue\nA Simple Features (SF) data frame containing tree detection information for the specified species and tile.\n\n\nExamples\n\n# Retrieve tree detection data for species \"example_species\" in tile \"example_tile\"\ntrees_data &lt;- lfa_get_detection_tile_location(\"example_species\", \"example_tile\")\n\n# Example usage:\ntrees_data &lt;- lfa_get_detection_tile_location(\"example_species\", \"example_tile\")\n\n# No trees found scenario:\nempty_data &lt;- lfa_get_detection_tile_location(\"nonexistent_species\", \"nonexistent_tile\")\n# The result will be an empty data frame if no trees are found for the specified species and tile.\n\n# Error handling:\n# In case of invalid inputs, the function may throw errors. Ensure correct species and tile names are provided.\n\n\n\nUsage\n\nlfa_get_detection_area(species, name)\n\n\n\n\n6.5.25 lfa_get_detections_species\nRetrieve detections for a specific species.\n\nArguments\n\n\n\nArgument\nDescription\n\n\n\n\nspecies\nA character string specifying the target species.\n\n\n\n\n\nDescription\nThis function retrieves detection data for a given species from multiple areas.\n\n\nDetails\nThe function looks for detection data in the “data” directory for the specified species. It then iterates through each subdirectory (representing different areas) and consolidates the detection data into a single data frame.\n\n\nValue\nA data frame containing detection information for the specified species in different areas.\n\n\nExamples\n\n# Example usage:\ndetections_data &lt;- lfa_get_detections_species(\"example_species\")\n\n\n\nUsage\n\nlfa_get_detections_species(species)\n\n\n\n\n6.5.26 lfa_get_detections\nRetrieve aggregated detection data for multiple species.\n\nConcept\ndata retrieval functions\n\n\nDescription\nThis function obtains aggregated detection data for multiple species by iterating through the list of species obtained from lfa_get_species . For each species, it calls lfa_get_detections_species to retrieve the corresponding detection data and aggregates the results into a single data frame. The resulting data frame includes columns for the species, tree detection data, and the area in which the detections occurred.\n\n\nKeyword\naggregation\n\n\nSeealso\nlfa_get_species , lfa_get_detections_species\nOther data retrieval functions: lfa_get_species\n\n\nValue\nA data frame containing aggregated detection data for multiple species.\n\n\nExamples\n\nlfa_get_detections()\n\n# Retrieve aggregated detection data for multiple species\ndetections_data &lt;- lfa_get_detections()\n\n\n\nUsage\n\nlfa_get_detections()\n\n\n\n\n6.5.27 lfa_get_flag_path\nGet the path to a flag file indicating the completion of a specific process.\n\nArguments\n\n\n\n\n\n\n\nArgument\nDescription\n\n\n\n\nflag_name\nA character string specifying the name of the flag file. It should be a descriptive and unique identifier for the process being flagged.\n\n\n\n\n\nDescription\nThis function constructs and returns the path to a hidden flag file, which serves as an indicator that a particular processing step has been completed. The flag file is created in a designated location within the working directory.\n\n\nValue\nA character string representing the absolute path to the hidden flag file.\n\n\nExamples\n\n# Get the flag path for a process named \"data_processing\"\nlfa_get_flag_path(\"data_processing\")\n\n\n\nUsage\n\nlfa_get_flag_path(flag_name)\n\n\n\n\n6.5.28 lfa_get_neighbor_paths\nGet Paths to Neighbor GeoPackage Files\n\nDescription\nThis function retrieves the file paths to GeoPackage files containing neighbor information for each detection area. The GeoPackage files are assumed to be named “neighbours.gpkg” and organized in a directory structure under the “data” folder.\n\n\nValue\nA character vector containing file paths to GeoPackage files for each detection area’s neighbors.\n\n\nExamples\n\n# Get paths to neighbor GeoPackage files for all areas\npaths &lt;- lfa_get_neighbor_paths()\n\n# Print the obtained file paths\nprint(paths)\n\n\n\nUsage\n\nlfa_get_neighbor_paths()\n\n\n\n\n6.5.29 lfa_get_species\nGet a list of species from the data directory.\n\nConcept\ndata retrieval functions\n\n\nDescription\nThis function retrieves a list of species by scanning the “data” directory located in the current working directory.\n\n\nKeyword\ndata\n\n\nReferences\nThis function relies on the list.dirs function for directory listing.\n\n\nSeealso\nlist.dirs\nOther data retrieval functions: lfa_get_detections\n\n\nValue\nA character vector containing the names of species found in the “data” directory.\n\n\nExamples\n\n# Retrieve the list of species\nspecies_list &lt;- lfa_get_species()\n\n\n\nUsage\n\nlfa_get_species()\n\n\n\n\n6.5.30 lfa_ground_correction\nCorrect the point clouds for correct ground imagery\n\nArguments\n\n\n\n\n\n\n\nArgument\nDescription\n\n\n\n\nctg\nAn LASCatalog object. If not null, it will perform the actions on this object, if NULL inferring the catalog from the tile_location\n\n\ntile_location\nA tile_location type object holding the information about the location of the cataog. This is used to save the catalog after processing too.\n\n\n\n\n\nAuthor\nJakob Danel\n\n\nDescription\nThis function is needed to correct the Z value of the point cloud, relative to the real ground height. After using this function to your catalog, the Z values can be seen as the real elevation about the ground. At the moment the function uses the tin() function from the lidr package. NOTE : The operation is inplace and can not be reverted, the old values of the point cloud will be deleted!\n\n\nValue\nA catalog with the corrected z values. The catalog is always stored at tile_location and holding only the transformed values.\n\n\nUsage\n\nlfa_ground_correction(ctg, tile_location)\n\n\n\n\n6.5.31 lfa_init_data_structure\nInitialize data structure for species and areas\n\nArguments\n\n\n\n\n\n\n\nArgument\nDescription\n\n\n\n\nsf_species\nA data frame with information about species and associated areas.\n\n\n\n\n\nDescription\nThis function initializes the data structure for storing species and associated areas.\n\n\nDetails\nThe input data frame, sf_species , should have at least the following columns:\n\n“species”: The names of the species for which the data structure needs to be initialized.\n“name”: The names of the associated areas.\n\nThe function creates directories based on the species and area information provided in the sf_species data frame. It checks whether the directories already exist and creates them if they don’t.\n\n\nValue\nNone\n\n\nExamples\n\n# Example species data frame\nsf_species &lt;- data.frame(\nspecies = c(\"SpeciesA\", \"SpeciesB\"),\nname = c(\"Area1\", \"Area2\"),\n# Other necessary columns\n)\n\nlfa_init_data_structure(sf_species)\n\n# Example species data frame\nsf_species &lt;- data.frame(\nspecies = c(\"SpeciesA\", \"SpeciesB\"),\nname = c(\"Area1\", \"Area2\"),\n# Other necessary columns\n)\n\nlfa_init_data_structure(sf_species)\n\n\n\nUsage\n\nlfa_init_data_structure(sf_species)\n\n\n\n\n6.5.32 lfa_init\nInitialize LFA (LiDAR forest analysis) data processing\n\nArguments\n\n\n\n\n\n\n\nArgument\nDescription\n\n\n\n\nsf_file\nA character string specifying the path to the shapefile containing spatial features of research areas.\n\n\n\n\n\nDescription\nThis function initializes the LFA data processing by reading a shapefile containing spatial features of research areas, downloading the specified areas, and creating tile location objects for each area.\n\n\nDetails\nThis function reads a shapefile ( sf_file ) using the sf package, which should contain information about research areas. It then calls the lfa_download_areas function to download the specified areas and lfa_create_tile_location_objects to create tile location objects based on Lidar data files in those areas. The shapefile MUST follow the following requirements:\n\nEach geometry must be a single object of type polygon\nEach entry must have the following attributes:\nspecies: A string describing the tree species of the area.\nname: A string describing the location of the area.\n\n\n\nValue\nA vector containing tile location objects.\n\n\nExamples\n\n# Initialize LFA processing with the default shapefile\nlfa_init()\n\n# Initialize LFA processing with a custom shapefile\nlfa_init(\"custom_areas.shp\")\n\n# Example usage with the default shapefile\nlfa_init()\n\n# Example usage with a custom shapefile\nlfa_init(\"custom_areas.shp\")\n\n\n\nUsage\n\nlfa_init(sf_file = \"research_areas.shp\")\n\n\n\n\n6.5.33 lfa_intersect_areas\nIntersect Lidar Catalog with Spatial Features\n\nArguments\n\n\n\n\n\n\n\nArgument\nDescription\n\n\n\n\nctg\nA LAScatalog object representing the Lidar data to be processed.\n\n\ntile_location\nA tile location object representing the specific area of interest.\n\n\nareas_sf\nSpatial features defining areas.\n\n\n\n\n\nDescription\nThis function intersects a Lidar catalog with a specific area defined by spatial features.\n\n\nDetails\nThe function intersects the Lidar catalog specified by ctg with a specific area defined by the tile_location object and areas_sf . It removes points outside the specified area and returns a modified LAScatalog object.\nThe specified area is identified based on the species and name attributes in the tile_location object. If a matching area is not found in areas_sf , the function stops with an error.\nThe function then transforms the spatial reference of the identified area to match that of the Lidar catalog using sf::st_transform .\nThe processing is applied to each chunk in the catalog using the identify_area function, which merges spatial information and filters out points that are not classified as inside the identified area. After processing, the function writes the modified LAS files back to the original file locations, removing points outside the specified area.\nIf an error occurs during the processing of a chunk, a warning is issued, and the function continues processing the next chunks. If no points are found after filtering, a warning is issued, and NULL is returned.\n\n\nSeealso\nOther functions in the Lidar forest analysis (LFA) package.\n\n\nValue\nA modified LAScatalog object with points outside the specified area removed.\n\n\nExamples\n\n# Example usage\nlfa_intersect_areas(ctg, tile_location, areas_sf)\n\n# Example usage\nlfa_intersect_areas(ctg, tile_location, areas_sf)\n\n\n\nUsage\n\nlfa_intersect_areas(ctg, tile_location, areas_sf)\n\n\n\n\n6.5.34 lfa_jsd_from_vec\nCompute Jensen-Shannon Divergence from Vectors\n\nArguments\n\n\n\nArgument\nDescription\n\n\n\n\nx\nA numeric vector.\n\n\ny\nA numeric vector.\n\n\n\n\n\nDescription\nThis function calculates the Jensen-Shannon Divergence (JSD) between two vectors.\n\n\nValue\nJensen-Shannon Divergence between the density distributions of x and y.\n\n\nExamples\n\nx &lt;- rnorm(100)\ny &lt;- rnorm(100, mean = 2)\nlfa_jsd_from_vec(x, y)\n\n\n\nUsage\n\nlfa_jsd_from_vec(x, y)\n\n\n\n\n6.5.35 lfa_jsd\nJensen-Shannon Divergence Calculation\n\nArguments\n\n\n\n\n\n\n\nArgument\nDescription\n\n\n\n\np\nA numeric vector representing the probability distribution P.\n\n\nq\nA numeric vector representing the probability distribution Q.\n\n\nepsilon\nA small positive constant added to both P and Q to avoid logarithm of zero. Default is 1e-10.\n\n\n\n\n\nDescription\nThis function calculates the Jensen-Shannon Divergence (JSD) between two probability distributions P and Q.\n\n\nDetails\nThe JSD is computed using the Kullback-Leibler Divergence (KLD) as follows: sum((p * log((p + epsilon) / (m + epsilon)) + q * log((q + epsilon) / (m + epsilon))) / 2) where m = (p + q) / 2 .\n\n\nSeealso\nkld , sum , log\n\n\nValue\nA numeric value representing the Jensen-Shannon Divergence between P and Q.\n\n\nExamples\n\n# Calculate JSD between two probability distributions\np_distribution &lt;- c(0.2, 0.3, 0.5)\nq_distribution &lt;- c(0.1, 0, 0.9)\njsd_result &lt;- jsd(p_distribution, q_distribution)\nprint(jsd_result)\n\n\n\nUsage\n\nlfa_jsd(p, q, epsilon = 1e-10)\n\n\n\n\n6.5.36 lfa_kld_from_vec\nCompute Kullback-Leibler Divergence from Vectors\n\nArguments\n\n\n\nArgument\nDescription\n\n\n\n\nx\nA numeric vector.\n\n\ny\nA numeric vector.\n\n\n\n\n\nDescription\nThis function calculates the Kullback-Leibler Divergence (KLD) between two vectors.\n\n\nValue\nKullback-Leibler Divergence between the density distributions of x and y.\n\n\nExamples\n\nx &lt;- rnorm(100)\ny &lt;- rnorm(100, mean = 2)\nlfa_kld_from_vec(x, y)\n\n\n\nUsage\n\nlfa_kld_from_vec(x, y)\n\n\n\n\n6.5.37 lfa_kld\nKullback-Leibler Divergence Calculation\n\nArguments\n\n\n\n\n\n\n\nArgument\nDescription\n\n\n\n\np\nA numeric vector representing the probability distribution P.\n\n\nq\nA numeric vector representing the probability distribution Q.\n\n\nepsilon\nA small positive constant added to both P and Q to avoid logarithm of zero. Default is 1e-10.\n\n\n\n\n\nDescription\nThis function calculates the Kullback-Leibler Divergence (KLD) between two probability distributions P and Q.\n\n\nDetails\nThe KLD is computed using the formula: sum(p * log((p + epsilon) / (q + epsilon))) This avoids issues when the denominator (Q) contains zero probabilities.\n\n\nSeealso\nsum , log\n\n\nValue\nA numeric value representing the Kullback-Leibler Divergence between P and Q.\n\n\nExamples\n\n# Calculate KLD between two probability distributions\np_distribution &lt;- c(0.2, 0.3, 0.5)\nq_distribution &lt;- c(0.1, 0, 0.9)\nkld_result &lt;- kld(p_distribution, q_distribution)\nprint(kld_result)\n\n\n\nUsage\n\nlfa_kld(p, q, epsilon = 1e-10)\n\n\n\n\n6.5.38 lfa_ks_test\nKolmogorov-Smirnov Test Wrapper Function\n\nArguments\n\n\n\n\n\n\n\nArgument\nDescription\n\n\n\n\nx\nA numeric vector representing the first sample.\n\n\ny\nA numeric vector representing the second sample.\n\n\noutput_variable\nA character string specifying the output variable to extract from the ks.test result. Default is “p.value”. Other possible values include “statistic” and “alternative”.\n\n\n...\nAdditional arguments to be passed to the ks.test function.\n\n\n\n\n\nDescription\nThis function serves as a wrapper for the Kolmogorov-Smirnov (KS) test between two samples.\n\n\nDetails\nThe function uses the ks.test function to perform a two-sample KS test and returns the specified output variable. The default output variable is the p-value. Other possible output variables include “statistic” and “alternative”.\n\n\nSeealso\nks.test\n\n\nValue\nA numeric value representing the specified output variable from the KS test result.\n\n\nExamples\n\n# Perform KS test and extract the p-value\nresult &lt;- lfa_ks_test(sample1, sample2)\nprint(result)\n\n# Perform KS test and extract the test statistic\nresult_statistic &lt;- lfa_ks_test(sample1, sample2, output_variable = \"statistic\")\nprint(result_statistic)\n\n\n\nUsage\n\nlfa_ks_test(x, y, output_variable = \"p.value\", ...)\n\n\n\n\n6.5.39 lfa_load_ctg_if_not_present\nLoading the catalog if it is not present\n\nArguments\n\n\n\n\n\n\n\nArgument\nDescription\n\n\n\n\nctg\nCatalog object. Can be NULL\n\n\ntile_location\nThe location to look for the catalog tiles, if their are not present\n\n\n\n\n\nDescription\nThis function checks if the catalog is NULL . If it is it will load the catalog from the tile_location\n\n\nValue\nThe provided ctg object if not null, else the catalog for the tiles of the tile_location.\n\n\nUsage\n\nlfa_load_ctg_if_not_present(ctg, tile_location)\n\n\n\n\n6.5.40 lfa_map_tile_locations\nMap Function Over Tile Locations\n\nArguments\n\n\n\n\n\n\n\nArgument\nDescription\n\n\n\n\ntile_locations\nA list of tile location objects.\n\n\nmap_function\nThe mapping function to be applied to each tile location.\n\n\n...\nAdditional arguments to be passed to the mapping function.\n\n\n\n\n\nDescription\nThis function applies a specified mapping function to each tile location in a list.\n\n\nDetails\nThis function iterates over each tile location in the provided list ( tile_locations ) and applies the specified mapping function ( map_function ) to each tile location. The mapping function should accept a tile location object as its first argument, and additional arguments can be passed using the ellipsis ( ... ) syntax.\nThis function is useful for performing operations on multiple tile locations concurrently, such as loading Lidar data, processing areas, or other tasks that involve tile locations.\n\n\nSeealso\nThe mapping function provided should be compatible with the structure and requirements of the tile locations and the specific task being performed.\n\n\nValue\nNone\n\n\nExamples\n\n# Example usage\nlfa_map_tile_locations(tile_locations, my_mapping_function, param1 = \"value\")\n\n# Example usage\nlfa_map_tile_locations(tile_locations, my_mapping_function, param1 = \"value\")\n\n\n\nUsage\n\nlfa_map_tile_locations(tile_locations, map_function, check_flag = NULL, ...)\n\n\n\n\n6.5.41 lfa_merge_and_save\nMerge and Save Text Files in a Directory\n\nArguments\n\n\n\n\n\n\n\nArgument\nDescription\n\n\n\n\ninput_directory\nThe path to the input directory containing text files.\n\n\noutput_name\nThe name for the output file where the merged content will be saved.\n\n\n\n\n\nDescription\nThis function takes an input directory and an output name as arguments. It merges the textual content of all files in the specified directory into a single string, with each file’s content separated by a newline character. The merged content is then saved into a file named after the output name in the same directory. After the merging is complete, all input files are deleted.\n\n\nDetails\nThis function reads the content of each text file in the specified input directory and concatenates them into a single string. Each file’s content is separated by a newline character. The merged content is then saved into a file named after the output name in the same directory. Finally, all input files are deleted from the directory.\n\n\nSeealso\nreadLines , writeLines , file.remove\n\n\nValue\nThis function does not explicitly return any value. It prints a message indicating the successful completion of the merging and saving process.\n\n\nExamples\n\n# Merge text files in the \"data_files\" directory and save the result in \"merged_output\"\nlfa_merge_and_save(\"data_files\", \"merged_output\")\n\n# Merge text files in the \"data_files\" directory and save the result in \"merged_output\"\nlfa_merge_and_save(\"data_files\", \"merged_output\")\n\n\n\nUsage\n\nlfa_merge_and_save(input_directory, output_name)\n\n\n\n\n6.5.42 lfa_plot_confusion_matrix\nPlot Confusion Matrix\n\nArguments\n\n\n\n\n\n\n\nArgument\nDescription\n\n\n\n\nconf_matrix\nConfusion matrix, typically obtained from classification evaluation.\n\n\n\n\n\nDescription\nThis function generates a heatmap plot of a confusion matrix using ggplot2.\n\n\nDetails\nThe function takes a confusion matrix as input and generates a heatmap plot using ggplot2. The plot represents the relationship between the predicted and actual classes, with cell colors indicating the frequency of each combination. Additionally, the plot includes labels for accuracy and kappa statistics based on the confusion matrix.\n\n\nValue\nA ggplot object representing the confusion matrix heatmap plot.\n\n\nExamples\n\n# Example confusion matrix\ncm &lt;- table(predicted = c(\"A\", \"B\", \"A\", \"B\"), actual = c(\"A\", \"A\", \"B\", \"B\"))\n# Plot confusion matrix\nlfa_plot_confusion_matrix(cm)\n\n\n\nUsage\n\nlfa_plot_confusion_matrix(conf_matrix)\n\n\n\n\n6.5.43 lfa_precision_per_class\nCalculate Precision per Class from Confusion Matrix\n\nArguments\n\n\n\n\n\n\n\nArgument\nDescription\n\n\n\n\nconfusion_matrix\nConfusion matrix obtained from a classification evaluation.\n\n\n\n\n\nDescription\nThis function calculates precision for each class based on the provided confusion matrix.\n\n\nDetails\nPrecision is a measure of the accuracy of the positive predictions for a specific class. It is calculated as the ratio of true positives to the sum of true positives and false positives.\n\n\nSeealso\nlfa_recall_per_class , lfa_f1_score_per_class\n\n\nValue\nA numeric vector representing precision for each class.\n\n\nExamples\n\n# Example confusion matrix\ncm &lt;- table(predicted = c(\"A\", \"B\", \"A\", \"B\"), actual = c(\"A\", \"A\", \"B\", \"B\"))\n# Calculate precision per class\nprecision_vector &lt;- lfa_precision_per_class(cm)\n\n\n\nUsage\n\nlfa_precision_per_class(confusion_matrix)\n\n\n\n\n6.5.44 lfa_random_forest\nRandom Forest Classifier with Leave-One-Out Cross-Validation\n\nArguments\n\n\n\n\n\n\n\nArgument\nDescription\n\n\n\n\ntree_data\nA data frame containing the tree data, including the response variable (“specie”) and predictor variables.\n\n\nexcluded_input_columns\nA character vector specifying columns to be excluded from predictor variables.\n\n\nresponse_variable\nThe response variable to be predicted (default is “specie”).\n\n\nseed\nAn integer to set the seed for reproducibility (default is 123).\n\n\n...\nAdditional parameters to be passed to the randomForest function.\n\n\n\n\n\nDescription\nThis function performs a random forest classification using leave-one-out cross-validation for each area in the input tree data. It returns a list containing various results, including predicted species, confusion matrix, accuracy, and the formula used for modeling.\n\n\nValue\nA list containing the following elements:\n\npredicted_species_absolute : A data frame with observed and predicted species for each area.\npredicted_species_relative : A data frame wit the relative precictions per speices and areas, normalized by the total predictions in each area.\nconfusion_matrix : A confusion matrix showing the counts of predicted vs. observed species.\naccuracy : The accuracy of the model, calculated as the sum of diagonal elements in the confusion matrix divided by the total count.\nformula : The formula used for modeling.\n\n\n\nExamples\n\n# Assuming tree_data is defined\nresults &lt;- lfa_random_forest(tree_data, excluded_input_columns = c(\"column1\", \"column2\"))\n\n# Print the list of results\nprint(results)\n\n\n\nUsage\n\nlfa_random_forest(\n  tree_data,\n  excluded_input_columns,\n  response_variable = \"specie\",\n  ntree = 100,\n  seed = 123,\n  ...\n)\n\n\n\n\n6.5.45 lfa_rasterize_chunk\nRasterize Lidar Chunk\n\nArguments\n\n\n\n\n\n\n\nArgument\nDescription\n\n\n\n\nchunk\nLidar chunk object to be rasterized.\n\n\n...\nAdditional arguments to be passed to the underlying lidR::rasterize_canopy function.\n\n\n\n\n\nDescription\nThis function rasterizes a Lidar chunk to generate a raster representation of the canopy.\n\n\nDetails\nThe function takes a Lidar chunk as input and uses lidR::rasterize_canopy to generate a raster representation of the canopy. Additional arguments can be passed to customize the rasterization process.\n\n\nValue\nA raster layer representing the rasterized canopy.\n\n\nExamples\n\n# Example Lidar chunk\nlidar_chunk &lt;- readLAS(\"lidar_data.las\", select = \"xyz\")\n# Rasterize Lidar chunk\nrasterized_canopy &lt;- lfa_rasterize_chunk(lidar_chunk)\n\n\n\nUsage\n\nlfa_rasterize_chunk(chunk, ...)\n\n\n\n\n6.5.46 lfa_rd_to_qmd\nConvert Rd File to Markdown\n\nArguments\n\n\n\n\n\n\n\nArgument\nDescription\n\n\n\n\nrdfile\nThe path to the Rd file or a parsed Rd object.\n\n\noutfile\nThe path to the output Markdown file (including the file extension).\n\n\nappend\nLogical, indicating whether to append to an existing file (default is FALSE).\n\n\n\n\n\nDescription\nIMPORTANT NOTE: This function is nearly identical to the Rd2md::Rd2markdown function from the Rd2md package. We needed to implement our own version of it because of various reasons:\n\nThe algorithm uses hardcoded header sizes (h1 and h2 in original) which is not feasible for our use-case of the markdown.\nWe needed to add some Quarto Markdown specifics, e.g. to make sure that the examples will not be runned.\nWe want to exclude certain tags from our implementation.\n\n\n\nDetails\nFor that reason we copied the method and made changes as needed and also added this custom documentation.\nThis function converts an Rd (R documentation) file to Markdown format (.md) and saves the converted file at the specified location. The function allows appending to an existing file or creating a new one. The resulting Markdown file includes sections for the function’s name, title, and additional content such as examples, usage, arguments, and other sections present in the Rd file.\nThe function performs the following steps:\n\nParses the Rd file using the Rd2md package.\nCreates a Markdown file with sections for the function’s name, title, and additional content.\nAppends the content to an existing file if append is set to TRUE.\nSaves the resulting Markdown file at the specified location.\n\n\n\nSeealso\nRd2md::parseRd\n\n\nValue\nThis function does not explicitly return any value. It saves the converted Markdown file at the specified location as described in the details section.\n\n\nExamples\n\n# Convert Rd file to Markdown and save it\nlfa_rd_to_md(\"path/to/your/file.Rd\", \"path/to/your/output/file.md\")\n\n# Convert Rd file to Markdown and append to an existing file\nlfa_rd_to_md(\"path/to/your/file.Rd\", \"path/to/existing/output/file.md\", append = TRUE)\n\n\n\nUsage\n\nlfa_rd_to_qmd(rdfile, outfile, append = FALSE)\n\n\n\n\n6.5.47 lfa_rd_to_results\nConvert Rd Files to Markdown and Merge Results\n\nDescription\nThis function converts all Rd (R documentation) files in the “man” directory to Markdown format (.qmd) and saves the converted files in the “results/appendix/package-docs” directory. It then merges the converted Markdown files into a single string and saves the merged content into a file named “docs.qmd” in the “results/appendix/package-docs” directory.\n\n\nDetails\nThe function performs the following steps:\n\nRemoves any existing “docs.qmd” file in the “results/appendix/package-docs” directory.\nFinds all Rd files in the “man” directory.\nConverts each Rd file to Markdown format (.qmd) using the lfa_rd_to_qmd function.\nSaves the converted Markdown files in the “results/appendix/package-docs” directory.\nMerges the content of all converted Markdown files into a single string.\nSaves the merged content into a file named “docs.qmd” in the “results/appendix/package-docs” directory.\n\n\n\nSeealso\nlfa_rd_to_qmd , lfa_merge_and_save\n\n\nValue\nThis function does not explicitly return any value. It performs the conversion, merging, and saving operations as described in the details section.\n\n\nExamples\n\n# Convert Rd files to Markdown and merge the results\nlfa_rd_to_results()\n\n\n\nUsage\n\nlfa_rd_to_results()\n\n\n\n\n6.5.48 lfa_read_area_as_catalog\nRead LiDAR data from a specified species and location as a catalog.\n\nArguments\n\n\n\n\n\n\n\nArgument\nDescription\n\n\n\n\nspecie\nA character string specifying the species of interest.\n\n\nlocation_name\nA character string specifying the name of the location.\n\n\n\n\n\nDescription\nThis function constructs the file path based on the specified specie and location_name , lists the directories at that path, and reads the LiDAR data into a lidR::LAScatalog .\n\n\nValue\nA lidR::LAScatalog object containing the LiDAR data from the specified location and species.\n\n\nExamples\n\nlfa_read_area_as_catalog(\"beech\", \"location1\")\n\n\n\nUsage\n\nlfa_read_area_as_catalog(specie, location_name)\n\n\n\n\n6.5.49 lfa_recall_per_class\nCalculate Recall per Class from Confusion Matrix\n\nArguments\n\n\n\n\n\n\n\nArgument\nDescription\n\n\n\n\nconfusion_matrix\nConfusion matrix obtained from a classification evaluation.\n\n\n\n\n\nDescription\nThis function calculates recall for each class based on the provided confusion matrix.\n\n\nDetails\nRecall (Sensitivity or True Positive Rate) is a measure of the ability of a classification model to identify all relevant instances. It is calculated as the ratio of true positives to the sum of true positives and false negatives.\n\n\nSeealso\nlfa_precision_per_class\n\n\nValue\nA numeric vector representing recall for each class.\n\n\nExamples\n\n# Example confusion matrix\ncm &lt;- table(predicted = c(\"A\", \"B\", \"A\", \"B\"), actual = c(\"A\", \"A\", \"B\", \"B\"))\n# Calculate recall per class\nrecall_vector &lt;- lfa_recall_per_class(cm)\n\n\n\nUsage\n\nlfa_recall_per_class(confusion_matrix)\n\n\n\n\n6.5.50 lfa_run_test_asymmetric\nAsymmetric Pairwise Test for Categories\n\nArguments\n\n\n\n\n\n\n\nArgument\nDescription\n\n\n\n\ndata\nA data frame containing the relevant columns.\n\n\ndata_column\nA character string specifying the column containing the numerical data.\n\n\ncategory_column\nA character string specifying the column containing the categorical variable.\n\n\ntest_function\nA function used to perform the pairwise test between two sets of data. It should accept two vectors of numeric data and additional parameters specified by ... . The function should return a numeric value representing the test result.\n\n\n...\nAdditional parameters to be passed to the test_function .\n\n\n\n\n\nDescription\nThis function performs an asymmetric pairwise test for categories using a user-defined test_function .\n\n\nDetails\nThe function calculates the test results for each unique combination of categories using the specified test_function . The resulting table is asymmetric, containing the test results for comparisons from the rows to the columns.\n\n\nSeealso\nouter , Vectorize\n\n\nValue\nA data frame representing the results of the asymmetric pairwise tests between categories.\n\n\nExamples\n\n# Define a custom test function\ncustom_test_function &lt;- function(x, y) {\n# Your test logic here\n# Return a numeric result\nreturn(mean(x) - mean(y))\n}\n\n# Perform an asymmetric pairwise test\nresult &lt;- lfa_run_test_asymmetric(your_data, \"numeric_column\", \"category_column\", custom_test_function)\n\n\n\nUsage\n\nlfa_run_test_asymmetric(data, data_column, category_column, test_function, ...)\n\n\n\n\n6.5.51 lfa_run_test_symmetric\nSymmetric Pairwise Test for Categories\n\nArguments\n\n\n\n\n\n\n\nArgument\nDescription\n\n\n\n\ndata\nA data frame containing the relevant columns.\n\n\ndata_column\nA character string specifying the column containing the numerical data.\n\n\ncategory_column\nA character string specifying the column containing the categorical variable.\n\n\ntest_function\nA function used to perform the pairwise test between two sets of data. It should accept two vectors of numeric data and additional parameters specified by ... . The function should return a numeric value representing the test result.\n\n\n...\nAdditional parameters to be passed to the test_function .\n\n\n\n\n\nDescription\nThis function performs a symmetric pairwise test for categories using a user-defined test_function .\n\n\nDetails\nThe function calculates the test results for each unique combination of categories using the specified test_function . The resulting table is symmetric, containing the test results for comparisons from the rows to the columns. The upper triangle of the matrix is filled with NA to avoid duplicate results.\n\n\nSeealso\nouter , Vectorize\n\n\nValue\nA data frame representing the results of the symmetric pairwise tests between categories.\n\n\nExamples\n\n# Define a custom test function\ncustom_test_function &lt;- function(x, y) {\n# Your test logic here\n# Return a numeric result\nreturn(mean(x) - mean(y))\n}\n\n# Perform a symmetric pairwise test\nresult &lt;- lfa_run_test_symmetric(your_data, \"numeric_column\", \"category_column\", custom_test_function)\n\n\n\nUsage\n\nlfa_run_test_symmetric(data, data_column, category_column, test_function, ...)\n\n\n\n\n6.5.52 lfa_save_all_neighbours\nSave Neighbors for All Areas\n\nArguments\n\n\n\n\n\n\n\nArgument\nDescription\n\n\n\n\nn\nThe number of nearest trees to find for each tree (default is 100).\n\n\n\n\n\nDescription\nThis function iterates through all detection areas, finds the n nearest trees for each tree, and saves the result to a GeoPackage file for each area.\n\n\nExamples\n\n# Save neighbors for all areas with default value (n=100)\nlfa_save_all_neighbours()\n\n# Save neighbors for all areas with a specific value of n (e.g., n=50)\nlfa_save_all_neighbours(n = 50)\n\n\n\nUsage\n\nlfa_save_all_neighbours(n = 100)\n\n\n\n\n6.5.53 lfa_segmentation\nSegment the elements of an point cloud by trees\n\nArguments\n\n\n\n\n\n\n\nArgument\nDescription\n\n\n\n\nctg\nAn LASCatalog object. If not null, it will perform the actions on this object, if NULL inferring the catalog from the tile_location\n\n\ntile_location\nA tile_location type object holding the information about the location of the catalog. This is used to save the catalog after processing too.\n\n\n\n\n\nAuthor\nJakob Danel\n\n\nDescription\nThis function will try to to divide the hole point cloud into unique trees. Therefore it is assigning for each chunk of the catalog a treeID for each point. Therefore the algorithm uses the li2012 implementation with the following parameters: li2012(dt1 = 2, dt2 = 3, R = 2, Zu = 10, hmin = 5, speed_up = 12) NOTE : The operation is in place and can not be reverted, the old values of the point cloud will be deleted!\n\n\nValue\nA catalog where each chunk has additional treeID values indicating the belonging tree.\n\n\nUsage\n\nlfa_segmentation(ctg, tile_location)\n\n\n\n\n6.5.54 lfa_set_flag\nSet a flag to indicate the completion of a specific process.\n\nArguments\n\n\n\n\n\n\n\nArgument\nDescription\n\n\n\n\nflag_name\nA character string specifying the name of the flag file. It should be a descriptive and unique identifier for the process being flagged.\n\n\n\n\n\nDescription\nThis function creates a hidden flag file at a specified location within the working directory to indicate that a particular processing step has been completed. If the flag file already exists, a warning is issued.\n\n\nValue\nThis function does not have a formal return value.\n\n\nExamples\n\n# Set the flag for a process named \"data_processing\"\nlfa_set_flag(\"data_processing\")\n\n\n\nUsage\n\nlfa_set_flag(flag_name)\n\n\n\n\n6.5.55 lfa_visit_all_areas\nVisit All Areas and Apply Preprocessing Function\n\nArguments\n\n\n\n\n\n\n\nArgument\nDescription\n\n\n\n\npreprocessing_function\nThe preprocessing function to be applied to each area. It should take specie, area, and additional parameters as inputs.\n\n\nareas\nData frame containing information about different areas, including columns “specie” and “area.”\n\n\n...\nAdditional arguments to be passed to the preprocessing function.\n\n\n\n\n\nDescription\nThis function iterates over all specified areas and applies a preprocessing function to each one.\n\n\nDetails\nThe function iterates over all areas specified in the ‘areas’ parameter, and for each area, it applies the provided preprocessing function. The ‘areas’ parameter is expected to be a data frame with columns “specie” and “area,” containing information about different areas to visit. Additional arguments passed via ‘…’ are forwarded to the preprocessing function.\n\n\nSeealso\nlfa_get_all_areas\n\n\nValue\nA list containing the results of applying the preprocessing function to each area.\n\n\nExamples\n\n# Example preprocessing function\nmy_preprocessing_function &lt;- function(specie, area, ...) {\n# Your preprocessing logic here\n# Return the result\nreturn(result)\n}\n# Visit all areas and apply the preprocessing function\nresults_list &lt;- lfa_visit_all_areas(my_preprocessing_function)\n\n\n\nUsage\n\nlfa_visit_all_areas(preprocessing_function, areas = lfa_get_all_areas(), ...)\n\n\n\n\n6.5.56 lfa_visualize_rf_metrics\nVisualize Precision and Recall Metrics for Random Forest Classification\n\nArguments\n\n\n\n\n\n\n\nArgument\nDescription\n\n\n\n\nmetrics_df\nData frame containing precision and recall metrics for each class.\n\n\n\n\n\nDescription\nThis function creates a bar plot to visualize precision and recall metrics for each class obtained from a Random Forest classification.\n\n\nDetails\nThe function creates a bar plot to visualize precision and recall metrics for each class obtained from a Random Forest classification.\n\n\nSeealso\nlfa_calculate_rf_metrics\n\n\nValue\nA ggplot object representing the bar plot of precision and recall metrics.\n\n\nExamples\n\n# Example data frame containing precision and recall metrics\nexample_metrics_df &lt;- data.frame(\nClass = c(\"ClassA\", \"ClassB\"),\nPrecision = c(0.85, 0.92),\nRecall = c(0.78, 0.88)\n)\n# Visualize precision and recall metrics\nlfa_visualize_rf_metrics(example_metrics_df)\n\n\n\nUsage\n\nlfa_visualize_rf_metrics(metrics_df)"
  },
  {
    "objectID": "report.html#canopy-height-models",
    "href": "report.html#canopy-height-models",
    "title": "Evaluating Tree Species Diversity in Forest Ecosystems Using LiDAR Data: A Exploration in NRW",
    "section": "6.3 Canopy Height Models",
    "text": "6.3 Canopy Height Models\nThe following section contains all canopy height models of the researched patches, plotted.\n\nlibrary(raster)\n\nLoading required package: sp\n\nchms &lt;- lfa::lfa_visit_all_areas(lfa::lfa_chm)\n\n[1] \"Load /home/jakob/gi-master/project-courses/lidar-forest-analysis/src/data/beech/bielefeld_brackwede/chm.tif\"\n[1] \"Load /home/jakob/gi-master/project-courses/lidar-forest-analysis/src/data/beech/billerbeck/chm.tif\"\n[1] \"Load /home/jakob/gi-master/project-courses/lidar-forest-analysis/src/data/beech/wuelfenrath/chm.tif\"\n[1] \"Load /home/jakob/gi-master/project-courses/lidar-forest-analysis/src/data/oak/hamm/chm.tif\"\n[1] \"Load /home/jakob/gi-master/project-courses/lidar-forest-analysis/src/data/oak/muenster/chm.tif\"\n[1] \"Load /home/jakob/gi-master/project-courses/lidar-forest-analysis/src/data/oak/rinkerode/chm.tif\"\n[1] \"Load /home/jakob/gi-master/project-courses/lidar-forest-analysis/src/data/pine/greffen/chm.tif\"\n[1] \"Load /home/jakob/gi-master/project-courses/lidar-forest-analysis/src/data/pine/mesum/chm.tif\"\n[1] \"Load /home/jakob/gi-master/project-courses/lidar-forest-analysis/src/data/pine/telgte/chm.tif\"\n[1] \"Load /home/jakob/gi-master/project-courses/lidar-forest-analysis/src/data/spruce/brilon/chm.tif\"\n[1] \"Load /home/jakob/gi-master/project-courses/lidar-forest-analysis/src/data/spruce/oberhundem/chm.tif\"\n[1] \"Load /home/jakob/gi-master/project-courses/lidar-forest-analysis/src/data/spruce/osterwald/chm.tif\"\n\nchms$rinkerode[chms$rinkerode &gt; 50] &lt;- NA\n\n\n\nCode\nchms$bielefeld_brackwede |&gt; plot(main = \"Canopy Height Model: Bielefeld Brackwede (Beech\")\n\n\n\n\n\nCanopy Height Model of the patch Bielefeld Brackwede (Beech) colorized by the canopy height.\n\n\n\n\n\n\nCode\nchms$billerbeck |&gt; plot(main = \"Canopy Height Model: Billerbeck (Beech\")\n\n\n\n\n\nCanopy Height Model of the patch Billerbeck (Beech) colorized by the canopy height.\n\n\n\n\n\n\nCode\nchms$wuelfenrath |&gt; plot(main = \"Canopy Height Model: Wülfenrath (Beech\")\n\n\n\n\n\nCanopy Height Model of the patch Wülfenrath (Beech) colorized by the canopy height.\n\n\n\n\n\n\nCode\nchms$hamm |&gt; plot(main = \"Canopy Height Model: Hamm (Oak)\")\n\n\n\n\n\nCanopy Height Model of the patch Hamm (Oak) colorized by the canopy height.\n\n\n\n\n\n\nCode\nchms$muenster |&gt; plot(main = \"Canopy Height Model: Münster (Oak)\")\n\n\n\n\n\nCanopy Height Model of the patch Münster (Oak) colorized by the canopy height.\n\n\n\n\n\n\nCode\nchms$rinkerode |&gt; plot(main = \"Canopy Height Model: Rinkerode (Oak)\")\n\n\n\n\n\nCanopy Height Model of the patch Rinkerode (Oak) colorized by the canopy height.\n\n\n\n\n\n\nCode\nchms$greffen |&gt; plot(main = \"Canopy Height Model: Greffen (Pine)\")\n\n\n\n\n\nCanopy Height Model of the patch Greffen (Pine) colorized by the canopy height.\n\n\n\n\n\n\nCode\nchms$mesum |&gt; plot(main = \"Canopy Height Model: Mesum (Pine)\")\n\n\n\n\n\nCanopy Height Model of the patch Mesum (Pine) colorized by the canopy height.\n\n\n\n\n\n\nCode\nchms$telgte |&gt; plot(main = \"Canopy Height Model: Telgte (Pine)\")\n\n\n\n\n\nCanopy Height Model of the patch Telgte (Pine) colorized by the canopy height.\n\n\n\n\n\n\nCode\nchms$brilon |&gt; plot(main = \"Canopy Height Model: Brilon (Spruce)\")\n\n\n\n\n\nCanopy Height Model of the patch Brilon (Spruce) colorized by the canopy height.\n\n\n\n\n\n\nCode\nchms$oberhundem |&gt; plot(main = \"Canopy Height Model: Oberhundem (Spruce)\")\n\n\n\n\n\nCanopy Height Model of the patch Oberhundem (Spruce) colorized by the canopy height.\n\n\n\n\n\n\nCode\nchms$osterwald |&gt; plot(main = \"Canopy Height Model: Osterwald (Spruce)\")\n\n\n\n\n\nCanopy Height Model of the patch Osterwald (Spruce) colorized by the canopy height."
  },
  {
    "objectID": "report.html#contributions",
    "href": "report.html#contributions",
    "title": "Evaluating Tree Species Diversity in Forest Ecosystems Using LiDAR Data: A Exploration in NRW",
    "section": "6.1 Contributions",
    "text": "6.1 Contributions\nMost of the work was done in pair programming. In the following sections we highlight, our key contributions to the project.\n\n6.1.1 Frederick\nMy contributions to the project encompassed several key areas: data acquisition, preprocessing, visualization, random forest implementation, and canopy height modeling. Each of these tasks presented unique challenges and learning opportunities.\n\nData Acquisition\nMy role in data acquisition involved sourcing relevant datasets for our study, particularly focusing on obtaining patches where one tree species exhibited dominance. This process involved navigating through existing datasets such as the Waldmonitor dataset and utilizing maps indicating dominant tree species in Nordrhein-Westfalia (NRW). One of the challenges encountered was ensuring the validity of the selected patches, considering factors such as patch size, species diversity, and the absence of human-made structures. Through this process, I learned the importance of meticulous data selection and validation to ensure the integrity of subsequent analyses.\n\n\nPreprocessing: Tiling/Height Normalization\nPreprocessing the acquired data was essential to derive meaningful variables for analysis. Tiling and height normalization were particularly crucial steps to standardize the data and facilitate further analysis. Tiling involved partitioning the patches into smaller, manageable units, while height normalization ensured consistency in height measurements across different patches. This process taught me the importance of data standardization and the impact it can have on downstream analyses.\n\n\nVisualization: Density and Boxplot\nVisualizing the data through density plots and boxplots was instrumental in gaining insights into the distribution and characteristics of the variables under study. Creating informative visualizations required careful selection of plotting parameters and consideration of the audience’s interpretation. Balancing clarity and complexity posed a challenge, but it also provided an opportunity to enhance my visualization skills and effectively communicate key findings.\n\n\nRandom Forest: Scores and Confusion Matrix\nImplementing the Random Forest algorithm for species classification involved several steps, including model training, validation, and performance evaluation. Generating scores and confusion matrices allowed us to assess the model’s accuracy and identify areas for improvement.\n\n\nCanopy Height Model\nDeveloping a canopy height model involved integrating data from various sources to estimate the height of forest canopies. Overcoming technical challenges and refining the model parameters provided valuable insights into remote sensing techniques and their applicability in forestry research.\nIn summary, my contributions to the project encompassed a range of tasks, each presenting its own set of challenges and learning opportunities. From data acquisition to model implementation, I gained valuable experience in ecological research methods and data analysis techniques.\n\n\n\n6.1.2 Jakob\nIn the broader context of a comprehensive lidar data analysis project, my contributions were instrumental in advancing key components. The preprocessing phase saw enhancements in Intersection, Detection, and Segmentation processes. I played a pivotal role in refining Intersection by overlaying lidar data onto shapefiles, ensuring a coherent file structure. Additionally, my efforts in Detection focused on optimizing tree identification within the intersected data. I developed the tree Segmentation too.\nIn terms of visualization, my contributions elevated the understanding of lidar data. The presentation of the confusion matrix as a colored table provided a comprehensive view of classification performance. Through the implementation of bar plots for patch-level data, I contributed to insights into the distribution of features. Precision and recall metrics were effectively communicated via bar plots, offering a nuanced evaluation of the model’s performance. The integration of Canopy Height Plots further enriched the visual representation of canopy structures.\nWithin the tree-level distribution analysis, my role extended to Data Preparation and the application of KLD and JSD. I ensured that the dataset was well-structured and prepared for analysis. Moreover, my involvement in researching methods, implementing calculations, and dynamically building result tables for KLD and JSD significantly contributed to the depth of the analysis.\nIn the development of an interface for Lidar data, I played a crucial role in designing a structured file system for efficient data storage. The implementation of various functions, including lfa::map_tile_locations, lfa::visit_all_areas, and lfa::combine_sf_object, showcased my commitment to enhancing data iteration and combination processes.\nThroughout the project, my contributions led to valuable learnings for the team. I actively addressed challenges associated with handling big data in R and underscored the importance of structured data storage. The development of an R-package was a testament to my commitment to enhancing functionality and promoting reusability. Additionally, my insights deepened the team’s understanding of package workflows in R.\nDespite encountering challenges with lidR mapping functions, my proactive approach to debugging, including the development of a custom mapping solution, showcased my resilience and commitment to overcoming obstacles. In summary, my contributions significantly shaped the success and advancement of the broader lidar data analysis project."
  },
  {
    "objectID": "report.html#sec-appendix-chms",
    "href": "report.html#sec-appendix-chms",
    "title": "Evaluating Tree Species Diversity in Forest Ecosystems Using LiDAR Data: A Exploration in NRW",
    "section": "6.3 Canopy Height Models",
    "text": "6.3 Canopy Height Models\nThe following section contains all canopy height models of the researched patches, plotted.\n\nlibrary(raster)\n\nLoading required package: sp\n\nchms &lt;- lfa::lfa_visit_all_areas(lfa::lfa_chm)\n\n[1] \"Load /home/jakob/gi-master/project-courses/lidar-forest-analysis/src/data/beech/bielefeld_brackwede/chm.tif\"\n[1] \"Load /home/jakob/gi-master/project-courses/lidar-forest-analysis/src/data/beech/billerbeck/chm.tif\"\n[1] \"Load /home/jakob/gi-master/project-courses/lidar-forest-analysis/src/data/beech/wuelfenrath/chm.tif\"\n[1] \"Load /home/jakob/gi-master/project-courses/lidar-forest-analysis/src/data/oak/hamm/chm.tif\"\n[1] \"Load /home/jakob/gi-master/project-courses/lidar-forest-analysis/src/data/oak/muenster/chm.tif\"\n[1] \"Load /home/jakob/gi-master/project-courses/lidar-forest-analysis/src/data/oak/rinkerode/chm.tif\"\n[1] \"Load /home/jakob/gi-master/project-courses/lidar-forest-analysis/src/data/pine/greffen/chm.tif\"\n[1] \"Load /home/jakob/gi-master/project-courses/lidar-forest-analysis/src/data/pine/mesum/chm.tif\"\n[1] \"Load /home/jakob/gi-master/project-courses/lidar-forest-analysis/src/data/pine/telgte/chm.tif\"\n[1] \"Load /home/jakob/gi-master/project-courses/lidar-forest-analysis/src/data/spruce/brilon/chm.tif\"\n[1] \"Load /home/jakob/gi-master/project-courses/lidar-forest-analysis/src/data/spruce/oberhundem/chm.tif\"\n[1] \"Load /home/jakob/gi-master/project-courses/lidar-forest-analysis/src/data/spruce/osterwald/chm.tif\"\n\nchms$rinkerode[chms$rinkerode &gt; 50] &lt;- NA\n\n\n\nCode\nchms$bielefeld_brackwede |&gt; plot(main = \"Canopy Height Model: Bielefeld Brackwede (Beech\")\n\n\n\n\n\nCanopy Height Model of the patch Bielefeld Brackwede (Beech) colorized by the canopy height.\n\n\n\n\n\n\nCode\nchms$billerbeck |&gt; plot(main = \"Canopy Height Model: Billerbeck (Beech\")\n\n\n\n\n\nCanopy Height Model of the patch Billerbeck (Beech) colorized by the canopy height.\n\n\n\n\n\n\nCode\nchms$wuelfenrath |&gt; plot(main = \"Canopy Height Model: Wülfenrath (Beech\")\n\n\n\n\n\nCanopy Height Model of the patch Wülfenrath (Beech) colorized by the canopy height.\n\n\n\n\n\n\nCode\nchms$hamm |&gt; plot(main = \"Canopy Height Model: Hamm (Oak)\")\n\n\n\n\n\nCanopy Height Model of the patch Hamm (Oak) colorized by the canopy height.\n\n\n\n\n\n\nCode\nchms$muenster |&gt; plot(main = \"Canopy Height Model: Münster (Oak)\")\n\n\n\n\n\nCanopy Height Model of the patch Münster (Oak) colorized by the canopy height.\n\n\n\n\n\n\nCode\nchms$rinkerode |&gt; plot(main = \"Canopy Height Model: Rinkerode (Oak)\")\n\n\n\n\n\nCanopy Height Model of the patch Rinkerode (Oak) colorized by the canopy height.\n\n\n\n\n\n\nCode\nchms$greffen |&gt; plot(main = \"Canopy Height Model: Greffen (Pine)\")\n\n\n\n\n\nCanopy Height Model of the patch Greffen (Pine) colorized by the canopy height.\n\n\n\n\n\n\nCode\nchms$mesum |&gt; plot(main = \"Canopy Height Model: Mesum (Pine)\")\n\n\n\n\n\nCanopy Height Model of the patch Mesum (Pine) colorized by the canopy height.\n\n\n\n\n\n\nCode\nchms$telgte |&gt; plot(main = \"Canopy Height Model: Telgte (Pine)\")\n\n\n\n\n\nCanopy Height Model of the patch Telgte (Pine) colorized by the canopy height.\n\n\n\n\n\n\nCode\nchms$brilon |&gt; plot(main = \"Canopy Height Model: Brilon (Spruce)\")\n\n\n\n\n\nCanopy Height Model of the patch Brilon (Spruce) colorized by the canopy height.\n\n\n\n\n\n\nCode\nchms$oberhundem |&gt; plot(main = \"Canopy Height Model: Oberhundem (Spruce)\")\n\n\n\n\n\nCanopy Height Model of the patch Oberhundem (Spruce) colorized by the canopy height.\n\n\n\n\n\n\nCode\nchms$osterwald |&gt; plot(main = \"Canopy Height Model: Osterwald (Spruce)\")\n\n\n\n\n\nCanopy Height Model of the patch Osterwald (Spruce) colorized by the canopy height."
  }
]